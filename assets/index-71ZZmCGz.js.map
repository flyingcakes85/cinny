{"version":3,"mappings":"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","names":["l","p","r","t","u","v","w","z","A","a","B","D","E","b","e","F","G","H","C","I","J","K","L","d","c","k","g","m","h","N","O","P","escape","n","R","f","S","T","U","V","W","react_production_min","q","M","y","require$$0","reactJsxRuntime_production_min","La","Oa","yf","Af","zf","Bf","Df","Ff","Gf","Hf","Jf","If","bd","Nf","Pf","of","Wc","uf","Mf","Cb","ue","Db","Sf","Tf","Uf","Vf","Xf","Yf","Wf","bg","eg","hg","jg","gg","ac","lg","ng","og","qg","rg","kg","mg","ug","pg","sg","vg","tg","wg","yg","Ag","Cg","xg","Bg","Dg","Eg","Lf","Gg","Fg","Ef","Hg","Ig","zg","Kg","Lg","Mg","Ng","Pg","Qg","Rg","Sg","Tg","Og","Ug","Xg","Wg","Yg","Zg","$g","ah","bh","eh","Cc","fh","gh","hh","jh","aa","lh","ch","dh","mh","Ie","ph","Vg","nh","qh","rh","kh","sh","th","uh","vh","xh","ya","Ha","zh","Ah","Ka","va","wa","x","yh","Dh","Eh","Fh","Gh","lb","Jh","Hh","Mh","Oh","Ph","ua","Qh","Sh","Th","Vh","Q","Wh","He","Xh","Rh","Zh","$h","ai","bi","Uh","di","gi","hi","ki","ni","oi","pi","qi","ri","li","si","ui","vi","ti","xi","yi","zi","Ai","Ci","Di","yc","Fi","Hi","Ii","Ji","Yh","ci","Gi","Ei","Bi","ji","wi","fi","ei","ii","Ki","Pa","Li","Mi","Ni","Oi","Pi","Ri","Si","Ti","Vi","Xi","Ch","Bh","Zi","$i","Yi","aj","bj","cj","wh","dj","ej","fj","gj","hj","Zf","cg","jj","oh","xj","zj","lj","Kh","Ih","yj","Bj","Dj","Cj","Ya","gb","ea","Ej","Fj","$f","lf","Za","hb","ub","Va","kb","hasOwn","arg","_extends","formMethod","formAction","opts","getInvalidBodyError","json","invariant","searchParams","formData","convertSearchParamsToFormData","target","i","source","key","DataRouterContext","DataRouterStateContext","NavigationContext","LocationContext","React.createContext","RouteContext","RouteErrorContext","useHref","to","_temp","useInRouterContext","UNSAFE_invariant","basename","React.useContext","useResolvedPath","joinedPathname","pathname","joinPaths","hash","useLocation","useMatch","React.useMemo","pattern","React.useLayoutEffect","useNavigate","isDataRoute","useNavigateStable","useNavigateUnstable","dataRouterContext","navigator","routePathnamesJson","UNSAFE_getResolveToMatches","activeRef","React.useRef","useIsomorphicLayoutEffect","React.useCallback","options","path","resolveTo","locationPathname","OutletContext","useOutlet","outlet","React.createElement","context","useParams","matches","routeMatch","_temp2","relative","useRoutesImpl","routes","locationArg","dataRouterState","parentMatches","_arrayLikeToArray","_arrayWithoutHoles","_toPropertyKey","normalCompletion","didErr","err","it","o","step","_e2","_unsupportedIterableToArray","minLen","arr","len","arr2","instance","_defineProperties","props","descriptor","protoProps","staticProps","Constructor","value","obj","NamespacedMap","initial","_defineProperty","_iterator","_createForOfIteratorHelper","val","_createClass","_content2","_content3","PollStartEvent","_message_types","_poll_types","kind","answers","_ExtensibleEvent2","PollStartEvent_1","makeId","_toConsumableArray","LETTERS","relationship_types","_NamespacedValue","REFERENCE_RELATION","_typeof","PollResponseEvent_1","_InvalidEventError","require$$2","_relationship_types","require$$3","_classCallCheck","superClass","subClass","_setPrototypeOf","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","Super","_getPrototypeOf","NewTarget","result","_possibleConstructorReturn","self","call","_ExtensibleEvent","_inherits","_this","_super","_assertThisInitialized","rel","PollResponseEvent","response","poll","pa","primaryEventType","pollEventId","PollEndEvent_1","require$$1","_MessageEvent","require$$4","_events","require$$6","ownKeys","enumerableOnly","object","symbols","sym","keys","_objectSpread","_createSuper","PollEndEvent","wireFormat","_content","message","MPoll","parseMPoll","_PollStartEvent","_PollResponseEvent","wireEvent","ExtensibleEvents_1","_NamespacedMap","_MMessage","require$$5","_MPoll","allowArrayLike","_e","_this$thread","event","_this$thread2","eventDebugString","eventId","timeline","toStartOfTimeline","roomState","addToState","RoomEvent","data","_this$thread3","PARAM_REGEXP","QESC_REGEXP","TYPE_REGEXP","parse","string","getcontenttype","header","index","type","ContentType","match","timeoutSignal","controller","anySignal","signals","cleanup","signal","onAbort","parseErrorResponse","body","_contentType","_contentType2","httpHeaders","isXhr","colonIdx","contentType","getResponseContentType","MatrixError","HTTPError","headers","parseContentType","retryNetworkOperation","_x","_x2","_retryNetworkOperation","_asyncToGenerator","maxAttempts","callback","attempts","timeout","logger","sleep","ConnectionError","calculateRetryBackoff","retryConnectionError","safeGetRetryAfterMs","TokenRefreshOutcome","REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS","REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS","TokenRefresher","writer","write","parser","toBase64","uint8Array","current","base64","encodeBase64","fromBase64","decodeBase64","LOWERCASE","UPPERCASE","DIGITS","secureRandomBase64Url","encodeUnpaddedBase64Url","secureRandomStringFrom","chars","reactIs_production_min","global","factory","module","this","exports","map","values","name","createEvent","evt","assign","ta","clientWidth","cachedHeight","init","style","heightOffset","update","changeOverflow","width","getParentOverflows","el","resize","docTop","styleHeight","actualHeight","computed","pageResize","destroy","methods","autosize","computedStyle","prop","getComputedStyle","word","computedStyle_commonjs","lineHeight","node","lnHeightStr","_lnHeightStyle","lnHeight","nodeName","fontSizeStr","_node","height","__extends","__","s","__rest","TextareaAutosize","React","getLineHeight","_getLineHeight","RESIZED","TextareaAutosizeClass","onChange","_a","maxRows","async","_b","maxHeight","__assign","element","children","PropTypes","ref","Input","label","required","minHeight","state","disabled","jsx","id","onResize","onKeyDown","autoFocus","forwardRef","placeholder","ScrollView","horizontal","vertical","autoHide","invisible","onScroll","scrollbarClasses","ContextMenu","content","placement","maxWidth","render","afterToggle","useState","showMenu","setVisibility","useEffect","isVisible","Tippy","hideMenu","MenuHeader","MenuItem","variant","iconSrc","onClick","Header","TitleWrapper","findTabbableDescendants","DISPLAY_NONE","DISPLAY_CONTENTS","tabbableNode","isNotOverflowing","hidesContents","displayValue"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,43],"sources":["../../node_modules/react/cjs/react.production.min.js","../../node_modules/react/index.js","../../node_modules/react/cjs/react-jsx-runtime.production.min.js","../../node_modules/react/jsx-runtime.js","../../node_modules/scheduler/cjs/scheduler.production.min.js","../../node_modules/react-dom/cjs/react-dom.production.min.js","../../node_modules/classnames/index.js","../../node_modules/@remix-run/router/dist/router.js","../../node_modules/react-router/dist/index.js","../../node_modules/react-router-dom/dist/index.js","../../node_modules/tabbable/dist/index.esm.js","../../node_modules/focus-trap/dist/focus-trap.esm.js","../../node_modules/matrix-events-sdk/lib/NamespacedMap.js","../../node_modules/matrix-events-sdk/lib/events/PollStartEvent.js","../../node_modules/matrix-events-sdk/lib/events/relationship_types.js","../../node_modules/matrix-events-sdk/lib/events/PollResponseEvent.js","../../node_modules/matrix-events-sdk/lib/events/PollEndEvent.js","../../node_modules/matrix-events-sdk/lib/interpreters/modern/MPoll.js","../../node_modules/matrix-events-sdk/lib/ExtensibleEvents.js","../../node_modules/matrix-js-sdk/lib/models/event-timeline-set.js","../../node_modules/content-type/index.js","../../node_modules/matrix-js-sdk/lib/http-api/utils.js","../../node_modules/matrix-js-sdk/lib/http-api/refresh.js","../../node_modules/sdp-transform/lib/writer.js","../../node_modules/sdp-transform/lib/index.js","../../node_modules/matrix-js-sdk/lib/base64.js","../../node_modules/matrix-js-sdk/lib/randomstring.js","../../node_modules/matrix-js-sdk/lib/matrixrtc/NewMembershipManagerActionScheduler.js","../../node_modules/matrix-js-sdk/lib/client.js","../../node_modules/matrix-widget-api/lib/models/WidgetEventCapability.js","../../node_modules/matrix-widget-api/lib/util/SimpleObservable.js","../../node_modules/matrix-widget-api/lib/ClientWidgetApi.js","../../node_modules/matrix-widget-api/lib/models/WidgetParser.js","../../node_modules/react-is/cjs/react-is.production.min.js","../../node_modules/autosize/dist/autosize.js","../../node_modules/computed-style/dist/computedStyle.commonjs.js","../../node_modules/line-height/lib/line-height.js","../../node_modules/react-autosize-textarea/lib/TextareaAutosize.js","../../node_modules/react-autosize-textarea/lib/index.js","../../src/app/atoms/input/Input.jsx","../../src/app/atoms/scroll/ScrollView.jsx","../../src/app/atoms/context-menu/ContextMenu.jsx","../../src/app/atoms/header/Header.jsx","../../node_modules/react-modal/lib/helpers/tabbable.js"],"sourcesContent":["/**\n * @license React\n * react.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var l=Symbol.for(\"react.element\"),n=Symbol.for(\"react.portal\"),p=Symbol.for(\"react.fragment\"),q=Symbol.for(\"react.strict_mode\"),r=Symbol.for(\"react.profiler\"),t=Symbol.for(\"react.provider\"),u=Symbol.for(\"react.context\"),v=Symbol.for(\"react.forward_ref\"),w=Symbol.for(\"react.suspense\"),x=Symbol.for(\"react.memo\"),y=Symbol.for(\"react.lazy\"),z=Symbol.iterator;function A(a){if(null===a||\"object\"!==typeof a)return null;a=z&&a[z]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}\nvar B={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}E.prototype.isReactComponent={};\nE.prototype.setState=function(a,b){if(\"object\"!==typeof a&&\"function\"!==typeof a&&null!=a)throw Error(\"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\");this.updater.enqueueSetState(this,a,b,\"setState\")};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,\"forceUpdate\")};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B}var H=G.prototype=new F;\nH.constructor=G;C(H,E.prototype);H.isPureReactComponent=!0;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:!0,ref:!0,__self:!0,__source:!0};\nfunction M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=\"\"+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f}if(a&&a.defaultProps)for(d in g=a.defaultProps,g)void 0===c[d]&&(c[d]=g[d]);return{$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}\nfunction N(a,b){return{$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={\"=\":\"=0\",\":\":\"=2\"};return\"$\"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\\/+/g;function Q(a,b){return\"object\"===typeof a&&null!==a&&null!=a.key?escape(\"\"+a.key):b.toString(36)}\nfunction R(a,b,e,d,c){var k=typeof a;if(\"undefined\"===k||\"boolean\"===k)a=null;var h=!1;if(null===a)h=!0;else switch(k){case \"string\":case \"number\":h=!0;break;case \"object\":switch(a.$$typeof){case l:case n:h=!0}}if(h)return h=a,c=c(h),a=\"\"===d?\".\"+Q(h,0):d,I(c)?(e=\"\",null!=a&&(e=a.replace(P,\"$&/\")+\"/\"),R(c,b,e,\"\",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?\"\":(\"\"+c.key).replace(P,\"$&/\")+\"/\")+a)),b.push(c)),1;h=0;d=\"\"===d?\".\":d+\":\";if(I(a))for(var g=0;g<a.length;g++){k=\na[g];var f=d+Q(k,g);h+=R(k,b,e,f,c)}else if(f=A(a),\"function\"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if(\"object\"===k)throw b=String(a),Error(\"Objects are not valid as a React child (found: \"+(\"[object Object]\"===b?\"object with keys {\"+Object.keys(a).join(\", \")+\"}\":b)+\"). If you meant to render a collection of children, use an array instead.\");return h}\nfunction S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,\"\",\"\",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b});-1===a._status&&(a._status=0,a._result=b)}if(1===a._status)return a._result.default;throw a._result;}\nvar U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};exports.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments)},e)},count:function(a){var b=0;S(a,function(){b++});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error(\"React.Children.only expected to receive a single React element child.\");return a}};exports.Component=E;exports.Fragment=p;\nexports.Profiler=r;exports.PureComponent=G;exports.StrictMode=q;exports.Suspense=w;exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;\nexports.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error(\"React.cloneElement(...): The argument must be a React element, but you passed \"+a+\".\");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=\"\"+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f])}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);\nfor(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g}return{$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};exports.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};exports.createElement=M;exports.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};exports.createRef=function(){return{current:null}};\nexports.forwardRef=function(a){return{$$typeof:v,render:a}};exports.isValidElement=O;exports.lazy=function(a){return{$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};exports.memo=function(a,b){return{$$typeof:x,type:a,compare:void 0===b?null:b}};exports.startTransition=function(a){var b=V.transition;V.transition={};try{a()}finally{V.transition=b}};exports.unstable_act=function(){throw Error(\"act(...) is not supported in production builds of React.\");};\nexports.useCallback=function(a,b){return U.current.useCallback(a,b)};exports.useContext=function(a){return U.current.useContext(a)};exports.useDebugValue=function(){};exports.useDeferredValue=function(a){return U.current.useDeferredValue(a)};exports.useEffect=function(a,b){return U.current.useEffect(a,b)};exports.useId=function(){return U.current.useId()};exports.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};\nexports.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};exports.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};exports.useMemo=function(a,b){return U.current.useMemo(a,b)};exports.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};exports.useRef=function(a){return U.current.useRef(a)};exports.useState=function(a){return U.current.useState(a)};exports.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};\nexports.useTransition=function(){return U.current.useTransition()};exports.version=\"18.2.0\";\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","/**\n * @license React\n * react-jsx-runtime.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';var f=require(\"react\"),k=Symbol.for(\"react.element\"),l=Symbol.for(\"react.fragment\"),m=Object.prototype.hasOwnProperty,n=f.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,p={key:!0,ref:!0,__self:!0,__source:!0};\nfunction q(c,a,g){var b,d={},e=null,h=null;void 0!==g&&(e=\"\"+g);void 0!==a.key&&(e=\"\"+a.key);void 0!==a.ref&&(h=a.ref);for(b in a)m.call(a,b)&&!p.hasOwnProperty(b)&&(d[b]=a[b]);if(c&&c.defaultProps)for(b in a=c.defaultProps,a)void 0===d[b]&&(d[b]=a[b]);return{$$typeof:k,type:c,key:e,ref:h,props:d,_owner:n.current}}exports.Fragment=l;exports.jsx=q;exports.jsxs=q;\n","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react-jsx-runtime.production.min.js');\n} else {\n  module.exports = require('./cjs/react-jsx-runtime.development.js');\n}\n","/**\n * @license React\n * scheduler.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n'use strict';function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}\nfunction g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if(\"object\"===typeof performance&&\"function\"===typeof performance.now){var l=performance;exports.unstable_now=function(){return l.now()}}else{var p=Date,q=p.now();exports.unstable_now=function(){return p.now()-q}}var r=[],t=[],u=1,v=null,y=3,z=!1,A=!1,B=!1,D=\"function\"===typeof setTimeout?setTimeout:null,E=\"function\"===typeof clearTimeout?clearTimeout:null,F=\"undefined\"!==typeof setImmediate?setImmediate:null;\n\"undefined\"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t)}}function H(a){B=!1;G(a);if(!A)if(null!==h(r))A=!0,I(J);else{var b=h(t);null!==b&&K(H,b.startTime-a)}}\nfunction J(a,b){A=!1;B&&(B=!1,E(L),L=-1);z=!0;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if(\"function\"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports.unstable_now();\"function\"===typeof e?v.callback=e:v===h(r)&&k(r);G(b)}else k(r);v=h(r)}if(null!==v)var w=!0;else{var m=h(t);null!==m&&K(H,m.startTime-b);w=!1}return w}finally{v=null,y=c,z=!1}}var N=!1,O=null,L=-1,P=5,Q=-1;\nfunction M(){return exports.unstable_now()-Q<P?!1:!0}function R(){if(null!==O){var a=exports.unstable_now();Q=a;var b=!0;try{b=O(!0,a)}finally{b?S():(N=!1,O=null)}}else N=!1}var S;if(\"function\"===typeof F)S=function(){F(R)};else if(\"undefined\"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null)}}else S=function(){D(R,0)};function I(a){O=a;N||(N=!0,S())}function K(a,b){L=D(function(){a(exports.unstable_now())},b)}\nexports.unstable_IdlePriority=5;exports.unstable_ImmediatePriority=1;exports.unstable_LowPriority=4;exports.unstable_NormalPriority=3;exports.unstable_Profiling=null;exports.unstable_UserBlockingPriority=2;exports.unstable_cancelCallback=function(a){a.callback=null};exports.unstable_continueExecution=function(){A||z||(A=!0,I(J))};\nexports.unstable_forceFrameRate=function(a){0>a||125<a?console.error(\"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"):P=0<a?Math.floor(1E3/a):5};exports.unstable_getCurrentPriorityLevel=function(){return y};exports.unstable_getFirstCallbackNode=function(){return h(r)};exports.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y}var c=y;y=b;try{return a()}finally{y=c}};exports.unstable_pauseExecution=function(){};\nexports.unstable_requestPaint=function(){};exports.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3}var c=y;y=a;try{return b()}finally{y=c}};\nexports.unstable_scheduleCallback=function(a,b,c){var d=exports.unstable_now();\"object\"===typeof c&&null!==c?(c=c.delay,c=\"number\"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=!0,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=!0,I(J)));return a};\nexports.unstable_shouldYield=M;exports.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c}}};\n","/**\n * @license React\n * react-dom.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n'use strict';var aa=require(\"react\"),ca=require(\"scheduler\");function p(a){for(var b=\"https://reactjs.org/docs/error-decoder.html?invariant=\"+a,c=1;c<arguments.length;c++)b+=\"&args[]=\"+encodeURIComponent(arguments[c]);return\"Minified React error #\"+a+\"; visit \"+b+\" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+\"Capture\",b)}\nfunction ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a])}\nvar ia=!(\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$/,la=\n{},ma={};function oa(a){if(ja.call(ma,a))return!0;if(ja.call(la,a))return!1;if(ka.test(a))return ma[a]=!0;la[a]=!0;return!1}function pa(a,b,c,d){if(null!==c&&0===c.type)return!1;switch(typeof b){case \"function\":case \"symbol\":return!0;case \"boolean\":if(d)return!1;if(null!==c)return!c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return\"data-\"!==a&&\"aria-\"!==a;default:return!1}}\nfunction qa(a,b,c,d){if(null===b||\"undefined\"===typeof b||pa(a,b,c,d))return!0;if(d)return!1;if(null!==c)switch(c.type){case 3:return!b;case 4:return!1===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return!1}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g}var z={};\n\"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style\".split(\" \").forEach(function(a){z[a]=new v(a,0,!1,a,null,!1,!1)});[[\"acceptCharset\",\"accept-charset\"],[\"className\",\"class\"],[\"htmlFor\",\"for\"],[\"httpEquiv\",\"http-equiv\"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,!1,a[1],null,!1,!1)});[\"contentEditable\",\"draggable\",\"spellCheck\",\"value\"].forEach(function(a){z[a]=new v(a,2,!1,a.toLowerCase(),null,!1,!1)});\n[\"autoReverse\",\"externalResourcesRequired\",\"focusable\",\"preserveAlpha\"].forEach(function(a){z[a]=new v(a,2,!1,a,null,!1,!1)});\"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope\".split(\" \").forEach(function(a){z[a]=new v(a,3,!1,a.toLowerCase(),null,!1,!1)});\n[\"checked\",\"multiple\",\"muted\",\"selected\"].forEach(function(a){z[a]=new v(a,3,!0,a,null,!1,!1)});[\"capture\",\"download\"].forEach(function(a){z[a]=new v(a,4,!1,a,null,!1,!1)});[\"cols\",\"rows\",\"size\",\"span\"].forEach(function(a){z[a]=new v(a,6,!1,a,null,!1,!1)});[\"rowSpan\",\"start\"].forEach(function(a){z[a]=new v(a,5,!1,a.toLowerCase(),null,!1,!1)});var ra=/[\\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}\n\"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height\".split(\" \").forEach(function(a){var b=a.replace(ra,\nsa);z[b]=new v(b,1,!1,a,null,!1,!1)});\"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type\".split(\" \").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/1999/xlink\",!1,!1)});[\"xml:base\",\"xml:lang\",\"xml:space\"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,!1,a,\"http://www.w3.org/XML/1998/namespace\",!1,!1)});[\"tabIndex\",\"crossOrigin\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!1,!1)});\nz.xlinkHref=new v(\"xlinkHref\",1,!1,\"xlink:href\",\"http://www.w3.org/1999/xlink\",!0,!1);[\"src\",\"href\",\"action\",\"formAction\"].forEach(function(a){z[a]=new v(a,1,!1,a.toLowerCase(),null,!0,!0)});\nfunction ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||\"o\"!==b[0]&&\"O\"!==b[0]||\"n\"!==b[1]&&\"N\"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,\"\"+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?!1:\"\":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&!0===c?\"\":\"\"+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)))}\nvar ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for(\"react.element\"),wa=Symbol.for(\"react.portal\"),ya=Symbol.for(\"react.fragment\"),za=Symbol.for(\"react.strict_mode\"),Aa=Symbol.for(\"react.profiler\"),Ba=Symbol.for(\"react.provider\"),Ca=Symbol.for(\"react.context\"),Da=Symbol.for(\"react.forward_ref\"),Ea=Symbol.for(\"react.suspense\"),Fa=Symbol.for(\"react.suspense_list\"),Ga=Symbol.for(\"react.memo\"),Ha=Symbol.for(\"react.lazy\");Symbol.for(\"react.scope\");Symbol.for(\"react.debug_trace_mode\");\nvar Ia=Symbol.for(\"react.offscreen\");Symbol.for(\"react.legacy_hidden\");Symbol.for(\"react.cache\");Symbol.for(\"react.tracing_marker\");var Ja=Symbol.iterator;function Ka(a){if(null===a||\"object\"!==typeof a)return null;a=Ja&&a[Ja]||a[\"@@iterator\"];return\"function\"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\\n( *(at )?)/);La=b&&b[1]||\"\"}return\"\\n\"+La+a}var Na=!1;\nfunction Oa(a,b){if(!a||Na)return\"\";Na=!0;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,\"props\",{set:function(){throw Error();}}),\"object\"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[])}catch(l){var d=l}Reflect.construct(a,[],b)}else{try{b.call()}catch(l){d=l}a.call(b.prototype)}else{try{throw Error();}catch(l){d=l}a()}}catch(l){if(l&&d&&\"string\"===typeof l.stack){for(var e=l.stack.split(\"\\n\"),\nf=d.stack.split(\"\\n\"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k=\"\\n\"+e[g].replace(\" at new \",\" at \");a.displayName&&k.includes(\"<anonymous>\")&&(k=k.replace(\"<anonymous>\",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=!1,Error.prepareStackTrace=c}return(a=a?a.displayName||a.name:\"\")?Ma(a):\"\"}\nfunction Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma(\"Lazy\");case 13:return Ma(\"Suspense\");case 19:return Ma(\"SuspenseList\");case 0:case 2:case 15:return a=Oa(a.type,!1),a;case 11:return a=Oa(a.type.render,!1),a;case 1:return a=Oa(a.type,!0),a;default:return\"\"}}\nfunction Qa(a){if(null==a)return null;if(\"function\"===typeof a)return a.displayName||a.name||null;if(\"string\"===typeof a)return a;switch(a){case ya:return\"Fragment\";case wa:return\"Portal\";case Aa:return\"Profiler\";case za:return\"StrictMode\";case Ea:return\"Suspense\";case Fa:return\"SuspenseList\"}if(\"object\"===typeof a)switch(a.$$typeof){case Ca:return(a.displayName||\"Context\")+\".Consumer\";case Ba:return(a._context.displayName||\"Context\")+\".Provider\";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||\nb.name||\"\",a=\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||\"Memo\";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}\nfunction Ra(a){var b=a.type;switch(a.tag){case 24:return\"Cache\";case 9:return(b.displayName||\"Context\")+\".Consumer\";case 10:return(b._context.displayName||\"Context\")+\".Provider\";case 18:return\"DehydratedFragment\";case 11:return a=b.render,a=a.displayName||a.name||\"\",b.displayName||(\"\"!==a?\"ForwardRef(\"+a+\")\":\"ForwardRef\");case 7:return\"Fragment\";case 5:return b;case 4:return\"Portal\";case 3:return\"Root\";case 6:return\"Text\";case 16:return Qa(b);case 8:return b===za?\"StrictMode\":\"Mode\";case 22:return\"Offscreen\";\ncase 12:return\"Profiler\";case 21:return\"Scope\";case 13:return\"Suspense\";case 19:return\"SuspenseList\";case 25:return\"TracingMarker\";case 1:case 0:case 17:case 2:case 14:case 15:if(\"function\"===typeof b)return b.displayName||b.name||null;if(\"string\"===typeof b)return b}return null}function Sa(a){switch(typeof a){case \"boolean\":case \"number\":case \"string\":case \"undefined\":return a;case \"object\":return a;default:return\"\"}}\nfunction Ta(a){var b=a.type;return(a=a.nodeName)&&\"input\"===a.toLowerCase()&&(\"checkbox\"===b||\"radio\"===b)}\nfunction Ua(a){var b=Ta(a)?\"checked\":\"value\",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=\"\"+a[b];if(!a.hasOwnProperty(b)&&\"undefined\"!==typeof c&&\"function\"===typeof c.get&&\"function\"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:!0,get:function(){return e.call(this)},set:function(a){d=\"\"+a;f.call(this,a)}});Object.defineProperty(a,b,{enumerable:c.enumerable});return{getValue:function(){return d},setValue:function(a){d=\"\"+a},stopTracking:function(){a._valueTracker=\nnull;delete a[b]}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a))}function Wa(a){if(!a)return!1;var b=a._valueTracker;if(!b)return!0;var c=b.getValue();var d=\"\";a&&(d=Ta(a)?a.checked?\"true\":\"false\":a.value);a=d;return a!==c?(b.setValue(a),!0):!1}function Xa(a){a=a||(\"undefined\"!==typeof document?document:void 0);if(\"undefined\"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}\nfunction Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?\"\":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:\"checkbox\"===b.type||\"radio\"===b.type?null!=b.checked:null!=b.value}}function ab(a,b){b=b.checked;null!=b&&ta(a,\"checked\",b,!1)}\nfunction bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if(\"number\"===d){if(0===c&&\"\"===a.value||a.value!=c)a.value=\"\"+c}else a.value!==\"\"+c&&(a.value=\"\"+c);else if(\"submit\"===d||\"reset\"===d){a.removeAttribute(\"value\");return}b.hasOwnProperty(\"value\")?cb(a,b.type,c):b.hasOwnProperty(\"defaultValue\")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked)}\nfunction db(a,b,c){if(b.hasOwnProperty(\"value\")||b.hasOwnProperty(\"defaultValue\")){var d=b.type;if(!(\"submit\"!==d&&\"reset\"!==d||void 0!==b.value&&null!==b.value))return;b=\"\"+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b}c=a.name;\"\"!==c&&(a.name=\"\");a.defaultChecked=!!a._wrapperState.initialChecked;\"\"!==c&&(a.name=c)}\nfunction cb(a,b,c){if(\"number\"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=\"\"+a._wrapperState.initialValue:a.defaultValue!==\"\"+c&&(a.defaultValue=\"\"+c)}var eb=Array.isArray;\nfunction fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b[\"$\"+c[e]]=!0;for(c=0;c<a.length;c++)e=b.hasOwnProperty(\"$\"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=!0)}else{c=\"\"+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=!0;d&&(a[e].defaultSelected=!0);return}null!==b||a[e].disabled||(b=a[e])}null!==b&&(b.selected=!0)}}\nfunction gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:\"\"+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0]}b=c}null==b&&(b=\"\");c=b}a._wrapperState={initialValue:Sa(c)}}\nfunction ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=\"\"+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=\"\"+d)}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&\"\"!==b&&null!==b&&(a.value=b)}function kb(a){switch(a){case \"svg\":return\"http://www.w3.org/2000/svg\";case \"math\":return\"http://www.w3.org/1998/Math/MathML\";default:return\"http://www.w3.org/1999/xhtml\"}}\nfunction lb(a,b){return null==a||\"http://www.w3.org/1999/xhtml\"===a?kb(b):\"http://www.w3.org/2000/svg\"===a&&\"foreignObject\"===b?\"http://www.w3.org/1999/xhtml\":a}\nvar mb,nb=function(a){return\"undefined\"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)})}:a}(function(a,b){if(\"http://www.w3.org/2000/svg\"!==a.namespaceURI||\"innerHTML\"in a)a.innerHTML=b;else{mb=mb||document.createElement(\"div\");mb.innerHTML=\"<svg>\"+b.valueOf().toString()+\"</svg>\";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild)}});\nfunction ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b}\nvar pb={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,\nzoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},qb=[\"Webkit\",\"ms\",\"Moz\",\"O\"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a]})});function rb(a,b,c){return null==b||\"boolean\"===typeof b||\"\"===b?\"\":c||\"number\"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(\"\"+b).trim():b+\"px\"}\nfunction sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf(\"--\"),e=rb(c,b[c],d);\"float\"===c&&(c=\"cssFloat\");d?a.setProperty(c,e):a[c]=e}}var tb=A({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});\nfunction ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if(\"object\"!==typeof b.dangerouslySetInnerHTML||!(\"__html\"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&\"object\"!==typeof b.style)throw Error(p(62));}}\nfunction vb(a,b){if(-1===a.indexOf(\"-\"))return\"string\"===typeof b.is;switch(a){case \"annotation-xml\":case \"color-profile\":case \"font-face\":case \"font-face-src\":case \"font-face-uri\":case \"font-face-format\":case \"font-face-name\":case \"missing-glyph\":return!1;default:return!0}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;\nfunction Bb(a){if(a=Cb(a)){if(\"function\"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b))}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a])}}function Gb(a,b){return a(b)}function Hb(){}var Ib=!1;function Jb(a,b,c){if(Ib)return a(b,c);Ib=!0;try{return Gb(a,b,c)}finally{if(Ib=!1,null!==zb||null!==Ab)Hb(),Fb()}}\nfunction Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case \"onClick\":case \"onClickCapture\":case \"onDoubleClick\":case \"onDoubleClickCapture\":case \"onMouseDown\":case \"onMouseDownCapture\":case \"onMouseMove\":case \"onMouseMoveCapture\":case \"onMouseUp\":case \"onMouseUpCapture\":case \"onMouseEnter\":(d=!d.disabled)||(a=a.type,d=!(\"button\"===a||\"input\"===a||\"select\"===a||\"textarea\"===a));a=!d;break a;default:a=!1}if(a)return null;if(c&&\"function\"!==\ntypeof c)throw Error(p(231,b,typeof c));return c}var Lb=!1;if(ia)try{var Mb={};Object.defineProperty(Mb,\"passive\",{get:function(){Lb=!0}});window.addEventListener(\"test\",Mb,Mb);window.removeEventListener(\"test\",Mb,Mb)}catch(a){Lb=!1}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l)}catch(m){this.onError(m)}}var Ob=!1,Pb=null,Qb=!1,Rb=null,Sb={onError:function(a){Ob=!0;Pb=a}};function Tb(a,b,c,d,e,f,g,h,k){Ob=!1;Pb=null;Nb.apply(Sb,arguments)}\nfunction Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=!1;Pb=null}else throw Error(p(198));Qb||(Qb=!0,Rb=l)}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else{a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}\nfunction Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else{for(var g=!1,h=e.child;h;){if(h===c){g=!0;c=e;d=f;break}if(h===d){g=!0;d=e;c=f;break}h=h.sibling}if(!g){for(h=f.child;h;){if(h===\nc){g=!0;c=f;d=e;break}if(h===d){g=!0;d=f;c=e;break}h=h.sibling}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling}return null}\nvar ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&\"function\"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128))}catch(b){}}\nvar oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;\nfunction tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;\ndefault:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)))}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}\nfunction vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}\nfunction wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b)}else k<=b&&(a.expiredLanes|=h);f&=~h}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}\nfunction Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f}}\nfunction Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=!1,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc=\"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit\".split(\" \");\nfunction Sc(a,b){switch(a){case \"focusin\":case \"focusout\":Lc=null;break;case \"dragenter\":case \"dragleave\":Mc=null;break;case \"mouseover\":case \"mouseout\":Nc=null;break;case \"pointerover\":case \"pointerout\":Oc.delete(b.pointerId);break;case \"gotpointercapture\":case \"lostpointercapture\":Pc.delete(b.pointerId)}}\nfunction Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}\nfunction Uc(a,b,c,d,e){switch(b){case \"focusin\":return Lc=Tc(Lc,a,b,c,d,e),!0;case \"dragenter\":return Mc=Tc(Mc,a,b,c,d,e),!0;case \"mouseover\":return Nc=Tc(Nc,a,b,c,d,e),!0;case \"pointerover\":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return!0;case \"gotpointercapture\":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),!0}return!1}\nfunction Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c)});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null}\nfunction Xc(a){if(null!==a.blockedOn)return!1;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,!1;b.shift()}return!0}function Zc(a,b,c){Xc(a)&&c.delete(b)}function $c(){Jc=!1;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc)}\nfunction ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=!0,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)))}\nfunction bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null)}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift()}var cd=ua.ReactCurrentBatchConfig,dd=!0;\nfunction ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d)}finally{C=e,cd.transition=f}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d)}finally{C=e,cd.transition=f}}\nfunction fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f}null!==e&&d.stopPropagation()}else hd(a,b,d,null,c)}}var id=null;\nfunction Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null}else b!==a&&(a=null);id=a;return null}\nfunction jd(a){switch(a){case \"cancel\":case \"click\":case \"close\":case \"contextmenu\":case \"copy\":case \"cut\":case \"auxclick\":case \"dblclick\":case \"dragend\":case \"dragstart\":case \"drop\":case \"focusin\":case \"focusout\":case \"input\":case \"invalid\":case \"keydown\":case \"keypress\":case \"keyup\":case \"mousedown\":case \"mouseup\":case \"paste\":case \"pause\":case \"play\":case \"pointercancel\":case \"pointerdown\":case \"pointerup\":case \"ratechange\":case \"reset\":case \"resize\":case \"seeked\":case \"submit\":case \"touchcancel\":case \"touchend\":case \"touchstart\":case \"volumechange\":case \"change\":case \"selectionchange\":case \"textInput\":case \"compositionstart\":case \"compositionend\":case \"compositionupdate\":case \"beforeblur\":case \"afterblur\":case \"beforeinput\":case \"blur\":case \"fullscreenchange\":case \"focus\":case \"hashchange\":case \"popstate\":case \"select\":case \"selectstart\":return 1;case \"drag\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"mousemove\":case \"mouseout\":case \"mouseover\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"scroll\":case \"toggle\":case \"touchmove\":case \"wheel\":case \"mouseenter\":case \"mouseleave\":case \"pointerenter\":case \"pointerleave\":return 4;\ncase \"message\":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e=\"value\"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}\nfunction od(a){var b=a.keyCode;\"charCode\"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return!0}function qd(){return!1}\nfunction rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:!1===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=!0;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():\"unknown\"!==typeof a.returnValue&&\n(a.returnValue=!1),this.isDefaultPrevented=pd)},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():\"unknown\"!==typeof a.cancelBubble&&(a.cancelBubble=!0),this.isPropagationStopped=pd)},persist:function(){},isPersistent:pd});return b}\nvar sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if(\"movementX\"in\na)return a.movementX;a!==yd&&(yd&&\"mousemove\"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return\"movementY\"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return\"clipboardData\"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:\"Escape\",\nSpacebar:\" \",Left:\"ArrowLeft\",Up:\"ArrowUp\",Right:\"ArrowRight\",Down:\"ArrowDown\",Del:\"Delete\",Win:\"OS\",Menu:\"ContextMenu\",Apps:\"ContextMenu\",Scroll:\"ScrollLock\",MozPrintableKey:\"Unidentified\"},Nd={8:\"Backspace\",9:\"Tab\",12:\"Clear\",13:\"Enter\",16:\"Shift\",17:\"Control\",18:\"Alt\",19:\"Pause\",20:\"CapsLock\",27:\"Escape\",32:\" \",33:\"PageUp\",34:\"PageDown\",35:\"End\",36:\"Home\",37:\"ArrowLeft\",38:\"ArrowUp\",39:\"ArrowRight\",40:\"ArrowDown\",45:\"Insert\",46:\"Delete\",112:\"F1\",113:\"F2\",114:\"F3\",115:\"F4\",116:\"F5\",117:\"F6\",118:\"F7\",\n119:\"F8\",120:\"F9\",121:\"F10\",122:\"F11\",123:\"F12\",144:\"NumLock\",145:\"ScrollLock\",224:\"Meta\"},Od={Alt:\"altKey\",Control:\"ctrlKey\",Meta:\"metaKey\",Shift:\"shiftKey\"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:!1}function zd(){return Pd}\nvar Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if(\"Unidentified\"!==b)return b}return\"keypress\"===a.type?(a=od(a),13===a?\"Enter\":String.fromCharCode(a)):\"keydown\"===a.type||\"keyup\"===a.type?Nd[a.keyCode]||\"Unidentified\":\"\"},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return\"keypress\"===a.type?od(a):0},keyCode:function(a){return\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0},which:function(a){return\"keypress\"===\na.type?od(a):\"keydown\"===a.type||\"keyup\"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return\"deltaX\"in a?a.deltaX:\"wheelDeltaX\"in a?-a.wheelDeltaX:0},\ndeltaY:function(a){return\"deltaY\"in a?a.deltaY:\"wheelDeltaY\"in a?-a.wheelDeltaY:\"wheelDelta\"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&\"CompositionEvent\"in window,be=null;ia&&\"documentMode\"in document&&(be=document.documentMode);var ce=ia&&\"TextEvent\"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=!1;\nfunction ge(a,b){switch(a){case \"keyup\":return-1!==$d.indexOf(b.keyCode);case \"keydown\":return 229!==b.keyCode;case \"keypress\":case \"mousedown\":case \"focusout\":return!0;default:return!1}}function he(a){a=a.detail;return\"object\"===typeof a&&\"data\"in a?a.data:null}var ie=!1;function je(a,b){switch(a){case \"compositionend\":return he(b);case \"keypress\":if(32!==b.which)return null;fe=!0;return ee;case \"textInput\":return a=b.data,a===ee&&fe?null:a;default:return null}}\nfunction ke(a,b){if(ie)return\"compositionend\"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=!1,a):null;switch(a){case \"paste\":return null;case \"keypress\":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case \"compositionend\":return de&&\"ko\"!==b.locale?null:b.data;default:return null}}\nvar le={color:!0,date:!0,datetime:!0,\"datetime-local\":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return\"input\"===b?!!le[a.type]:\"textarea\"===b?!0:!1}function ne(a,b,c,d){Eb(d);b=oe(b,\"onChange\");0<b.length&&(c=new td(\"onChange\",\"change\",null,c,d),a.push({event:c,listeners:b}))}var pe=null,qe=null;function re(a){se(a,0)}function te(a){var b=ue(a);if(Wa(b))return a}\nfunction ve(a,b){if(\"change\"===a)return b}var we=!1;if(ia){var xe;if(ia){var ye=\"oninput\"in document;if(!ye){var ze=document.createElement(\"div\");ze.setAttribute(\"oninput\",\"return;\");ye=\"function\"===typeof ze.oninput}xe=ye}else xe=!1;we=xe&&(!document.documentMode||9<document.documentMode)}function Ae(){pe&&(pe.detachEvent(\"onpropertychange\",Be),qe=pe=null)}function Be(a){if(\"value\"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b)}}\nfunction Ce(a,b,c){\"focusin\"===a?(Ae(),pe=b,qe=c,pe.attachEvent(\"onpropertychange\",Be)):\"focusout\"===a&&Ae()}function De(a){if(\"selectionchange\"===a||\"keyup\"===a||\"keydown\"===a)return te(qe)}function Ee(a,b){if(\"click\"===a)return te(b)}function Fe(a,b){if(\"input\"===a||\"change\"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He=\"function\"===typeof Object.is?Object.is:Ge;\nfunction Ie(a,b){if(He(a,b))return!0;if(\"object\"!==typeof a||null===a||\"object\"!==typeof b||null===b)return!1;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return!1;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return!1}return!0}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}\nfunction Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return{node:c,offset:b-a};a=d}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode}c=void 0}c=Je(c)}}function Le(a,b){return a&&b?a===b?!0:a&&3===a.nodeType?!1:b&&3===b.nodeType?Le(a,b.parentNode):\"contains\"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):!1:!1}\nfunction Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c=\"string\"===typeof b.contentWindow.location.href}catch(d){c=!1}if(c)a=b.contentWindow;else break;b=Xa(a.document)}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&(\"input\"===b&&(\"text\"===a.type||\"search\"===a.type||\"tel\"===a.type||\"url\"===a.type||\"password\"===a.type)||\"textarea\"===b||\"true\"===a.contentEditable)}\nfunction Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),\"selectionStart\"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,\nd);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)))}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});\"function\"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top}}\nvar Pe=ia&&\"documentMode\"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=!1;\nfunction Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,\"selectionStart\"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,\"onSelect\"),0<d.length&&(b=new td(\"onSelect\",\"select\",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)))}\nfunction Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c[\"Webkit\"+a]=\"webkit\"+b;c[\"Moz\"+a]=\"moz\"+b;return c}var We={animationend:Ve(\"Animation\",\"AnimationEnd\"),animationiteration:Ve(\"Animation\",\"AnimationIteration\"),animationstart:Ve(\"Animation\",\"AnimationStart\"),transitionend:Ve(\"Transition\",\"TransitionEnd\")},Xe={},Ye={};\nia&&(Ye=document.createElement(\"div\").style,\"AnimationEvent\"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),\"TransitionEvent\"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze(\"animationend\"),af=Ze(\"animationiteration\"),bf=Ze(\"animationstart\"),cf=Ze(\"transitionend\"),df=new Map,ef=\"abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\" \");\nfunction ff(a,b){df.set(a,b);fa(b,[a])}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,\"on\"+kf)}ff($e,\"onAnimationEnd\");ff(af,\"onAnimationIteration\");ff(bf,\"onAnimationStart\");ff(\"dblclick\",\"onDoubleClick\");ff(\"focusin\",\"onFocus\");ff(\"focusout\",\"onBlur\");ff(cf,\"onTransitionEnd\");ha(\"onMouseEnter\",[\"mouseout\",\"mouseover\"]);ha(\"onMouseLeave\",[\"mouseout\",\"mouseover\"]);ha(\"onPointerEnter\",[\"pointerout\",\"pointerover\"]);\nha(\"onPointerLeave\",[\"pointerout\",\"pointerover\"]);fa(\"onChange\",\"change click focusin focusout input keydown keyup selectionchange\".split(\" \"));fa(\"onSelect\",\"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\" \"));fa(\"onBeforeInput\",[\"compositionend\",\"keypress\",\"textInput\",\"paste\"]);fa(\"onCompositionEnd\",\"compositionend focusout keydown keypress keyup mousedown\".split(\" \"));fa(\"onCompositionStart\",\"compositionstart focusout keydown keypress keyup mousedown\".split(\" \"));\nfa(\"onCompositionUpdate\",\"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \"));var lf=\"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\" \"),mf=new Set(\"cancel close invalid load scroll toggle\".split(\" \").concat(lf));\nfunction nf(a,b,c){var d=a.type||\"unknown-event\";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null}\nfunction se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k}}}if(Qb)throw a=Rb,Qb=!1,Rb=null,a;}\nfunction D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+\"__bubble\";c.has(d)||(pf(b,a,2,!1),c.add(d))}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b)}var rf=\"_reactListening\"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=!0;da.forEach(function(b){\"selectionchange\"!==b&&(mf.has(b)||qf(b,!1,a),qf(b,!0,a))});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=!0,qf(\"selectionchange\",!1,b))}}\nfunction pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd}c=e.bind(null,b,c,a);e=void 0;!Lb||\"touchstart\"!==b&&\"touchmove\"!==b&&\"wheel\"!==b||(e=!0);d?void 0!==e?a.addEventListener(b,c,{capture:!0,passive:e}):a.addEventListener(b,c,!0):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,!1)}\nfunction hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode}}d=d.return}Jb(function(){var d=f,e=xb(c),g=[];\na:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case \"keypress\":if(0===od(c))break a;case \"keydown\":case \"keyup\":k=Rd;break;case \"focusin\":n=\"focus\";k=Fd;break;case \"focusout\":n=\"blur\";k=Fd;break;case \"beforeblur\":case \"afterblur\":k=Fd;break;case \"click\":if(2===c.button)break a;case \"auxclick\":case \"dblclick\":case \"mousedown\":case \"mousemove\":case \"mouseup\":case \"mouseout\":case \"mouseover\":case \"contextmenu\":k=Bd;break;case \"drag\":case \"dragend\":case \"dragenter\":case \"dragexit\":case \"dragleave\":case \"dragover\":case \"dragstart\":case \"drop\":k=\nDd;break;case \"touchcancel\":case \"touchend\":case \"touchmove\":case \"touchstart\":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case \"scroll\":k=vd;break;case \"wheel\":k=Zd;break;case \"copy\":case \"cut\":case \"paste\":k=Jd;break;case \"gotpointercapture\":case \"lostpointercapture\":case \"pointercancel\":case \"pointerdown\":case \"pointermove\":case \"pointerout\":case \"pointerover\":case \"pointerup\":k=Td}var t=0!==(b&4),J=!t&&\"scroll\"===a,x=t?null!==h?h+\"Capture\":null:h;t=[];for(var w=d,u;null!==\nw;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}))}}if(0===(b&7)){a:{h=\"mouseover\"===a||\"pointerover\"===a;k=\"mouseout\"===a||\"pointerout\"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==\nn&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null}else k=null,n=d;if(k!==n){t=Bd;F=\"onMouseLeave\";x=\"onMouseEnter\";w=\"mouse\";if(\"pointerout\"===a||\"pointerover\"===a)t=Td,F=\"onPointerLeave\",x=\"onPointerEnter\",w=\"pointer\";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+\"leave\",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+\"enter\",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=\nvf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x)}t=null}else t=null;null!==k&&wf(g,h,k,t,!1);null!==n&&null!==J&&wf(g,J,n,t,!0)}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if(\"select\"===k||\"input\"===k&&\"file\"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else{na=De;var xa=Ce}else(k=h.nodeName)&&\"input\"===k.toLowerCase()&&(\"checkbox\"===h.type||\"radio\"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);\"focusout\"===a&&(xa=h._wrapperState)&&\nxa.controlled&&\"number\"===h.type&&cb(h,\"number\",h.value)}xa=d?ue(d):window;switch(a){case \"focusin\":if(me(xa)||\"true\"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case \"focusout\":Se=Re=Qe=null;break;case \"mousedown\":Te=!0;break;case \"contextmenu\":case \"mouseup\":case \"dragend\":Te=!1;Ue(g,c,e);break;case \"selectionchange\":if(Pe)break;case \"keydown\":case \"keyup\":Ue(g,c,e)}var $a;if(ae)b:{switch(a){case \"compositionstart\":var ba=\"onCompositionStart\";break b;case \"compositionend\":ba=\"onCompositionEnd\";\nbreak b;case \"compositionupdate\":ba=\"onCompositionUpdate\";break b}ba=void 0}else ie?ge(a,c)&&(ba=\"onCompositionEnd\"):\"keydown\"===a&&229===c.keyCode&&(ba=\"onCompositionStart\");ba&&(de&&\"ko\"!==c.locale&&(ie||\"onCompositionStart\"!==ba?\"onCompositionEnd\"===ba&&ie&&($a=nd()):(kd=e,ld=\"value\"in kd?kd.value:kd.textContent,ie=!0)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,\"onBeforeInput\"),\n0<d.length&&(e=new Ld(\"onBeforeInput\",\"beforeinput\",null,c,e),g.push({event:e,listeners:d}),e.data=$a)}se(g,b)})}function tf(a,b,c){return{instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+\"Capture\",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}\nfunction wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return}0!==g.length&&a.push({event:b,listeners:g})}var xf=/\\r\\n?/g,yf=/\\u0000|\\uFFFD/g;function zf(a){return(\"string\"===typeof a?a:\"\"+a).replace(xf,\"\\n\").replace(yf,\"\")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}\nvar Cf=null,Df=null;function Ef(a,b){return\"textarea\"===a||\"noscript\"===a||\"string\"===typeof b.children||\"number\"===typeof b.children||\"object\"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}\nvar Ff=\"function\"===typeof setTimeout?setTimeout:void 0,Gf=\"function\"===typeof clearTimeout?clearTimeout:void 0,Hf=\"function\"===typeof Promise?Promise:void 0,Jf=\"function\"===typeof queueMicrotask?queueMicrotask:\"undefined\"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;})}\nfunction Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,\"/$\"===c){if(0===d){a.removeChild(e);bd(b);return}d--}else\"$\"!==c&&\"$?\"!==c&&\"$!\"!==c||d++;c=e}while(c);bd(b)}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if(\"$\"===b||\"$!\"===b||\"$?\"===b)break;if(\"/$\"===b)return null}}return a}\nfunction Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if(\"$\"===c||\"$!\"===c||\"$?\"===c){if(0===b)return a;b--}else\"/$\"===c&&b++}a=a.previousSibling}return null}var Nf=Math.random().toString(36).slice(2),Of=\"__reactFiber$\"+Nf,Pf=\"__reactProps$\"+Nf,uf=\"__reactContainer$\"+Nf,of=\"__reactEvents$\"+Nf,Qf=\"__reactListeners$\"+Nf,Rf=\"__reactHandles$\"+Nf;\nfunction Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a)}return b}a=c;c=a.parentNode}return null}function Cb(a){a=a[Of]||a[uf];return!a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return{current:a}}\nfunction E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--)}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b}var Vf={},H=Uf(Vf),Wf=Uf(!1),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}\nfunction Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H)}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c)}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if(\"function\"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||\"Unknown\",e));return A({},c,d)}\nfunction cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return!0}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c)}var eg=null,fg=!1,gg=!1;function hg(a){null===eg?eg=[a]:eg.push(a)}function ig(a){fg=!0;hg(a)}\nfunction jg(){if(!gg&&null!==eg){gg=!0;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=!1}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg=\"\";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b}\nfunction ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a}else rg=1<<f|c<<e|d,sg=a}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0))}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null}var xg=null,yg=null,I=!1,zg=null;\nfunction Ag(a,b){var c=Bg(5,null,null,0);c.elementType=\"DELETED\";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c)}\nfunction Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),!0):!1;case 6:return b=\"\"===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,!0):!1;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=\nnull,!0):!1;default:return!1}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=!1,xg=a)}}else{if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=!1;xg=a}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a}\nfunction Gg(a){if(a!==xg)return!1;if(!I)return Fg(a),I=!0,!1;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b=\"head\"!==b&&\"body\"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling)}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if(\"/$\"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--}else\"$\"!==c&&\"$!\"!==c&&\"$?\"!==c||b++}a=a.nextSibling}yg=\nnull}}else yg=xg?Lf(a.stateNode.nextSibling):null;return!0}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling)}function Ig(){yg=xg=null;I=!1}function Jg(a){null===zg?zg=[a]:zg.push(a)}var Kg=ua.ReactCurrentBatchConfig;function Lg(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a)void 0===b[c]&&(b[c]=a[c]);return b}return b}var Mg=Uf(null),Ng=null,Og=null,Pg=null;function Qg(){Pg=Og=Ng=null}function Rg(a){var b=Mg.current;E(Mg);a._currentValue=b}\nfunction Sg(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return}}function Tg(a,b){Ng=a;Pg=Og=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(Ug=!0),a.firstContext=null)}\nfunction Vg(a){var b=a._currentValue;if(Pg!==a)if(a={context:a,memoizedValue:b,next:null},null===Og){if(null===Ng)throw Error(p(308));Og=a;Ng.dependencies={lanes:0,firstContext:a}}else Og=Og.next=a;return b}var Wg=null;function Xg(a){null===Wg?Wg=[a]:Wg.push(a)}function Yg(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,Xg(b)):(c.next=e.next,e.next=c);b.interleaved=c;return Zg(a,d)}\nfunction Zg(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var $g=!1;function ah(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}\nfunction bh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects})}function ch(a,b){return{eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}\nfunction dh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return Zg(a,c)}e=d.interleaved;null===e?(b.next=b,Xg(d)):(b.next=e.next,e.next=b);d.interleaved=b;return Zg(a,c)}function eh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nfunction fh(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next}while(null!==c);null===f?e=f=b:f=f.next=b}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=\nb;c.lastBaseUpdate=b}\nfunction gh(a,b,c,d){var e=a.updateQueue;$g=!1;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k))}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,\nnext:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if(\"function\"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r=\"function\"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:$g=!0}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h))}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;\nh=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);hh|=g;a.lanes=g;a.memoizedState=q}}\nfunction ih(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if(\"function\"!==typeof e)throw Error(p(191,e));e.call(d)}}}var jh=(new aa.Component).refs;function kh(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c)}\nvar nh={isMounted:function(a){return(a=a._reactInternals)?Vb(a)===a:!1},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=L(),e=lh(a),f=ch(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=dh(a,f,e);null!==b&&(mh(b,a,e,d),eh(b,a,e))},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=L(),d=\nlh(a),e=ch(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=dh(a,e,d);null!==b&&(mh(b,a,d,c),eh(b,a,d))}};function oh(a,b,c,d,e,f,g){a=a.stateNode;return\"function\"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):!0}\nfunction ph(a,b,c){var d=!1,e=Vf;var f=b.contextType;\"object\"===typeof f&&null!==f?f=Vg(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=nh;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}\nfunction qh(a,b,c,d){a=b.state;\"function\"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);\"function\"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&nh.enqueueReplaceState(b,b.state,null)}\nfunction rh(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs=jh;ah(a);var f=b.contextType;\"object\"===typeof f&&null!==f?e.context=Vg(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;\"function\"===typeof f&&(kh(a,b,f,c),e.state=a.memoizedState);\"function\"===typeof b.getDerivedStateFromProps||\"function\"===typeof e.getSnapshotBeforeUpdate||\"function\"!==typeof e.UNSAFE_componentWillMount&&\"function\"!==typeof e.componentWillMount||(b=e.state,\n\"function\"===typeof e.componentWillMount&&e.componentWillMount(),\"function\"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&nh.enqueueReplaceState(e,e.state,null),gh(a,c,e,d),e.state=a.memoizedState);\"function\"===typeof e.componentDidMount&&(a.flags|=4194308)}\nfunction sh(a,b,c){a=c.ref;if(null!==a&&\"function\"!==typeof a&&\"object\"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode}if(!d)throw Error(p(147,a));var e=d,f=\"\"+a;if(null!==b&&null!==b.ref&&\"function\"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;b===jh&&(b=e.refs={});null===a?delete b[f]:b[f]=a};b._stringRef=f;return b}if(\"string\"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}\nfunction th(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,\"[object Object]\"===a?\"object with keys {\"+Object.keys(b).join(\", \")+\"}\":a));}function uh(a){var b=a._init;return b(a._payload)}\nfunction vh(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c)}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=wh(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&\nnull===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=xh(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||\"object\"===typeof f&&null!==f&&f.$$typeof===Ha&&uh(f)===b.type))return d=e(b,c.props),d.ref=sh(a,b,c),d.return=a,d;d=yh(c.type,c.key,c.props,null,a.mode,d);d.ref=sh(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||\nb.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=zh(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Ah(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if(\"string\"===typeof b&&\"\"!==b||\"number\"===typeof b)return b=xh(\"\"+b,a.mode,c),b.return=a,b;if(\"object\"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=yh(b.type,b.key,b.props,null,a.mode,c),\nc.ref=sh(a,null,b),c.return=a,c;case wa:return b=zh(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Ah(b,a.mode,c,null),b.return=a,b;th(a,b)}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if(\"string\"===typeof c&&\"\"!==c||\"number\"===typeof c)return null!==e?null:h(a,b,\"\"+c,d);if(\"object\"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,\nb,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);th(a,c)}return null}function y(a,b,c,d,e){if(\"string\"===typeof d&&\"\"!==d||\"number\"===typeof d)return a=a.get(c)||null,h(b,a,\"\"+d,e);if(\"object\"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);th(b,d)}return null}\nfunction n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===\nx.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if(\"function\"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x}if(n.done)return c(e,\nm),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){\"object\"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if(\"object\"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=\nf.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||\"object\"===typeof k&&null!==k&&k.$$typeof===Ha&&uh(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=sh(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling}f.type===ya?(d=Ah(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=yh(f.type,f.key,f.props,null,a.mode,h),h.ref=sh(a,d,f),h.return=a,a=h)}return g(a);case wa:a:{for(l=f.key;null!==\nd;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else{c(a,d);break}else b(a,d);d=d.sibling}d=zh(f,a.mode,h);d.return=a;a=d}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);th(a,f)}return\"string\"===typeof f&&\"\"!==f||\"number\"===typeof f?(f=\"\"+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):\n(c(a,d),d=xh(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Bh=vh(!0),Ch=vh(!1),Dh={},Eh=Uf(Dh),Fh=Uf(Dh),Gh=Uf(Dh);function Hh(a){if(a===Dh)throw Error(p(174));return a}function Ih(a,b){G(Gh,b);G(Fh,a);G(Eh,Dh);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,\"\");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a)}E(Eh);G(Eh,b)}function Jh(){E(Eh);E(Fh);E(Gh)}\nfunction Kh(a){Hh(Gh.current);var b=Hh(Eh.current);var c=lb(b,a.type);b!==c&&(G(Fh,a),G(Eh,c))}function Lh(a){Fh.current===a&&(E(Eh),E(Fh))}var M=Uf(0);\nfunction Mh(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||\"$?\"===c.data||\"$!\"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return}b.sibling.return=b.return;b=b.sibling}return null}var Nh=[];\nfunction Oh(){for(var a=0;a<Nh.length;a++)Nh[a]._workInProgressVersionPrimary=null;Nh.length=0}var Ph=ua.ReactCurrentDispatcher,Qh=ua.ReactCurrentBatchConfig,Rh=0,N=null,O=null,P=null,Sh=!1,Th=!1,Uh=0,Vh=0;function Q(){throw Error(p(321));}function Wh(a,b){if(null===b)return!1;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return!1;return!0}\nfunction Xh(a,b,c,d,e,f){Rh=f;N=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Ph.current=null===a||null===a.memoizedState?Yh:Zh;a=c(d,e);if(Th){f=0;do{Th=!1;Uh=0;if(25<=f)throw Error(p(301));f+=1;P=O=null;b.updateQueue=null;Ph.current=$h;a=c(d,e)}while(Th)}Ph.current=ai;b=null!==O&&null!==O.next;Rh=0;P=O=N=null;Sh=!1;if(b)throw Error(p(300));return a}function bi(){var a=0!==Uh;Uh=0;return a}\nfunction ci(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===P?N.memoizedState=P=a:P=P.next=a;return P}function di(){if(null===O){var a=N.alternate;a=null!==a?a.memoizedState:null}else a=O.next;var b=null===P?N.memoizedState:P.next;if(null!==b)P=b,O=a;else{if(null===a)throw Error(p(310));O=a;a={memoizedState:O.memoizedState,baseState:O.baseState,baseQueue:O.baseQueue,queue:O.queue,next:null};null===P?N.memoizedState=P=a:P=P.next=a}return P}\nfunction ei(a,b){return\"function\"===typeof b?b(a):b}\nfunction fi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=O,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g}d.baseQueue=e=f;c.pending=null}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Rh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else{var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,\neagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;N.lanes|=m;hh|=m}l=l.next}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(Ug=!0);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d}a=c.interleaved;if(null!==a){e=a;do f=e.lane,N.lanes|=f,hh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return[b.memoizedState,c.dispatch]}\nfunction gi(a){var b=di(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(Ug=!0);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f}return[f,d]}function hi(){}\nfunction ii(a,b){var c=N,d=di(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,Ug=!0);d=d.queue;ji(ki.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==P&&P.memoizedState.tag&1){c.flags|=2048;li(9,mi.bind(null,c,d,e,b),void 0,null);if(null===R)throw Error(p(349));0!==(Rh&30)||ni(c,b,e)}return e}function ni(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a))}\nfunction mi(a,b,c,d){b.value=c;b.getSnapshot=d;oi(b)&&pi(a)}function ki(a,b,c){return c(function(){oi(b)&&pi(a)})}function oi(a){var b=a.getSnapshot;a=a.value;try{var c=b();return!He(a,c)}catch(d){return!0}}function pi(a){var b=Zg(a,1);null!==b&&mh(b,a,1,-1)}\nfunction qi(a){var b=ci();\"function\"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:ei,lastRenderedState:a};b.queue=a;a=a.dispatch=ri.bind(null,N,a);return[b.memoizedState,a]}\nfunction li(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=N.updateQueue;null===b?(b={lastEffect:null,stores:null},N.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function si(){return di().memoizedState}function ti(a,b,c,d){var e=ci();N.flags|=a;e.memoizedState=li(1|b,c,void 0,void 0===d?null:d)}\nfunction ui(a,b,c,d){var e=di();d=void 0===d?null:d;var f=void 0;if(null!==O){var g=O.memoizedState;f=g.destroy;if(null!==d&&Wh(d,g.deps)){e.memoizedState=li(b,c,f,d);return}}N.flags|=a;e.memoizedState=li(1|b,c,f,d)}function vi(a,b){return ti(8390656,8,a,b)}function ji(a,b){return ui(2048,8,a,b)}function wi(a,b){return ui(4,2,a,b)}function xi(a,b){return ui(4,4,a,b)}\nfunction yi(a,b){if(\"function\"===typeof b)return a=a(),b(a),function(){b(null)};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null}}function zi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ui(4,4,yi.bind(null,b,a),c)}function Ai(){}function Bi(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}\nfunction Ci(a,b){var c=di();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Wh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function Di(a,b,c){if(0===(Rh&21))return a.baseState&&(a.baseState=!1,Ug=!0),a.memoizedState=c;He(c,b)||(c=yc(),N.lanes|=c,hh|=c,a.baseState=!0);return b}function Ei(a,b){var c=C;C=0!==c&&4>c?c:4;a(!0);var d=Qh.transition;Qh.transition={};try{a(!1),b()}finally{C=c,Qh.transition=d}}function Fi(){return di().memoizedState}\nfunction Gi(a,b,c){var d=lh(a);c={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,c);else if(c=Yg(a,b,c,d),null!==c){var e=L();mh(c,a,d,e);Ji(c,b,d)}}\nfunction ri(a,b,c){var d=lh(a),e={lane:d,action:c,hasEagerState:!1,eagerState:null,next:null};if(Hi(a))Ii(b,e);else{var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,Xg(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=Yg(a,b,e,d);null!==c&&(e=L(),mh(c,a,d,e),Ji(c,b,d))}}\nfunction Hi(a){var b=a.alternate;return a===N||null!==b&&b===N}function Ii(a,b){Th=Sh=!0;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b}function Ji(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c)}}\nvar ai={readContext:Vg,useCallback:Q,useContext:Q,useEffect:Q,useImperativeHandle:Q,useInsertionEffect:Q,useLayoutEffect:Q,useMemo:Q,useReducer:Q,useRef:Q,useState:Q,useDebugValue:Q,useDeferredValue:Q,useTransition:Q,useMutableSource:Q,useSyncExternalStore:Q,useId:Q,unstable_isNewReconciler:!1},Yh={readContext:Vg,useCallback:function(a,b){ci().memoizedState=[a,void 0===b?null:b];return a},useContext:Vg,useEffect:vi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ti(4194308,\n4,yi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ti(4194308,4,a,b)},useInsertionEffect:function(a,b){return ti(4,2,a,b)},useMemo:function(a,b){var c=ci();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=ci();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=Gi.bind(null,N,a);return[d.memoizedState,a]},useRef:function(a){var b=\nci();a={current:a};return b.memoizedState=a},useState:qi,useDebugValue:Ai,useDeferredValue:function(a){return ci().memoizedState=a},useTransition:function(){var a=qi(!1),b=a[0];a=Ei.bind(null,a[1]);ci().memoizedState=a;return[b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=N,e=ci();if(I){if(void 0===c)throw Error(p(407));c=c()}else{c=b();if(null===R)throw Error(p(349));0!==(Rh&30)||ni(d,b,c)}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;vi(ki.bind(null,d,\nf,a),[a]);d.flags|=2048;li(9,mi.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=ci(),b=R.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=\":\"+b+\"R\"+c;c=Uh++;0<c&&(b+=\"H\"+c.toString(32));b+=\":\"}else c=Vh++,b=\":\"+b+\"r\"+c.toString(32)+\":\";return a.memoizedState=b},unstable_isNewReconciler:!1},Zh={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:fi,useRef:si,useState:function(){return fi(ei)},\nuseDebugValue:Ai,useDeferredValue:function(a){var b=di();return Di(b,O.memoizedState,a)},useTransition:function(){var a=fi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1},$h={readContext:Vg,useCallback:Bi,useContext:Vg,useEffect:ji,useImperativeHandle:zi,useInsertionEffect:wi,useLayoutEffect:xi,useMemo:Ci,useReducer:gi,useRef:si,useState:function(){return gi(ei)},useDebugValue:Ai,useDeferredValue:function(a){var b=di();return null===\nO?b.memoizedState=a:Di(b,O.memoizedState,a)},useTransition:function(){var a=gi(ei)[0],b=di().memoizedState;return[a,b]},useMutableSource:hi,useSyncExternalStore:ii,useId:Fi,unstable_isNewReconciler:!1};function Ki(a,b){try{var c=\"\",d=b;do c+=Pa(d),d=d.return;while(d);var e=c}catch(f){e=\"\\nError generating stack: \"+f.message+\"\\n\"+f.stack}return{value:a,source:b,stack:e,digest:null}}function Li(a,b,c){return{value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}\nfunction Mi(a,b){try{console.error(b.value)}catch(c){setTimeout(function(){throw c;})}}var Ni=\"function\"===typeof WeakMap?WeakMap:Map;function Oi(a,b,c){c=ch(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Pi||(Pi=!0,Qi=d);Mi(a,b)};return c}\nfunction Ri(a,b,c){c=ch(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if(\"function\"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Mi(a,b)}}var f=a.stateNode;null!==f&&\"function\"===typeof f.componentDidCatch&&(c.callback=function(){Mi(a,b);\"function\"!==typeof d&&(null===Si?Si=new Set([this]):Si.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:\"\"})});return c}\nfunction Ti(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Ni;var e=new Set;d.set(b,e)}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ui.bind(null,a,b,c),b.then(a,a))}function Vi(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?!0:!1:!0;if(b)return a;a=a.return}while(null!==a);return null}\nfunction Wi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=ch(-1,1),b.tag=2,dh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Xi=ua.ReactCurrentOwner,Ug=!1;function Yi(a,b,c,d){b.child=null===a?Ch(b,null,c,d):Bh(b,a.child,c,d)}\nfunction Zi(a,b,c,d,e){c=c.render;var f=b.ref;Tg(b,e);d=Xh(a,b,c,d,f,e);c=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&c&&vg(b);b.flags|=1;Yi(a,b,d,e);return b.child}\nfunction aj(a,b,c,d,e){if(null===a){var f=c.type;if(\"function\"===typeof f&&!bj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,cj(a,b,f,d,e);a=yh(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return $i(a,b,e)}b.flags|=1;a=wh(f,d);a.ref=b.ref;a.return=b;return b.child=a}\nfunction cj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(Ug=!1,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(Ug=!0);else return b.lanes=a.lanes,$i(a,b,e)}return dj(a,b,c,d,e)}\nfunction ej(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if(\"hidden\"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(fj,gj),gj|=c;else{if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(fj,gj),gj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(fj,gj);gj|=d}else null!==\nf?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(fj,gj),gj|=d;Yi(a,b,e,c);return b.child}function hj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152}function dj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);Tg(b,e);c=Xh(a,b,c,d,f,e);d=bi();if(null!==a&&!Ug)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,$i(a,b,e);I&&d&&vg(b);b.flags|=1;Yi(a,b,c,e);return b.child}\nfunction ij(a,b,c,d,e){if(Zf(c)){var f=!0;cg(b)}else f=!1;Tg(b,e);if(null===b.stateNode)jj(a,b),ph(b,c,d),rh(b,c,d,e),d=!0;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;\"object\"===typeof l&&null!==l?l=Vg(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q=\"function\"===typeof m||\"function\"===typeof g.getSnapshotBeforeUpdate;q||\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||\n(h!==d||k!==l)&&qh(b,g,d,l);$g=!1;var r=b.memoizedState;g.state=r;gh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||$g?(\"function\"===typeof m&&(kh(b,c,m,d),k=b.memoizedState),(h=$g||oh(b,c,h,d,r,k,l))?(q||\"function\"!==typeof g.UNSAFE_componentWillMount&&\"function\"!==typeof g.componentWillMount||(\"function\"===typeof g.componentWillMount&&g.componentWillMount(),\"function\"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),\"function\"===typeof g.componentDidMount&&(b.flags|=4194308)):\n(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):(\"function\"===typeof g.componentDidMount&&(b.flags|=4194308),d=!1)}else{g=b.stateNode;bh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Lg(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;\"object\"===typeof k&&null!==k?k=Vg(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m=\"function\"===typeof y||\"function\"===typeof g.getSnapshotBeforeUpdate)||\n\"function\"!==typeof g.UNSAFE_componentWillReceiveProps&&\"function\"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&qh(b,g,d,k);$g=!1;r=b.memoizedState;g.state=r;gh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||$g?(\"function\"===typeof y&&(kh(b,c,y,d),n=b.memoizedState),(l=$g||oh(b,c,l,d,r,n,k)||!1)?(m||\"function\"!==typeof g.UNSAFE_componentWillUpdate&&\"function\"!==typeof g.componentWillUpdate||(\"function\"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),\"function\"===typeof g.UNSAFE_componentWillUpdate&&\ng.UNSAFE_componentWillUpdate(d,n,k)),\"function\"===typeof g.componentDidUpdate&&(b.flags|=4),\"function\"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):(\"function\"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===\na.memoizedState||(b.flags|=4),\"function\"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=!1)}return kj(a,b,c,d,f,e)}\nfunction kj(a,b,c,d,e,f){hj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,!1),$i(a,b,f);d=b.stateNode;Xi.current=b;var h=g&&\"function\"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Bh(b,a.child,null,f),b.child=Bh(b,null,h,f)):Yi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,!0);return b.child}function lj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,!1);Ih(a,b.containerInfo)}\nfunction mj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Yi(a,b,c,d);return b.child}var nj={dehydrated:null,treeContext:null,retryLane:0};function oj(a){return{baseLanes:a,cachePool:null,transitions:null}}\nfunction pj(a,b,c){var d=b.pendingProps,e=M.current,f=!1,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?!1:0!==(e&2));if(h)f=!0,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(M,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:\"$!\"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:\"hidden\",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=\ng):f=qj(g,d,0,null),a=Ah(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=oj(c),b.memoizedState=nj,a):rj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return sj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:\"hidden\",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=wh(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=wh(h,f):(f=Ah(f,g,c,null),f.flags|=2);f.return=\nb;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?oj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=nj;return d}f=a.child;a=f.sibling;d=wh(f,{mode:\"visible\",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}\nfunction rj(a,b){b=qj({mode:\"visible\",children:b},a.mode,0,null);b.return=a;return a.child=b}function tj(a,b,c,d){null!==d&&Jg(d);Bh(b,a.child,null,c);a=rj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}\nfunction sj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Li(Error(p(422))),tj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=qj({mode:\"visible\",children:d.children},e,0,null);f=Ah(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Bh(b,a.child,null,g);b.child.memoizedState=oj(g);b.memoizedState=nj;return f}if(0===(b.mode&1))return tj(a,b,g,null);if(\"$!\"===e.data){d=e.nextSibling&&e.nextSibling.dataset;\nif(d)var h=d.dgst;d=h;f=Error(p(419));d=Li(f,d,void 0);return tj(a,b,g,d)}h=0!==(g&a.childLanes);if(Ug||h){d=R;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0}e=0!==(e&(d.suspendedLanes|g))?0:e;\n0!==e&&e!==f.retryLane&&(f.retryLane=e,Zg(a,e),mh(d,a,e,-1))}uj();d=Li(Error(p(421)));return tj(a,b,g,d)}if(\"$?\"===e.data)return b.flags|=128,b.child=a.child,b=vj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=!0;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=rj(b,d.children);b.flags|=4096;return b}function wj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);Sg(a.return,b,c)}\nfunction xj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e)}\nfunction yj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Yi(a,b,d.children,c);d=M.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else{if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&wj(a,c,b);else if(19===a.tag)wj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return}a.sibling.return=a.return;a=a.sibling}d&=1}G(M,d);if(0===(b.mode&1))b.memoizedState=\nnull;else switch(e){case \"forwards\":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Mh(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);xj(b,!1,e,c,f);break;case \"backwards\":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Mh(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a}xj(b,!0,c,null,f);break;case \"together\":xj(b,!1,null,null,void 0);break;default:b.memoizedState=null}return b.child}\nfunction jj(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2)}function $i(a,b,c){null!==a&&(b.dependencies=a.dependencies);hh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=wh(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=wh(a,a.pendingProps),c.return=b;c.sibling=null}return b.child}\nfunction zj(a,b,c){switch(b.tag){case 3:lj(b);Ig();break;case 5:Kh(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:Ih(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Mg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(M,M.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return pj(a,b,c);G(M,M.current&1);a=$i(a,b,c);return null!==a?a.sibling:null}G(M,M.current&1);break;case 19:d=0!==(c&\nb.childLanes);if(0!==(a.flags&128)){if(d)return yj(a,b,c);b.flags|=128}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(M,M.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,ej(a,b,c)}return $i(a,b,c)}var Aj,Bj,Cj,Dj;\nAj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return}c.sibling.return=c.return;c=c.sibling}};Bj=function(){};\nCj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;Hh(Eh.current);var f=null;switch(c){case \"input\":e=Ya(a,e);d=Ya(a,d);f=[];break;case \"select\":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case \"textarea\":e=gb(a,e);d=gb(a,d);f=[];break;default:\"function\"!==typeof e.onClick&&\"function\"===typeof d.onClick&&(a.onclick=Bf)}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if(\"style\"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&\n(c||(c={}),c[g]=\"\")}else\"dangerouslySetInnerHTML\"!==l&&\"children\"!==l&&\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&\"autoFocus\"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if(\"style\"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]=\"\");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g])}else c||(f||(f=[]),f.push(l,\nc)),c=k;else\"dangerouslySetInnerHTML\"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):\"children\"===l?\"string\"!==typeof k&&\"number\"!==typeof k||(f=f||[]).push(l,\"\"+k):\"suppressContentEditableWarning\"!==l&&\"suppressHydrationWarning\"!==l&&(ea.hasOwnProperty(l)?(null!=k&&\"onScroll\"===l&&D(\"scroll\",a),f||h===k||(f=[])):(f=f||[]).push(l,k))}c&&(f=f||[]).push(\"style\",c);var l=f;if(b.updateQueue=l)b.flags|=4}};Dj=function(a,b,c,d){c!==d&&(b.flags|=4)};\nfunction Ej(a,b){if(!I)switch(a.tailMode){case \"hidden\":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case \"collapsed\":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null}}\nfunction S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}\nfunction Fj(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;Jh();E(Wf);E(H);Oh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Gj(zg),zg=null));Bj(a,b);S(b);return null;case 5:Lh(b);var e=Hh(Gh.current);\nc=b.type;if(null!==a&&null!=b.stateNode)Cj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else{if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case \"dialog\":D(\"cancel\",d);D(\"close\",d);break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",d);break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],d);break;case \"source\":D(\"error\",d);break;case \"img\":case \"image\":case \"link\":D(\"error\",\nd);D(\"load\",d);break;case \"details\":D(\"toggle\",d);break;case \"input\":Za(d,f);D(\"invalid\",d);break;case \"select\":d._wrapperState={wasMultiple:!!f.multiple};D(\"invalid\",d);break;case \"textarea\":hb(d,f),D(\"invalid\",d)}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];\"children\"===g?\"string\"===typeof h?d.textContent!==h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=[\"children\",h]):\"number\"===typeof h&&d.textContent!==\"\"+h&&(!0!==f.suppressHydrationWarning&&Af(d.textContent,\nh,a),e=[\"children\",\"\"+h]):ea.hasOwnProperty(g)&&null!=h&&\"onScroll\"===g&&D(\"scroll\",d)}switch(c){case \"input\":Va(d);db(d,f,!0);break;case \"textarea\":Va(d);jb(d);break;case \"select\":case \"option\":break;default:\"function\"===typeof f.onClick&&(d.onclick=Bf)}d=e;b.updateQueue=d;null!==d&&(b.flags|=4)}else{g=9===e.nodeType?e:e.ownerDocument;\"http://www.w3.org/1999/xhtml\"===a&&(a=kb(c));\"http://www.w3.org/1999/xhtml\"===a?\"script\"===c?(a=g.createElement(\"div\"),a.innerHTML=\"<script>\\x3c/script>\",a=a.removeChild(a.firstChild)):\n\"string\"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),\"select\"===c&&(g=a,d.multiple?g.multiple=!0:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;Aj(a,b,!1,!1);b.stateNode=a;a:{g=vb(c,d);switch(c){case \"dialog\":D(\"cancel\",a);D(\"close\",a);e=d;break;case \"iframe\":case \"object\":case \"embed\":D(\"load\",a);e=d;break;case \"video\":case \"audio\":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case \"source\":D(\"error\",a);e=d;break;case \"img\":case \"image\":case \"link\":D(\"error\",\na);D(\"load\",a);e=d;break;case \"details\":D(\"toggle\",a);e=d;break;case \"input\":Za(a,d);e=Ya(a,d);D(\"invalid\",a);break;case \"option\":e=d;break;case \"select\":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D(\"invalid\",a);break;case \"textarea\":hb(a,d);e=gb(a,d);D(\"invalid\",a);break;default:e=d}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];\"style\"===f?sb(a,k):\"dangerouslySetInnerHTML\"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):\"children\"===f?\"string\"===typeof k?(\"textarea\"!==\nc||\"\"!==k)&&ob(a,k):\"number\"===typeof k&&ob(a,\"\"+k):\"suppressContentEditableWarning\"!==f&&\"suppressHydrationWarning\"!==f&&\"autoFocus\"!==f&&(ea.hasOwnProperty(f)?null!=k&&\"onScroll\"===f&&D(\"scroll\",a):null!=k&&ta(a,f,k,g))}switch(c){case \"input\":Va(a);db(a,d,!1);break;case \"textarea\":Va(a);jb(a);break;case \"option\":null!=d.value&&a.setAttribute(\"value\",\"\"+Sa(d.value));break;case \"select\":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,!1):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,\n!0);break;default:\"function\"===typeof e.onClick&&(a.onclick=Bf)}switch(c){case \"button\":case \"input\":case \"select\":case \"textarea\":d=!!d.autoFocus;break a;case \"img\":d=!0;break a;default:d=!1}}d&&(b.flags|=4)}null!==b.ref&&(b.flags|=512,b.flags|=2097152)}S(b);return null;case 6:if(a&&null!=b.stateNode)Dj(a,b,a.memoizedProps,d);else{if(\"string\"!==typeof d&&null===b.stateNode)throw Error(p(166));c=Hh(Gh.current);Hh(Eh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=\nxg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:!0!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1))}f&&(b.flags|=4)}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d}S(b);return null;case 13:E(M);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=!1;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===\na){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=!1}else null!==zg&&(Gj(zg),zg=null),f=!0;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(M.current&1)?0===T&&(T=3):uj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return Jh(),\nBj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return Rg(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(M);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Ej(f,!1);else{if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Mh(a);if(null!==g){b.flags|=128;Ej(f,!1);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,\ng=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(M,M.current&1|2);return b.child}a=\na.sibling}null!==f.tail&&B()>Hj&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304)}else{if(!d)if(a=Mh(g),null!==a){if(b.flags|=128,d=!0,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Ej(f,!0),null===f.tail&&\"hidden\"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Hj&&1073741824!==c&&(b.flags|=128,d=!0,Ej(f,!1),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g)}if(null!==f.tail)return b=f.tail,f.rendering=\nb,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=M.current,G(M,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Ij(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(gj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}\nfunction Jj(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return Jh(),E(Wf),E(H),Oh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Lh(b),null;case 13:E(M);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig()}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(M),null;case 4:return Jh(),null;case 10:return Rg(b.type._context),null;case 22:case 23:return Ij(),\nnull;case 24:return null;default:return null}}var Kj=!1,U=!1,Lj=\"function\"===typeof WeakSet?WeakSet:Set,V=null;function Mj(a,b){var c=a.ref;if(null!==c)if(\"function\"===typeof c)try{c(null)}catch(d){W(a,b,d)}else c.current=null}function Nj(a,b,c){try{c()}catch(d){W(a,b,d)}}var Oj=!1;\nfunction Pj(a,b){Cf=dd;a=Me();if(Ne(a)){if(\"selectionStart\"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=\nq.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode}q=y}c=-1===h||-1===k?null:{start:h,end:k}}else c=null}c=c||{start:0,end:0}}else c=null;Df={focusedElem:a,selectionRange:c};dd=!1;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;\ncase 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Lg(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent=\"\":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F)}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return}n=Oj;Oj=!1;return n}\nfunction Qj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Nj(b,c,f)}e=e.next}while(e!==d)}}function Rj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d()}c=c.next}while(c!==b)}}function Sj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c}\"function\"===typeof b?b(a):b.current=a}}\nfunction Tj(a){var b=a.alternate;null!==b&&(a.alternate=null,Tj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null}function Uj(a){return 5===a.tag||3===a.tag||4===a.tag}\nfunction Vj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Uj(a.return))return null;a=a.return}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child}if(!(a.flags&2))return a.stateNode}}\nfunction Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling}\nfunction Xj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Xj(a,b,c),a=a.sibling;null!==a;)Xj(a,b,c),a=a.sibling}var X=null,Yj=!1;function Zj(a,b,c){for(c=c.child;null!==c;)ak(a,b,c),c=c.sibling}\nfunction ak(a,b,c){if(lc&&\"function\"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c)}catch(h){}switch(c.tag){case 5:U||Mj(c,b);case 6:var d=X,e=Yj;X=null;Zj(a,b,c);X=d;Yj=e;null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Yj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Yj;X=c.stateNode.containerInfo;Yj=!0;\nZj(a,b,c);X=d;Yj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Nj(c,b,g):0!==(f&4)&&Nj(c,b,g));e=e.next}while(e!==d)}Zj(a,b,c);break;case 1:if(!U&&(Mj(c,b),d=c.stateNode,\"function\"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount()}catch(h){W(c,b,h)}Zj(a,b,c);break;case 21:Zj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==\nc.memoizedState,Zj(a,b,c),U=d):Zj(a,b,c);break;default:Zj(a,b,c)}}function bk(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Lj);b.forEach(function(b){var d=ck.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d))})}}\nfunction dk(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Yj=!1;break a;case 3:X=h.stateNode.containerInfo;Yj=!0;break a;case 4:X=h.stateNode.containerInfo;Yj=!0;break a}h=h.return}if(null===X)throw Error(p(160));ak(f,g,e);X=null;Yj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null}catch(l){W(e,b,l)}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)ek(b,a),b=b.sibling}\nfunction ek(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:dk(b,a);fk(a);if(d&4){try{Qj(3,a,a.return),Rj(3,a)}catch(t){W(a,a.return,t)}try{Qj(5,a,a.return)}catch(t){W(a,a.return,t)}}break;case 1:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);break;case 5:dk(b,a);fk(a);d&512&&null!==c&&Mj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,\"\")}catch(t){W(a,a.return,t)}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;\na.updateQueue=null;if(null!==k)try{\"input\"===h&&\"radio\"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];\"style\"===m?sb(e,q):\"dangerouslySetInnerHTML\"===m?nb(e,q):\"children\"===m?ob(e,q):ta(e,m,q,l)}switch(h){case \"input\":bb(e,f);break;case \"textarea\":ib(e,f);break;case \"select\":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,\nf.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:\"\",!1))}e[Pf]=f}catch(t){W(a,a.return,t)}}break;case 6:dk(b,a);fk(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f}catch(t){W(a,a.return,t)}}break;case 3:dk(b,a);fk(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo)}catch(t){W(a,a.return,t)}break;case 4:dk(b,a);fk(a);break;case 13:dk(b,a);fk(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||\nnull!==e.alternate&&null!==e.alternate.memoizedState||(gk=B()));d&4&&bk(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,dk(b,a),U=l):dk(b,a);fk(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Qj(4,r,r.return);break;case 1:Mj(r,r.return);var n=r.stateNode;if(\"function\"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=\nb.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount()}catch(t){W(d,c,t)}}break;case 5:Mj(r,r.return);break;case 22:if(null!==r.memoizedState){hk(q);continue}}null!==y?(y.return=r,V=y):hk(q)}m=m.sibling}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,\"function\"===typeof f.setProperty?f.setProperty(\"display\",\"none\",\"important\"):f.display=\"none\"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty(\"display\")?k.display:null,h.style.display=\nrb(\"display\",g))}catch(t){W(a,a.return,t)}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?\"\":q.memoizedProps}catch(t){W(a,a.return,t)}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling}}break;case 19:dk(b,a);fk(a);d&4&&bk(a);break;case 21:break;default:dk(b,\na),fk(a)}}function fk(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Uj(c)){var d=c;break a}c=c.return}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,\"\"),d.flags&=-33);var f=Vj(a);Xj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Vj(a);Wj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k)}a.flags&=-3}b&4096&&(a.flags&=-4097)}function ik(a,b,c){V=a;jk(a,b,c)}\nfunction jk(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Kj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Kj;var l=U;Kj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?kk(e):null!==k?(k.return=g,V=k):kk(e);for(;null!==f;)V=f,jk(f,b,c),f=f.sibling;V=e;Kj=h;U=l}lk(a,b,c)}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):lk(a,b,c)}}\nfunction lk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Rj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else{var e=b.elementType===b.type?c.memoizedProps:Lg(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate)}var f=b.updateQueue;null!==f&&ih(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=\nb.child.stateNode;break;case 1:c=b.child.stateNode}ih(b,g,c)}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case \"button\":case \"input\":case \"select\":case \"textarea\":k.autoFocus&&c.focus();break;case \"img\":k.src&&(c.src=k.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;\ndefault:throw Error(p(163));}U||b.flags&512&&Sj(b)}catch(r){W(b,b.return,r)}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}function hk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return}}\nfunction kk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Rj(4,b)}catch(k){W(b,c,k)}break;case 1:var d=b.stateNode;if(\"function\"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount()}catch(k){W(b,e,k)}}var f=b.return;try{Sj(b)}catch(k){W(b,f,k)}break;case 5:var g=b.return;try{Sj(b)}catch(k){W(b,g,k)}}}catch(k){W(b,b.return,k)}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return}}\nvar mk=Math.ceil,nk=ua.ReactCurrentDispatcher,ok=ua.ReactCurrentOwner,pk=ua.ReactCurrentBatchConfig,K=0,R=null,Y=null,Z=0,gj=0,fj=Uf(0),T=0,qk=null,hh=0,rk=0,sk=0,tk=null,uk=null,gk=0,Hj=Infinity,vk=null,Pi=!1,Qi=null,Si=null,wk=!1,xk=null,yk=0,zk=0,Ak=null,Bk=-1,Ck=0;function L(){return 0!==(K&6)?B():-1!==Bk?Bk:Bk=B()}\nfunction lh(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Ck&&(Ck=yc()),Ck;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function mh(a,b,c,d){if(50<zk)throw zk=0,Ak=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==R)a===R&&(0===(K&2)&&(rk|=c),4===T&&Dk(a,Z)),Ek(a,d),1===c&&0===K&&0===(b.mode&1)&&(Hj=B()+500,fg&&jg())}\nfunction Ek(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===R?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Fk.bind(null,a)):hg(Fk.bind(null,a)),Jf(function(){0===(K&6)&&jg()}),c=null;else{switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc}c=Gk(c,Hk.bind(null,a))}a.callbackPriority=b;a.callbackNode=c}}\nfunction Hk(a,b){Bk=-1;Ck=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Ik()&&a.callbackNode!==c)return null;var d=uc(a,a===R?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Jk(a,d);else{b=d;var e=K;K|=2;var f=Kk();if(R!==a||Z!==b)vk=null,Hj=B()+500,Lk(a,b);do try{Mk();break}catch(h){Nk(a,h)}while(1);Qg();nk.current=f;K=e;null!==Y?b=0:(R=null,Z=0,b=T)}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Ok(a,e)));if(1===b)throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;if(6===b)Dk(a,d);\nelse{e=a.current.alternate;if(0===(d&30)&&!Pk(e)&&(b=Jk(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Ok(a,f))),1===b))throw c=qk,Lk(a,0),Dk(a,d),Ek(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Qk(a,uk,vk);break;case 3:Dk(a,d);if((d&130023424)===d&&(b=gk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){L();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),b);break}Qk(a,uk,vk);break;case 4:Dk(a,d);if((d&4194240)===\nd)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*mk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Qk.bind(null,a,uk,vk),d);break}Qk(a,uk,vk);break;case 5:Qk(a,uk,vk);break;default:throw Error(p(329));}}}Ek(a,B());return a.callbackNode===c?Hk.bind(null,a):null}\nfunction Ok(a,b){var c=tk;a.current.memoizedState.isDehydrated&&(Lk(a,b).flags|=256);a=Jk(a,b);2!==a&&(b=uk,uk=c,null!==b&&Gj(b));return a}function Gj(a){null===uk?uk=a:uk.push.apply(uk,a)}\nfunction Pk(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return!1}catch(g){return!1}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else{if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return!0;b=b.return}b.sibling.return=b.return;b=b.sibling}}return!0}\nfunction Dk(a,b){b&=~sk;b&=~rk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d}}function Fk(a){if(0!==(K&6))throw Error(p(327));Ik();var b=uc(a,0);if(0===(b&1))return Ek(a,B()),null;var c=Jk(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Ok(a,d))}if(1===c)throw c=qk,Lk(a,0),Dk(a,b),Ek(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Qk(a,uk,vk);Ek(a,B());return null}\nfunction Rk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Hj=B()+500,fg&&jg())}}function Sk(a){null!==xk&&0===xk.tag&&0===(K&6)&&Ik();var b=K;K|=1;var c=pk.transition,d=C;try{if(pk.transition=null,C=1,a)return a()}finally{C=d,pk.transition=c,K=b,0===(K&6)&&jg()}}function Ij(){gj=fj.current;E(fj)}\nfunction Lk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:Jh();E(Wf);E(H);Oh();break;case 5:Lh(d);break;case 4:Jh();break;case 13:E(M);break;case 19:E(M);break;case 10:Rg(d.type._context);break;case 22:case 23:Ij()}c=c.return}R=a;Y=a=wh(a.current,null);Z=gj=b;T=0;qk=null;sk=rk=hh=0;uk=tk=null;if(null!==Wg){for(b=\n0;b<Wg.length;b++)if(c=Wg[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g}c.pending=d}Wg=null}return a}\nfunction Nk(a,b){do{var c=Y;try{Qg();Ph.current=ai;if(Sh){for(var d=N.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next}Sh=!1}Rh=0;P=O=N=null;Th=!1;Uh=0;ok.current=null;if(null===c||null===c.return){T=1;qk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&\"object\"===typeof k&&\"function\"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,\nm.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null)}var y=Vi(g);if(null!==y){y.flags&=-257;Wi(y,g,h,f,b);y.mode&1&&Ti(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t}else n.add(k);break a}else{if(0===(b&1)){Ti(f,l,b);uj();break a}k=Error(p(426))}}else if(I&&h.mode&1){var J=Vi(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Wi(J,g,h,f,b);Jg(Ki(k,h));break a}}f=k=Ki(k,h);4!==T&&(T=2);null===tk?tk=[f]:tk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;\nb&=-b;f.lanes|=b;var x=Oi(f,k,b);fh(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&(\"function\"===typeof w.getDerivedStateFromError||null!==u&&\"function\"===typeof u.componentDidCatch&&(null===Si||!Si.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Ri(f,h,b);fh(f,F);break a}}f=f.return}while(null!==f)}Tk(c)}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Kk(){var a=nk.current;nk.current=ai;return null===a?ai:a}\nfunction uj(){if(0===T||3===T||2===T)T=4;null===R||0===(hh&268435455)&&0===(rk&268435455)||Dk(R,Z)}function Jk(a,b){var c=K;K|=2;var d=Kk();if(R!==a||Z!==b)vk=null,Lk(a,b);do try{Uk();break}catch(e){Nk(a,e)}while(1);Qg();K=c;nk.current=d;if(null!==Y)throw Error(p(261));R=null;Z=0;return T}function Uk(){for(;null!==Y;)Vk(Y)}function Mk(){for(;null!==Y&&!cc();)Vk(Y)}function Vk(a){var b=Wk(a.alternate,a,gj);a.memoizedProps=a.pendingProps;null===b?Tk(a):Y=b;ok.current=null}\nfunction Tk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Fj(c,b,gj),null!==c){Y=c;return}}else{c=Jj(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else{T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a}while(null!==b);0===T&&(T=5)}function Qk(a,b,c){var d=C,e=pk.transition;try{pk.transition=null,C=1,Xk(a,b,c,d)}finally{pk.transition=e,C=d}return null}\nfunction Xk(a,b,c,d){do Ik();while(null!==xk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===R&&(Y=R=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||wk||(wk=!0,Gk(hc,function(){Ik();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=pk.transition;pk.transition=null;\nvar g=C;C=1;var h=K;K|=4;ok.current=null;Pj(a,c);ek(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;ik(c,a,e);dc();K=h;C=g;pk.transition=f}else a.current=c;wk&&(wk=!1,xk=a,yk=e);f=a.pendingLanes;0===f&&(Si=null);mc(c.stateNode,d);Ek(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Pi)throw Pi=!1,a=Qi,Qi=null,a;0!==(yk&1)&&0!==a.tag&&Ik();f=a.pendingLanes;0!==(f&1)?a===Ak?zk++:(zk=0,Ak=a):zk=0;jg();return null}\nfunction Ik(){if(null!==xk){var a=Dc(yk),b=pk.transition,c=C;try{pk.transition=null;C=16>a?16:a;if(null===xk)var d=!1;else{a=xk;xk=null;yk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Qj(8,m,f)}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Tj(m);if(m===\nl){V=null;break}if(null!==r){r.return=y;V=r;break}V=y}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J}while(null!==t)}}V=f}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Qj(9,f,f.return)}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==\nu)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Rj(9,h)}}catch(na){W(h,h.return,na)}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return}}K=e;jg();if(lc&&\"function\"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a)}catch(na){}d=!0}return d}finally{C=c,pk.transition=b}}return!1}function Yk(a,b,c){b=Ki(c,b);b=Oi(a,b,1);a=dh(a,b,1);b=L();null!==a&&(Ac(a,1,b),Ek(a,b))}\nfunction W(a,b,c){if(3===a.tag)Yk(a,a,c);else for(;null!==b;){if(3===b.tag){Yk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if(\"function\"===typeof b.type.getDerivedStateFromError||\"function\"===typeof d.componentDidCatch&&(null===Si||!Si.has(d))){a=Ki(c,a);a=Ri(b,a,1);b=dh(b,a,1);a=L();null!==b&&(Ac(b,1,a),Ek(b,a));break}}b=b.return}}\nfunction Ui(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=L();a.pingedLanes|=a.suspendedLanes&c;R===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-gk?Lk(a,0):sk|=c);Ek(a,b)}function Zk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=L();a=Zg(a,b);null!==a&&(Ac(a,b,c),Ek(a,c))}function vj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Zk(a,c)}\nfunction ck(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Zk(a,c)}var Wk;\nWk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)Ug=!0;else{if(0===(a.lanes&c)&&0===(b.flags&128))return Ug=!1,zj(a,b,c);Ug=0!==(a.flags&131072)?!0:!1}else Ug=!1,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;jj(a,b);a=b.pendingProps;var e=Yf(b,H.current);Tg(b,c);e=Xh(null,b,d,a,e,c);var f=bi();b.flags|=1;\"object\"===typeof e&&null!==e&&\"function\"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=\nnull,Zf(d)?(f=!0,cg(b)):f=!1,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,ah(b),e.updater=nh,b.stateNode=e,e._reactInternals=b,rh(b,d,a,c),b=kj(null,b,d,!0,f,c)):(b.tag=0,I&&f&&vg(b),Yi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{jj(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=$k(d);a=Lg(d,a);switch(e){case 0:b=dj(null,b,d,a,c);break a;case 1:b=ij(null,b,d,a,c);break a;case 11:b=Zi(null,b,d,a,c);break a;case 14:b=aj(null,b,d,Lg(d.type,a),c);break a}throw Error(p(306,\nd,\"\"));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),dj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),ij(a,b,d,e,c);case 3:a:{lj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;bh(a,b);gh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:!1,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=\nf,b.memoizedState=f,b.flags&256){e=Ki(Error(p(423)),b);b=mj(a,b,d,c,e);break a}else if(d!==e){e=Ki(Error(p(424)),b);b=mj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=!0,zg=null,c=Ch(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else{Ig();if(d===e){b=$i(a,b,c);break a}Yi(a,b,d,c)}b=b.child}return b;case 5:return Kh(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),\nhj(a,b),Yi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return pj(a,b,c);case 4:return Ih(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Bh(b,null,d,c):Yi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),Zi(a,b,d,e,c);case 7:return Yi(a,b,b.pendingProps,c),b.child;case 8:return Yi(a,b,b.pendingProps.children,c),b.child;case 12:return Yi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;\ng=e.value;G(Mg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=$i(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=ch(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);Sg(f.return,\nc,b);h.lanes|=c;break}k=k.next}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);Sg(g,c,b);g=f.sibling}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return}f=g}Yi(a,b,e.children,c);b=b.child}return b;case 9:return e=b.type,d=b.pendingProps.children,Tg(b,c),e=Vg(e),d=d(e),b.flags|=1,Yi(a,b,d,c),\nb.child;case 14:return d=b.type,e=Lg(d,b.pendingProps),e=Lg(d.type,e),aj(a,b,d,e,c);case 15:return cj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Lg(d,e),jj(a,b),b.tag=1,Zf(d)?(a=!0,cg(b)):a=!1,Tg(b,c),ph(b,d,e),rh(b,d,e,c),kj(null,b,d,!0,a,c);case 19:return yj(a,b,c);case 22:return ej(a,b,c)}throw Error(p(156,b.tag));};function Gk(a,b){return ac(a,b)}\nfunction al(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null}function Bg(a,b,c,d){return new al(a,b,c,d)}function bj(a){a=a.prototype;return!(!a||!a.isReactComponent)}\nfunction $k(a){if(\"function\"===typeof a)return bj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}\nfunction wh(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};\nc.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}\nfunction yh(a,b,c,d,e,f){var g=2;d=a;if(\"function\"===typeof a)bj(a)&&(g=1);else if(\"string\"===typeof a)g=5;else a:switch(a){case ya:return Ah(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return qj(c,e,f,b);default:if(\"object\"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;\nbreak a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,\"\"));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Ah(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function qj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:!1};return a}function xh(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}\nfunction zh(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}\nfunction bl(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=\nnull}function cl(a,b,c,d,e,f,g,h,k){a=new bl(a,b,c,h,k);1===b?(b=1,!0===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};ah(f);return a}function dl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:wa,key:null==d?null:\"\"+d,children:a,containerInfo:b,implementation:c}}\nfunction el(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}\nfunction fl(a,b,c,d,e,f,g,h,k){a=cl(c,d,!0,a,e,f,g,h,k);a.context=el(null);c=a.current;d=L();e=lh(c);f=ch(d,e);f.callback=void 0!==b&&null!==b?b:null;dh(c,f,e);a.current.lanes=e;Ac(a,e,d);Ek(a,d);return a}function gl(a,b,c,d){var e=b.current,f=L(),g=lh(e);c=el(c);null===b.context?b.context=c:b.pendingContext=c;b=ch(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=dh(e,b,g);null!==a&&(mh(a,e,g,f),eh(a,e,g));return g}\nfunction hl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function il(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b}}function jl(a,b){il(a,b);(a=a.alternate)&&il(a,b)}function kl(){return null}var ll=\"function\"===typeof reportError?reportError:function(a){console.error(a)};function ml(a){this._internalRoot=a}\nnl.prototype.render=ml.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));gl(a,b,null,null)};nl.prototype.unmount=ml.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Sk(function(){gl(null,a,null,null)});b[uf]=null}};function nl(a){this._internalRoot=a}\nnl.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a)}};function ol(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function pl(a){return!(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||\" react-mount-point-unstable \"!==a.nodeValue))}function ql(){}\nfunction rl(a,b,c,d,e){if(e){if(\"function\"===typeof d){var f=d;d=function(){var a=hl(g);f.call(a)}}var g=fl(b,d,a,0,null,!1,!1,\"\",ql);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Sk();return g}for(;e=a.lastChild;)a.removeChild(e);if(\"function\"===typeof d){var h=d;d=function(){var a=hl(k);h.call(a)}}var k=cl(a,0,!1,null,null,!1,!1,\"\",ql);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Sk(function(){gl(b,k,c,d)});return k}\nfunction sl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if(\"function\"===typeof e){var h=e;e=function(){var a=hl(g);h.call(a)}}gl(b,g,a,e)}else g=rl(c,b,a,e,d);return hl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Ek(b,B()),0===(K&6)&&(Hj=B()+500,jg()))}break;case 13:Sk(function(){var b=Zg(a,1);if(null!==b){var c=L();mh(b,a,1,c)}}),jl(a,1)}};\nFc=function(a){if(13===a.tag){var b=Zg(a,134217728);if(null!==b){var c=L();mh(b,a,134217728,c)}jl(a,134217728)}};Gc=function(a){if(13===a.tag){var b=lh(a),c=Zg(a,b);if(null!==c){var d=L();mh(c,a,b,d)}jl(a,b)}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c}};\nyb=function(a,b,c){switch(b){case \"input\":bb(a,c);b=c.name;if(\"radio\"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll(\"input[name=\"+JSON.stringify(\"\"+b)+'][type=\"radio\"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e)}}}break;case \"textarea\":ib(a,c);break;case \"select\":b=c.value,null!=b&&fb(a,!!c.multiple,b,!1)}};Gb=Rk;Hb=Sk;\nvar tl={usingClientEntryPoint:!1,Events:[Cb,ue,Db,Eb,Fb,Rk]},ul={findFiberByHostInstance:Wc,bundleType:0,version:\"18.2.0\",rendererPackageName:\"react-dom\"};\nvar vl={bundleType:ul.bundleType,version:ul.version,rendererPackageName:ul.rendererPackageName,rendererConfig:ul.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:ul.findFiberByHostInstance||\nkl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:\"18.2.0-next-9e3b772b8-20220608\"};if(\"undefined\"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var wl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!wl.isDisabled&&wl.supportsFiber)try{kc=wl.inject(vl),lc=wl}catch(a){}}exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=tl;\nexports.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!ol(b))throw Error(p(200));return dl(a,b,null,c)};exports.createRoot=function(a,b){if(!ol(a))throw Error(p(299));var c=!1,d=\"\",e=ll;null!==b&&void 0!==b&&(!0===b.unstable_strictMode&&(c=!0),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=cl(a,1,!1,null,null,c,!1,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ml(b)};\nexports.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if(\"function\"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(\",\");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};exports.flushSync=function(a){return Sk(a)};exports.hydrate=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!0,c)};\nexports.hydrateRoot=function(a,b,c){if(!ol(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=!1,f=\"\",g=ll;null!==c&&void 0!==c&&(!0===c.unstable_strictMode&&(e=!0),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=fl(b,null,a,1,null!=c?c:null,e,!1,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,\ne);return new nl(b)};exports.render=function(a,b,c){if(!pl(b))throw Error(p(200));return sl(null,a,b,!1,c)};exports.unmountComponentAtNode=function(a){if(!pl(a))throw Error(p(40));return a._reactRootContainer?(Sk(function(){sl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null})}),!0):!1};exports.unstable_batchedUpdates=Rk;\nexports.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!pl(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return sl(a,b,c,!1,d)};exports.version=\"18.2.0-next-9e3b772b8-20220608\";\n","/*!\n\tCopyright (c) 2018 Jed Watson.\n\tLicensed under the MIT License (MIT), see\n\thttp://jedwatson.github.io/classnames\n*/\n/* global define */\n\n(function () {\n\t'use strict';\n\n\tvar hasOwn = {}.hasOwnProperty;\n\tvar nativeCodeString = '[native code]';\n\n\tfunction classNames() {\n\t\tvar classes = [];\n\n\t\tfor (var i = 0; i < arguments.length; i++) {\n\t\t\tvar arg = arguments[i];\n\t\t\tif (!arg) continue;\n\n\t\t\tvar argType = typeof arg;\n\n\t\t\tif (argType === 'string' || argType === 'number') {\n\t\t\t\tclasses.push(arg);\n\t\t\t} else if (Array.isArray(arg)) {\n\t\t\t\tif (arg.length) {\n\t\t\t\t\tvar inner = classNames.apply(null, arg);\n\t\t\t\t\tif (inner) {\n\t\t\t\t\t\tclasses.push(inner);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (argType === 'object') {\n\t\t\t\tif (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {\n\t\t\t\t\tclasses.push(arg.toString());\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor (var key in arg) {\n\t\t\t\t\tif (hasOwn.call(arg, key) && arg[key]) {\n\t\t\t\t\t\tclasses.push(key);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn classes.join(' ');\n\t}\n\n\tif (typeof module !== 'undefined' && module.exports) {\n\t\tclassNames.default = classNames;\n\t\tmodule.exports = classNames;\n\t} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {\n\t\t// register as 'classnames', consistent with npm package name\n\t\tdefine('classnames', [], function () {\n\t\t\treturn classNames;\n\t\t});\n\t} else {\n\t\twindow.classNames = classNames;\n\t}\n}());\n","/**\n * @remix-run/router v1.13.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */\nvar Action;\n(function (Action) {\n  /**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */\n  Action[\"Push\"] = \"PUSH\";\n  /**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\nconst PopStateEventType = \"popstate\";\n/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    initialEntries = [\"/\"],\n    initialIndex,\n    v5Compat = false\n  } = options;\n  let entries; // Declare so we can access from createMemoryLocation\n  entries = initialEntries.map((entry, index) => createMemoryLocation(entry, typeof entry === \"string\" ? null : entry.state, index === 0 ? \"default\" : undefined));\n  let index = clampIndex(initialIndex == null ? entries.length - 1 : initialIndex);\n  let action = Action.Pop;\n  let listener = null;\n  function clampIndex(n) {\n    return Math.min(Math.max(n, 0), entries.length - 1);\n  }\n  function getCurrentLocation() {\n    return entries[index];\n  }\n  function createMemoryLocation(to, state, key) {\n    if (state === void 0) {\n      state = null;\n    }\n    let location = createLocation(entries ? getCurrentLocation().pathname : \"/\", to, state, key);\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in memory history: \" + JSON.stringify(to));\n    return location;\n  }\n  function createHref(to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  let history = {\n    get index() {\n      return index;\n    },\n    get action() {\n      return action;\n    },\n    get location() {\n      return getCurrentLocation();\n    },\n    createHref,\n    createURL(to) {\n      return new URL(createHref(to), \"http://localhost\");\n    },\n    encodeLocation(to) {\n      let path = typeof to === \"string\" ? parsePath(to) : to;\n      return {\n        pathname: path.pathname || \"\",\n        search: path.search || \"\",\n        hash: path.hash || \"\"\n      };\n    },\n    push(to, state) {\n      action = Action.Push;\n      let nextLocation = createMemoryLocation(to, state);\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 1\n        });\n      }\n    },\n    replace(to, state) {\n      action = Action.Replace;\n      let nextLocation = createMemoryLocation(to, state);\n      entries[index] = nextLocation;\n      if (v5Compat && listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta: 0\n        });\n      }\n    },\n    go(delta) {\n      action = Action.Pop;\n      let nextIndex = clampIndex(index + delta);\n      let nextLocation = entries[nextIndex];\n      index = nextIndex;\n      if (listener) {\n        listener({\n          action,\n          location: nextLocation,\n          delta\n        });\n      }\n    },\n    listen(fn) {\n      listener = fn;\n      return () => {\n        listener = null;\n      };\n    }\n  };\n  return history;\n}\n/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createBrowserLocation(window, globalHistory) {\n    let {\n      pathname,\n      search,\n      hash\n    } = window.location;\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createBrowserHref(window, to) {\n    return typeof to === \"string\" ? to : createPath(to);\n  }\n  return getUrlBasedHistory(createBrowserLocation, createBrowserHref, null, options);\n}\n/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n  function createHashLocation(window, globalHistory) {\n    let {\n      pathname = \"/\",\n      search = \"\",\n      hash = \"\"\n    } = parsePath(window.location.hash.substr(1));\n    // Hash URL should always have a leading / just like window.location.pathname\n    // does, so if an app ends up at a route like /#something then we add a\n    // leading slash so all of our path-matching behaves the same as if it would\n    // in a browser router.  This is particularly important when there exists a\n    // root splat route (<Route path=\"*\">) since that matches internally against\n    // \"/*\" and we'd expect /#something to 404 in a hash router app.\n    if (!pathname.startsWith(\"/\") && !pathname.startsWith(\".\")) {\n      pathname = \"/\" + pathname;\n    }\n    return createLocation(\"\", {\n      pathname,\n      search,\n      hash\n    },\n    // state defaults to `null` because `window.history.state` does\n    globalHistory.state && globalHistory.state.usr || null, globalHistory.state && globalHistory.state.key || \"default\");\n  }\n  function createHashHref(window, to) {\n    let base = window.document.querySelector(\"base\");\n    let href = \"\";\n    if (base && base.getAttribute(\"href\")) {\n      let url = window.location.href;\n      let hashIndex = url.indexOf(\"#\");\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n    return href + \"#\" + (typeof to === \"string\" ? to : createPath(to));\n  }\n  function validateHashLocation(location, to) {\n    warning(location.pathname.charAt(0) === \"/\", \"relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\");\n  }\n  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);\n}\nfunction invariant(value, message) {\n  if (value === false || value === null || typeof value === \"undefined\") {\n    throw new Error(message);\n  }\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience, so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message);\n      // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\n * For browser-based histories, we combine the state and key into an object\n */\nfunction getHistoryState(location, index) {\n  return {\n    usr: location.state,\n    key: location.key,\n    idx: index\n  };\n}\n/**\n * Creates a Location object with a unique key from the given Path\n */\nfunction createLocation(current, to, state, key) {\n  if (state === void 0) {\n    state = null;\n  }\n  let location = _extends({\n    pathname: typeof current === \"string\" ? current : current.pathname,\n    search: \"\",\n    hash: \"\"\n  }, typeof to === \"string\" ? parsePath(to) : to, {\n    state,\n    // TODO: This could be cleaned up.  push/replace should probably just take\n    // full Locations now and avoid the need to run through this flow at all\n    // But that's a pretty big refactor to the current test suite so going to\n    // keep as is for the time being and just let any incoming keys take precedence\n    key: to && to.key || key || createKey()\n  });\n  return location;\n}\n/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */\nfunction createPath(_ref) {\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\"\n  } = _ref;\n  if (search && search !== \"?\") pathname += search.charAt(0) === \"?\" ? search : \"?\" + search;\n  if (hash && hash !== \"#\") pathname += hash.charAt(0) === \"#\" ? hash : \"#\" + hash;\n  return pathname;\n}\n/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */\nfunction parsePath(path) {\n  let parsedPath = {};\n  if (path) {\n    let hashIndex = path.indexOf(\"#\");\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n    let searchIndex = path.indexOf(\"?\");\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n  return parsedPath;\n}\nfunction getUrlBasedHistory(getLocation, createHref, validateLocation, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  let {\n    window = document.defaultView,\n    v5Compat = false\n  } = options;\n  let globalHistory = window.history;\n  let action = Action.Pop;\n  let listener = null;\n  let index = getIndex();\n  // Index should only be null when we initialize. If not, it's because the\n  // user called history.pushState or history.replaceState directly, in which\n  // case we should log a warning as it will result in bugs.\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), \"\");\n  }\n  function getIndex() {\n    let state = globalHistory.state || {\n      idx: null\n    };\n    return state.idx;\n  }\n  function handlePop() {\n    action = Action.Pop;\n    let nextIndex = getIndex();\n    let delta = nextIndex == null ? null : nextIndex - index;\n    index = nextIndex;\n    if (listener) {\n      listener({\n        action,\n        location: history.location,\n        delta\n      });\n    }\n  }\n  function push(to, state) {\n    action = Action.Push;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex() + 1;\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    // try...catch because iOS limits us to 100 pushState calls :/\n    try {\n      globalHistory.pushState(historyState, \"\", url);\n    } catch (error) {\n      // If the exception is because `state` can't be serialized, let that throw\n      // outwards just like a replace call would so the dev knows the cause\n      // https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n      // https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\n      if (error instanceof DOMException && error.name === \"DataCloneError\") {\n        throw error;\n      }\n      // They are going to lose state here, but there is no real\n      // way to warn them about it since the page will refresh...\n      window.location.assign(url);\n    }\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 1\n      });\n    }\n  }\n  function replace(to, state) {\n    action = Action.Replace;\n    let location = createLocation(history.location, to, state);\n    if (validateLocation) validateLocation(location, to);\n    index = getIndex();\n    let historyState = getHistoryState(location, index);\n    let url = history.createHref(location);\n    globalHistory.replaceState(historyState, \"\", url);\n    if (v5Compat && listener) {\n      listener({\n        action,\n        location: history.location,\n        delta: 0\n      });\n    }\n  }\n  function createURL(to) {\n    // window.location.origin is \"null\" (the literal string value) in Firefox\n    // under certain conditions, notably when serving from a local HTML file\n    // See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\n    let base = window.location.origin !== \"null\" ? window.location.origin : window.location.href;\n    let href = typeof to === \"string\" ? to : createPath(to);\n    invariant(base, \"No window.location.(origin|href) available to create URL for href: \" + href);\n    return new URL(href, base);\n  }\n  let history = {\n    get action() {\n      return action;\n    },\n    get location() {\n      return getLocation(window, globalHistory);\n    },\n    listen(fn) {\n      if (listener) {\n        throw new Error(\"A history only accepts one active listener\");\n      }\n      window.addEventListener(PopStateEventType, handlePop);\n      listener = fn;\n      return () => {\n        window.removeEventListener(PopStateEventType, handlePop);\n        listener = null;\n      };\n    },\n    createHref(to) {\n      return createHref(window, to);\n    },\n    createURL,\n    encodeLocation(to) {\n      // Encode a Location the same way window.location would\n      let url = createURL(to);\n      return {\n        pathname: url.pathname,\n        search: url.search,\n        hash: url.hash\n      };\n    },\n    push,\n    replace,\n    go(n) {\n      return globalHistory.go(n);\n    }\n  };\n  return history;\n}\n//#endregion\n\nvar ResultType;\n(function (ResultType) {\n  ResultType[\"data\"] = \"data\";\n  ResultType[\"deferred\"] = \"deferred\";\n  ResultType[\"redirect\"] = \"redirect\";\n  ResultType[\"error\"] = \"error\";\n})(ResultType || (ResultType = {}));\nconst immutableRouteKeys = new Set([\"lazy\", \"caseSensitive\", \"path\", \"id\", \"index\", \"children\"]);\nfunction isIndexRoute(route) {\n  return route.index === true;\n}\n// Walk the route tree generating unique IDs where necessary, so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes, mapRouteProperties, parentPath, manifest) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  if (manifest === void 0) {\n    manifest = {};\n  }\n  return routes.map((route, index) => {\n    let treePath = [...parentPath, index];\n    let id = typeof route.id === \"string\" ? route.id : treePath.join(\"-\");\n    invariant(route.index !== true || !route.children, \"Cannot specify children on an index route\");\n    invariant(!manifest[id], \"Found a route id collision on id \\\"\" + id + \"\\\".  Route \" + \"id's must be globally unique within Data Router usages\");\n    if (isIndexRoute(route)) {\n      let indexRoute = _extends({}, route, mapRouteProperties(route), {\n        id\n      });\n      manifest[id] = indexRoute;\n      return indexRoute;\n    } else {\n      let pathOrLayoutRoute = _extends({}, route, mapRouteProperties(route), {\n        id,\n        children: undefined\n      });\n      manifest[id] = pathOrLayoutRoute;\n      if (route.children) {\n        pathOrLayoutRoute.children = convertRoutesToDataRoutes(route.children, mapRouteProperties, treePath, manifest);\n      }\n      return pathOrLayoutRoute;\n    }\n  });\n}\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n  if (pathname == null) {\n    return null;\n  }\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i],\n    // Incoming pathnames are generally encoded from either window.location\n    // or from router.navigate, but we want to match against the unencoded\n    // paths in the route definitions.  Memory router locations won't be\n    // encoded here but there also shouldn't be anything to decode so this\n    // should be a safe operation.  This avoids needing matchRoutes to be\n    // history-aware.\n    safelyDecodeURI(pathname));\n  }\n  return matches;\n}\nfunction convertRouteMatchToUiMatch(match, loaderData) {\n  let {\n    route,\n    pathname,\n    params\n  } = match;\n  return {\n    id: route.id,\n    pathname,\n    params,\n    data: loaderData[route.id],\n    handle: route.handle\n  };\n}\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n  let flattenRoute = (route, index, relativePath) => {\n    let meta = {\n      relativePath: relativePath === undefined ? route.path || \"\" : relativePath,\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n    if (meta.relativePath.startsWith(\"/\")) {\n      invariant(meta.relativePath.startsWith(parentPath), \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\");\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta);\n    // Add the children before adding this route to the array, so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n    if (route.children && route.children.length > 0) {\n      invariant(\n      // Our types know better, but runtime JS may not!\n      // @ts-expect-error\n      route.index !== true, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\"));\n      flattenRoutes(route.children, branches, routesMeta, path);\n    }\n    // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n    if (route.path == null && !route.index) {\n      return;\n    }\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  };\n  routes.forEach((route, index) => {\n    var _route$path;\n    // coarse-grain check for optional params\n    if (route.path === \"\" || !((_route$path = route.path) != null && _route$path.includes(\"?\"))) {\n      flattenRoute(route, index);\n    } else {\n      for (let exploded of explodeOptionalSegments(route.path)) {\n        flattenRoute(route, index, exploded);\n      }\n    }\n  });\n  return branches;\n}\n/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */\nfunction explodeOptionalSegments(path) {\n  let segments = path.split(\"/\");\n  if (segments.length === 0) return [];\n  let [first, ...rest] = segments;\n  // Optional path segments are denoted by a trailing `?`\n  let isOptional = first.endsWith(\"?\");\n  // Compute the corresponding required segment: `foo?` -> `foo`\n  let required = first.replace(/\\?$/, \"\");\n  if (rest.length === 0) {\n    // Intepret empty string as omitting an optional segment\n    // `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\n    return isOptional ? [required, \"\"] : [required];\n  }\n  let restExploded = explodeOptionalSegments(rest.join(\"/\"));\n  let result = [];\n  // All child paths with the prefix.  Do this for all children before the\n  // optional version for all children, so we get consistent ordering where the\n  // parent optional aspect is preferred as required.  Otherwise, we can get\n  // child sections interspersed where deeper optional segments are higher than\n  // parent optional segments, where for example, /:two would explode _earlier_\n  // then /:one.  By always including the parent as required _for all children_\n  // first, we avoid this issue\n  result.push(...restExploded.map(subpath => subpath === \"\" ? required : [required, subpath].join(\"/\")));\n  // Then, if this is an optional value, add all child versions without\n  if (isOptional) {\n    result.push(...restExploded);\n  }\n  // for absolute paths, ensure `/` instead of empty segment\n  return result.map(exploded => path.startsWith(\"/\") && exploded === \"\" ? \"/\" : exploded);\n}\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\nconst isSplat = s => s === \"*\";\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ?\n  // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] :\n  // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      // TODO: Can this as be avoided?\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n  return matches;\n}\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */\nfunction generatePath(originalPath, params) {\n  if (params === void 0) {\n    params = {};\n  }\n  let path = originalPath;\n  if (path.endsWith(\"*\") && path !== \"*\" && !path.endsWith(\"/*\")) {\n    warning(false, \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n    path = path.replace(/\\*$/, \"/*\");\n  }\n  // ensure `/` is added at the beginning if the path is absolute\n  const prefix = path.startsWith(\"/\") ? \"/\" : \"\";\n  const stringify = p => p == null ? \"\" : typeof p === \"string\" ? p : String(p);\n  const segments = path.split(/\\/+/).map((segment, index, array) => {\n    const isLastSegment = index === array.length - 1;\n    // only apply the splat if it's the last segment\n    if (isLastSegment && segment === \"*\") {\n      const star = \"*\";\n      // Apply the splat\n      return stringify(params[star]);\n    }\n    const keyMatch = segment.match(/^:(\\w+)(\\??)$/);\n    if (keyMatch) {\n      const [, key, optional] = keyMatch;\n      let param = params[key];\n      invariant(optional === \"?\" || param != null, \"Missing \\\":\" + key + \"\\\" param\");\n      return stringify(param);\n    }\n    // Remove any optional markers from optional static segments\n    return segment.replace(/\\?$/g, \"\");\n  })\n  // Remove empty segments\n  .filter(segment => !!segment);\n  return prefix + segments.join(\"/\");\n}\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n  let [matcher, compiledParams] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = compiledParams.reduce((memo, _ref, index) => {\n    let {\n      paramName,\n      isOptional\n    } = _ref;\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n    const value = captureGroups[index];\n    if (isOptional && !value) {\n      memo[paramName] = undefined;\n    } else {\n      memo[paramName] = safelyDecodeURIComponent(value || \"\", paramName);\n    }\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n  if (end === void 0) {\n    end = true;\n  }\n  warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\"));\n  let params = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^${}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/\\/:(\\w+)(\\?)?/g, (_, paramName, isOptional) => {\n    params.push({\n      paramName,\n      isOptional: isOptional != null\n    });\n    return isOptional ? \"/?([^\\\\/]+)?\" : \"/([^\\\\/]+)\";\n  });\n  if (path.endsWith(\"*\")) {\n    params.push({\n      paramName: \"*\"\n    });\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else if (end) {\n    // When matching to the end, ignore trailing slashes\n    regexpSource += \"\\\\/*$\";\n  } else if (path !== \"\" && path !== \"/\") {\n    // If our path is non-empty and contains anything beyond an initial slash,\n    // then we have _some_ form of path in our regex, so we should expect to\n    // match only if we find the end of this path segment.  Look for an optional\n    // non-captured trailing slash (to match a portion of the URL) or the end\n    // of the path (if we've matched to the end).  We used to do this with a\n    // word boundary but that gives false positives on routes like\n    // /user-preferences since `-` counts as a word boundary.\n    regexpSource += \"(?:(?=\\\\/|$))\";\n  } else ;\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, params];\n}\nfunction safelyDecodeURI(value) {\n  try {\n    return decodeURI(value);\n  } catch (error) {\n    warning(false, \"The URL path \\\"\" + value + \"\\\" could not be decoded because it is is a \" + \"malformed URL segment. This is probably due to a bad percent \" + (\"encoding (\" + error + \").\"));\n    return value;\n  }\n}\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\"));\n    return value;\n  }\n}\n/**\n * @private\n */\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n  // We want to leave trailing slash behavior in the user's control, so if they\n  // specify a basename with a trailing slash, we should support it\n  let startIndex = basename.endsWith(\"/\") ? basename.length - 1 : basename.length;\n  let nextChar = pathname.charAt(startIndex);\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n  return pathname.slice(startIndex) || \"/\";\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\nfunction getInvalidPathError(char, field, dest, path) {\n  return \"Cannot include a '\" + char + \"' character in a manually specified \" + (\"`to.\" + field + \"` field [\" + JSON.stringify(path) + \"].  Please separate it out to the \") + (\"`to.\" + dest + \"` field. Alternatively you may provide the full path as \") + \"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";\n}\n/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */\nfunction getPathContributingMatches(matches) {\n  return matches.filter((match, index) => index === 0 || match.route.path && match.route.path.length > 0);\n}\n// Return the array of pathnames for the current route matches - used to\n// generate the routePathnames input for resolveTo()\nfunction getResolveToMatches(matches) {\n  // Use the full pathname for the leaf match so we include splat values for \".\" links\n  return getPathContributingMatches(matches).map((match, idx) => idx === matches.length - 1 ? match.pathname : match.pathnameBase);\n}\n/**\n * @private\n */\nfunction resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {\n  if (isPathRelative === void 0) {\n    isPathRelative = false;\n  }\n  let to;\n  if (typeof toArg === \"string\") {\n    to = parsePath(toArg);\n  } else {\n    to = _extends({}, toArg);\n    invariant(!to.pathname || !to.pathname.includes(\"?\"), getInvalidPathError(\"?\", \"pathname\", \"search\", to));\n    invariant(!to.pathname || !to.pathname.includes(\"#\"), getInvalidPathError(\"#\", \"pathname\", \"hash\", to));\n    invariant(!to.search || !to.search.includes(\"#\"), getInvalidPathError(\"#\", \"search\", \"hash\", to));\n  }\n  let isEmptyPath = toArg === \"\" || to.pathname === \"\";\n  let toPathname = isEmptyPath ? \"/\" : to.pathname;\n  let from;\n  // Routing is relative to the current pathname if explicitly requested.\n  //\n  // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n  if (toPathname == null) {\n    from = locationPathname;\n  } else if (isPathRelative) {\n    let fromSegments = routePathnames[routePathnames.length - 1].replace(/^\\//, \"\").split(\"/\");\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      // With relative=\"path\", each leading .. segment means \"go up one URL segment\"\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        fromSegments.pop();\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    from = \"/\" + fromSegments.join(\"/\");\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\");\n      // With relative=\"route\" (the default), each leading .. segment means\n      // \"go up one route\" instead of \"go up one URL segment\".  This is a key\n      // difference from how <a href> works and a major reason we call this a\n      // \"to\" value instead of a \"href\".\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n      to.pathname = toSegments.join(\"/\");\n    }\n    // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n  let path = resolvePath(to, from);\n  // Ensure the pathname has a trailing slash if the original \"to\" had one\n  let hasExplicitTrailingSlash = toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\");\n  // Or if this was a link to the current path which has a trailing slash\n  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === \".\") && locationPathname.endsWith(\"/\");\n  if (!path.pathname.endsWith(\"/\") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {\n    path.pathname += \"/\";\n  }\n  return path;\n}\n/**\n * @private\n */\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\n/**\n * @private\n */\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\n/**\n * @private\n */\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n/**\n * @private\n */\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n/**\n * @private\n */\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */\nconst json = function json(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  let headers = new Headers(responseInit.headers);\n  if (!headers.has(\"Content-Type\")) {\n    headers.set(\"Content-Type\", \"application/json; charset=utf-8\");\n  }\n  return new Response(JSON.stringify(data), _extends({}, responseInit, {\n    headers\n  }));\n};\nclass AbortedDeferredError extends Error {}\nclass DeferredData {\n  constructor(data, responseInit) {\n    this.pendingKeysSet = new Set();\n    this.subscribers = new Set();\n    this.deferredKeys = [];\n    invariant(data && typeof data === \"object\" && !Array.isArray(data), \"defer() only accepts plain objects\");\n    // Set up an AbortController + Promise we can race against to exit early\n    // cancellation\n    let reject;\n    this.abortPromise = new Promise((_, r) => reject = r);\n    this.controller = new AbortController();\n    let onAbort = () => reject(new AbortedDeferredError(\"Deferred data aborted\"));\n    this.unlistenAbortSignal = () => this.controller.signal.removeEventListener(\"abort\", onAbort);\n    this.controller.signal.addEventListener(\"abort\", onAbort);\n    this.data = Object.entries(data).reduce((acc, _ref2) => {\n      let [key, value] = _ref2;\n      return Object.assign(acc, {\n        [key]: this.trackPromise(key, value)\n      });\n    }, {});\n    if (this.done) {\n      // All incoming values were resolved\n      this.unlistenAbortSignal();\n    }\n    this.init = responseInit;\n  }\n  trackPromise(key, value) {\n    if (!(value instanceof Promise)) {\n      return value;\n    }\n    this.deferredKeys.push(key);\n    this.pendingKeysSet.add(key);\n    // We store a little wrapper promise that will be extended with\n    // _data/_error props upon resolve/reject\n    let promise = Promise.race([value, this.abortPromise]).then(data => this.onSettle(promise, key, undefined, data), error => this.onSettle(promise, key, error));\n    // Register rejection listeners to avoid uncaught promise rejections on\n    // errors or aborted deferred values\n    promise.catch(() => {});\n    Object.defineProperty(promise, \"_tracked\", {\n      get: () => true\n    });\n    return promise;\n  }\n  onSettle(promise, key, error, data) {\n    if (this.controller.signal.aborted && error instanceof AbortedDeferredError) {\n      this.unlistenAbortSignal();\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      return Promise.reject(error);\n    }\n    this.pendingKeysSet.delete(key);\n    if (this.done) {\n      // Nothing left to abort!\n      this.unlistenAbortSignal();\n    }\n    // If the promise was resolved/rejected with undefined, we'll throw an error as you\n    // should always resolve with a value or null\n    if (error === undefined && data === undefined) {\n      let undefinedError = new Error(\"Deferred data for key \\\"\" + key + \"\\\" resolved/rejected with `undefined`, \" + \"you must resolve/reject with a value or `null`.\");\n      Object.defineProperty(promise, \"_error\", {\n        get: () => undefinedError\n      });\n      this.emit(false, key);\n      return Promise.reject(undefinedError);\n    }\n    if (data === undefined) {\n      Object.defineProperty(promise, \"_error\", {\n        get: () => error\n      });\n      this.emit(false, key);\n      return Promise.reject(error);\n    }\n    Object.defineProperty(promise, \"_data\", {\n      get: () => data\n    });\n    this.emit(false, key);\n    return data;\n  }\n  emit(aborted, settledKey) {\n    this.subscribers.forEach(subscriber => subscriber(aborted, settledKey));\n  }\n  subscribe(fn) {\n    this.subscribers.add(fn);\n    return () => this.subscribers.delete(fn);\n  }\n  cancel() {\n    this.controller.abort();\n    this.pendingKeysSet.forEach((v, k) => this.pendingKeysSet.delete(k));\n    this.emit(true);\n  }\n  async resolveData(signal) {\n    let aborted = false;\n    if (!this.done) {\n      let onAbort = () => this.cancel();\n      signal.addEventListener(\"abort\", onAbort);\n      aborted = await new Promise(resolve => {\n        this.subscribe(aborted => {\n          signal.removeEventListener(\"abort\", onAbort);\n          if (aborted || this.done) {\n            resolve(aborted);\n          }\n        });\n      });\n    }\n    return aborted;\n  }\n  get done() {\n    return this.pendingKeysSet.size === 0;\n  }\n  get unwrappedData() {\n    invariant(this.data !== null && this.done, \"Can only unwrap data on initialized and settled deferreds\");\n    return Object.entries(this.data).reduce((acc, _ref3) => {\n      let [key, value] = _ref3;\n      return Object.assign(acc, {\n        [key]: unwrapTrackedPromise(value)\n      });\n    }, {});\n  }\n  get pendingKeys() {\n    return Array.from(this.pendingKeysSet);\n  }\n}\nfunction isTrackedPromise(value) {\n  return value instanceof Promise && value._tracked === true;\n}\nfunction unwrapTrackedPromise(value) {\n  if (!isTrackedPromise(value)) {\n    return value;\n  }\n  if (value._error) {\n    throw value._error;\n  }\n  return value._data;\n}\nconst defer = function defer(data, init) {\n  if (init === void 0) {\n    init = {};\n  }\n  let responseInit = typeof init === \"number\" ? {\n    status: init\n  } : init;\n  return new DeferredData(data, responseInit);\n};\n/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirect = function redirect(url, init) {\n  if (init === void 0) {\n    init = 302;\n  }\n  let responseInit = init;\n  if (typeof responseInit === \"number\") {\n    responseInit = {\n      status: responseInit\n    };\n  } else if (typeof responseInit.status === \"undefined\") {\n    responseInit.status = 302;\n  }\n  let headers = new Headers(responseInit.headers);\n  headers.set(\"Location\", url);\n  return new Response(null, _extends({}, responseInit, {\n    headers\n  }));\n};\n/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */\nconst redirectDocument = (url, init) => {\n  let response = redirect(url, init);\n  response.headers.set(\"X-Remix-Reload-Document\", \"true\");\n  return response;\n};\n/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n *\n * We don't export the class for public use since it's an implementation\n * detail, but we export the interface above so folks can build their own\n * abstractions around instances via isRouteErrorResponse()\n */\nclass ErrorResponseImpl {\n  constructor(status, statusText, data, internal) {\n    if (internal === void 0) {\n      internal = false;\n    }\n    this.status = status;\n    this.statusText = statusText || \"\";\n    this.internal = internal;\n    if (data instanceof Error) {\n      this.data = data.toString();\n      this.error = data;\n    } else {\n      this.data = data;\n    }\n  }\n}\n/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */\nfunction isRouteErrorResponse(error) {\n  return error != null && typeof error.status === \"number\" && typeof error.statusText === \"string\" && typeof error.internal === \"boolean\" && \"data\" in error;\n}\n\nconst validMutationMethodsArr = [\"post\", \"put\", \"patch\", \"delete\"];\nconst validMutationMethods = new Set(validMutationMethodsArr);\nconst validRequestMethodsArr = [\"get\", ...validMutationMethodsArr];\nconst validRequestMethods = new Set(validRequestMethodsArr);\nconst redirectStatusCodes = new Set([301, 302, 303, 307, 308]);\nconst redirectPreserveMethodStatusCodes = new Set([307, 308]);\nconst IDLE_NAVIGATION = {\n  state: \"idle\",\n  location: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_FETCHER = {\n  state: \"idle\",\n  data: undefined,\n  formMethod: undefined,\n  formAction: undefined,\n  formEncType: undefined,\n  formData: undefined,\n  json: undefined,\n  text: undefined\n};\nconst IDLE_BLOCKER = {\n  state: \"unblocked\",\n  proceed: undefined,\n  reset: undefined,\n  location: undefined\n};\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\nconst defaultMapRouteProperties = route => ({\n  hasErrorBoundary: Boolean(route.hasErrorBoundary)\n});\nconst TRANSITIONS_STORAGE_KEY = \"remix-router-transitions\";\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */\nfunction createRouter(init) {\n  const routerWindow = init.window ? init.window : typeof window !== \"undefined\" ? window : undefined;\n  const isBrowser = typeof routerWindow !== \"undefined\" && typeof routerWindow.document !== \"undefined\" && typeof routerWindow.document.createElement !== \"undefined\";\n  const isServer = !isBrowser;\n  invariant(init.routes.length > 0, \"You must provide a non-empty routes array to createRouter\");\n  let mapRouteProperties;\n  if (init.mapRouteProperties) {\n    mapRouteProperties = init.mapRouteProperties;\n  } else if (init.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = init.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  // Routes keyed by ID\n  let manifest = {};\n  // Routes in tree format for matching\n  let dataRoutes = convertRoutesToDataRoutes(init.routes, mapRouteProperties, undefined, manifest);\n  let inFlightDataRoutes;\n  let basename = init.basename || \"/\";\n  // Config driven behavior flags\n  let future = _extends({\n    v7_fetcherPersist: false,\n    v7_normalizeFormMethod: false,\n    v7_prependBasename: false\n  }, init.future);\n  // Cleanup function for history\n  let unlistenHistory = null;\n  // Externally-provided functions to call on all state changes\n  let subscribers = new Set();\n  // Externally-provided object to hold scroll restoration locations during routing\n  let savedScrollPositions = null;\n  // Externally-provided function to get scroll restoration keys\n  let getScrollRestorationKey = null;\n  // Externally-provided function to get current scroll position\n  let getScrollPosition = null;\n  // One-time flag to control the initial hydration scroll restoration.  Because\n  // we don't get the saved positions from <ScrollRestoration /> until _after_\n  // the initial render, we need to manually trigger a separate updateState to\n  // send along the restoreScrollPosition\n  // Set to true if we have `hydrationData` since we assume we were SSR'd and that\n  // SSR did the initial scroll restoration.\n  let initialScrollRestored = init.hydrationData != null;\n  let initialMatches = matchRoutes(dataRoutes, init.history.location, basename);\n  let initialErrors = null;\n  if (initialMatches == null) {\n    // If we do not match a user-provided-route, fall back to the root\n    // to allow the error boundary to take over\n    let error = getInternalRouterError(404, {\n      pathname: init.history.location.pathname\n    });\n    let {\n      matches,\n      route\n    } = getShortCircuitMatches(dataRoutes);\n    initialMatches = matches;\n    initialErrors = {\n      [route.id]: error\n    };\n  }\n  let initialized =\n  // All initialMatches need to be loaded before we're ready.  If we have lazy\n  // functions around still then we'll need to run them in initialize()\n  !initialMatches.some(m => m.route.lazy) && (\n  // And we have to either have no loaders or have been provided hydrationData\n  !initialMatches.some(m => m.route.loader) || init.hydrationData != null);\n  let router;\n  let state = {\n    historyAction: init.history.action,\n    location: init.history.location,\n    matches: initialMatches,\n    initialized,\n    navigation: IDLE_NAVIGATION,\n    // Don't restore on initial updateState() if we were SSR'd\n    restoreScrollPosition: init.hydrationData != null ? false : null,\n    preventScrollReset: false,\n    revalidation: \"idle\",\n    loaderData: init.hydrationData && init.hydrationData.loaderData || {},\n    actionData: init.hydrationData && init.hydrationData.actionData || null,\n    errors: init.hydrationData && init.hydrationData.errors || initialErrors,\n    fetchers: new Map(),\n    blockers: new Map()\n  };\n  // -- Stateful internal variables to manage navigations --\n  // Current navigation in progress (to be committed in completeNavigation)\n  let pendingAction = Action.Pop;\n  // Should the current navigation prevent the scroll reset if scroll cannot\n  // be restored?\n  let pendingPreventScrollReset = false;\n  // AbortController for the active navigation\n  let pendingNavigationController;\n  // Should the current navigation enable document.startViewTransition?\n  let pendingViewTransitionEnabled = false;\n  // Store applied view transitions so we can apply them on POP\n  let appliedViewTransitions = new Map();\n  // Cleanup function for persisting applied transitions to sessionStorage\n  let removePageHideEventListener = null;\n  // We use this to avoid touching history in completeNavigation if a\n  // revalidation is entirely uninterrupted\n  let isUninterruptedRevalidation = false;\n  // Use this internal flag to force revalidation of all loaders:\n  //  - submissions (completed or interrupted)\n  //  - useRevalidator()\n  //  - X-Remix-Revalidate (from redirect)\n  let isRevalidationRequired = false;\n  // Use this internal array to capture routes that require revalidation due\n  // to a cancelled deferred on action submission\n  let cancelledDeferredRoutes = [];\n  // Use this internal array to capture fetcher loads that were cancelled by an\n  // action navigation and require revalidation\n  let cancelledFetcherLoads = [];\n  // AbortControllers for any in-flight fetchers\n  let fetchControllers = new Map();\n  // Track loads based on the order in which they started\n  let incrementingLoadId = 0;\n  // Track the outstanding pending navigation data load to be compared against\n  // the globally incrementing load when a fetcher load lands after a completed\n  // navigation\n  let pendingNavigationLoadId = -1;\n  // Fetchers that triggered data reloads as a result of their actions\n  let fetchReloadIds = new Map();\n  // Fetchers that triggered redirect navigations\n  let fetchRedirectIds = new Set();\n  // Most recent href/match for fetcher.load calls for fetchers\n  let fetchLoadMatches = new Map();\n  // Ref-count mounted fetchers so we know when it's ok to clean them up\n  let activeFetchers = new Map();\n  // Fetchers that have requested a delete when using v7_fetcherPersist,\n  // they'll be officially removed after they return to idle\n  let deletedFetchers = new Set();\n  // Store DeferredData instances for active route matches.  When a\n  // route loader returns defer() we stick one in here.  Then, when a nested\n  // promise resolves we update loaderData.  If a new navigation starts we\n  // cancel active deferreds for eliminated routes.\n  let activeDeferreds = new Map();\n  // Store blocker functions in a separate Map outside of router state since\n  // we don't need to update UI state if they change\n  let blockerFunctions = new Map();\n  // Flag to ignore the next history update, so we can revert the URL change on\n  // a POP navigation that was blocked by the user without touching router state\n  let ignoreNextHistoryUpdate = false;\n  // Initialize the router, all side effects should be kicked off from here.\n  // Implemented as a Fluent API for ease of:\n  //   let router = createRouter(init).initialize();\n  function initialize() {\n    // If history informs us of a POP navigation, start the navigation but do not update\n    // state.  We'll update our own state once the navigation completes\n    unlistenHistory = init.history.listen(_ref => {\n      let {\n        action: historyAction,\n        location,\n        delta\n      } = _ref;\n      // Ignore this event if it was just us resetting the URL from a\n      // blocked POP navigation\n      if (ignoreNextHistoryUpdate) {\n        ignoreNextHistoryUpdate = false;\n        return;\n      }\n      warning(blockerFunctions.size === 0 || delta != null, \"You are trying to use a blocker on a POP navigation to a location \" + \"that was not created by @remix-run/router. This will fail silently in \" + \"production. This can happen if you are navigating outside the router \" + \"via `window.history.pushState`/`window.location.hash` instead of using \" + \"router navigation APIs.  This can also happen if you are using \" + \"createHashRouter and the user manually changes the URL.\");\n      let blockerKey = shouldBlockNavigation({\n        currentLocation: state.location,\n        nextLocation: location,\n        historyAction\n      });\n      if (blockerKey && delta != null) {\n        // Restore the URL to match the current UI, but don't update router state\n        ignoreNextHistoryUpdate = true;\n        init.history.go(delta * -1);\n        // Put the blocker into a blocked state\n        updateBlocker(blockerKey, {\n          state: \"blocked\",\n          location,\n          proceed() {\n            updateBlocker(blockerKey, {\n              state: \"proceeding\",\n              proceed: undefined,\n              reset: undefined,\n              location\n            });\n            // Re-do the same POP navigation we just blocked\n            init.history.go(delta);\n          },\n          reset() {\n            let blockers = new Map(state.blockers);\n            blockers.set(blockerKey, IDLE_BLOCKER);\n            updateState({\n              blockers\n            });\n          }\n        });\n        return;\n      }\n      return startNavigation(historyAction, location);\n    });\n    if (isBrowser) {\n      // FIXME: This feels gross.  How can we cleanup the lines between\n      // scrollRestoration/appliedTransitions persistance?\n      restoreAppliedTransitions(routerWindow, appliedViewTransitions);\n      let _saveAppliedTransitions = () => persistAppliedTransitions(routerWindow, appliedViewTransitions);\n      routerWindow.addEventListener(\"pagehide\", _saveAppliedTransitions);\n      removePageHideEventListener = () => routerWindow.removeEventListener(\"pagehide\", _saveAppliedTransitions);\n    }\n    // Kick off initial data load if needed.  Use Pop to avoid modifying history\n    // Note we don't do any handling of lazy here.  For SPA's it'll get handled\n    // in the normal navigation flow.  For SSR it's expected that lazy modules are\n    // resolved prior to router creation since we can't go into a fallbackElement\n    // UI for SSR'd apps\n    if (!state.initialized) {\n      startNavigation(Action.Pop, state.location);\n    }\n    return router;\n  }\n  // Clean up a router and it's side effects\n  function dispose() {\n    if (unlistenHistory) {\n      unlistenHistory();\n    }\n    if (removePageHideEventListener) {\n      removePageHideEventListener();\n    }\n    subscribers.clear();\n    pendingNavigationController && pendingNavigationController.abort();\n    state.fetchers.forEach((_, key) => deleteFetcher(key));\n    state.blockers.forEach((_, key) => deleteBlocker(key));\n  }\n  // Subscribe to state updates for the router\n  function subscribe(fn) {\n    subscribers.add(fn);\n    return () => subscribers.delete(fn);\n  }\n  // Update our state and notify the calling context of the change\n  function updateState(newState, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state = _extends({}, state, newState);\n    // Prep fetcher cleanup so we can tell the UI which fetcher data entries\n    // can be removed\n    let completedFetchers = [];\n    let deletedFetchersKeys = [];\n    if (future.v7_fetcherPersist) {\n      state.fetchers.forEach((fetcher, key) => {\n        if (fetcher.state === \"idle\") {\n          if (deletedFetchers.has(key)) {\n            // Unmounted from the UI and can be totally removed\n            deletedFetchersKeys.push(key);\n          } else {\n            // Returned to idle but still mounted in the UI, so semi-remains for\n            // revalidations and such\n            completedFetchers.push(key);\n          }\n        }\n      });\n    }\n    // Iterate over a local copy so that if flushSync is used and we end up\n    // removing and adding a new subscriber due to the useCallback dependencies,\n    // we don't get ourselves into a loop calling the new subscriber immediately\n    [...subscribers].forEach(subscriber => subscriber(state, {\n      deletedFetchers: deletedFetchersKeys,\n      unstable_viewTransitionOpts: opts.viewTransitionOpts,\n      unstable_flushSync: opts.flushSync === true\n    }));\n    // Remove idle fetchers from state since we only care about in-flight fetchers.\n    if (future.v7_fetcherPersist) {\n      completedFetchers.forEach(key => state.fetchers.delete(key));\n      deletedFetchersKeys.forEach(key => deleteFetcher(key));\n    }\n  }\n  // Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n  // and setting state.[historyAction/location/matches] to the new route.\n  // - Location is a required param\n  // - Navigation will always be set to IDLE_NAVIGATION\n  // - Can pass any other state in newState\n  function completeNavigation(location, newState, _temp) {\n    var _location$state, _location$state2;\n    let {\n      flushSync\n    } = _temp === void 0 ? {} : _temp;\n    // Deduce if we're in a loading/actionReload state:\n    // - We have committed actionData in the store\n    // - The current navigation was a mutation submission\n    // - We're past the submitting state and into the loading state\n    // - The location being loaded is not the result of a redirect\n    let isActionReload = state.actionData != null && state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && state.navigation.state === \"loading\" && ((_location$state = location.state) == null ? void 0 : _location$state._isRedirect) !== true;\n    let actionData;\n    if (newState.actionData) {\n      if (Object.keys(newState.actionData).length > 0) {\n        actionData = newState.actionData;\n      } else {\n        // Empty actionData -> clear prior actionData due to an action error\n        actionData = null;\n      }\n    } else if (isActionReload) {\n      // Keep the current data if we're wrapping up the action reload\n      actionData = state.actionData;\n    } else {\n      // Clear actionData on any other completed navigations\n      actionData = null;\n    }\n    // Always preserve any existing loaderData from re-used routes\n    let loaderData = newState.loaderData ? mergeLoaderData(state.loaderData, newState.loaderData, newState.matches || [], newState.errors) : state.loaderData;\n    // On a successful navigation we can assume we got through all blockers\n    // so we can start fresh\n    let blockers = state.blockers;\n    if (blockers.size > 0) {\n      blockers = new Map(blockers);\n      blockers.forEach((_, k) => blockers.set(k, IDLE_BLOCKER));\n    }\n    // Always respect the user flag.  Otherwise don't reset on mutation\n    // submission navigations unless they redirect\n    let preventScrollReset = pendingPreventScrollReset === true || state.navigation.formMethod != null && isMutationMethod(state.navigation.formMethod) && ((_location$state2 = location.state) == null ? void 0 : _location$state2._isRedirect) !== true;\n    if (inFlightDataRoutes) {\n      dataRoutes = inFlightDataRoutes;\n      inFlightDataRoutes = undefined;\n    }\n    if (isUninterruptedRevalidation) ; else if (pendingAction === Action.Pop) ; else if (pendingAction === Action.Push) {\n      init.history.push(location, location.state);\n    } else if (pendingAction === Action.Replace) {\n      init.history.replace(location, location.state);\n    }\n    let viewTransitionOpts;\n    // On POP, enable transitions if they were enabled on the original navigation\n    if (pendingAction === Action.Pop) {\n      // Forward takes precedence so they behave like the original navigation\n      let priorPaths = appliedViewTransitions.get(state.location.pathname);\n      if (priorPaths && priorPaths.has(location.pathname)) {\n        viewTransitionOpts = {\n          currentLocation: state.location,\n          nextLocation: location\n        };\n      } else if (appliedViewTransitions.has(location.pathname)) {\n        // If we don't have a previous forward nav, assume we're popping back to\n        // the new location and enable if that location previously enabled\n        viewTransitionOpts = {\n          currentLocation: location,\n          nextLocation: state.location\n        };\n      }\n    } else if (pendingViewTransitionEnabled) {\n      // Store the applied transition on PUSH/REPLACE\n      let toPaths = appliedViewTransitions.get(state.location.pathname);\n      if (toPaths) {\n        toPaths.add(location.pathname);\n      } else {\n        toPaths = new Set([location.pathname]);\n        appliedViewTransitions.set(state.location.pathname, toPaths);\n      }\n      viewTransitionOpts = {\n        currentLocation: state.location,\n        nextLocation: location\n      };\n    }\n    updateState(_extends({}, newState, {\n      actionData,\n      loaderData,\n      historyAction: pendingAction,\n      location,\n      initialized: true,\n      navigation: IDLE_NAVIGATION,\n      revalidation: \"idle\",\n      restoreScrollPosition: getSavedScrollPosition(location, newState.matches || state.matches),\n      preventScrollReset,\n      blockers\n    }), {\n      viewTransitionOpts,\n      flushSync: flushSync === true\n    });\n    // Reset stateful navigation vars\n    pendingAction = Action.Pop;\n    pendingPreventScrollReset = false;\n    pendingViewTransitionEnabled = false;\n    isUninterruptedRevalidation = false;\n    isRevalidationRequired = false;\n    cancelledDeferredRoutes = [];\n    cancelledFetcherLoads = [];\n  }\n  // Trigger a navigation event, which can either be a numerical POP or a PUSH\n  // replace with an optional submission\n  async function navigate(to, opts) {\n    if (typeof to === \"number\") {\n      init.history.go(to);\n      return;\n    }\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, to, opts == null ? void 0 : opts.fromRouteId, opts == null ? void 0 : opts.relative);\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, false, normalizedPath, opts);\n    let currentLocation = state.location;\n    let nextLocation = createLocation(state.location, path, opts && opts.state);\n    // When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n    // URL from window.location, so we need to encode it here so the behavior\n    // remains the same as POP and non-data-router usages.  new URL() does all\n    // the same encoding we'd get from a history.pushState/window.location read\n    // without having to touch history\n    nextLocation = _extends({}, nextLocation, init.history.encodeLocation(nextLocation));\n    let userReplace = opts && opts.replace != null ? opts.replace : undefined;\n    let historyAction = Action.Push;\n    if (userReplace === true) {\n      historyAction = Action.Replace;\n    } else if (userReplace === false) ; else if (submission != null && isMutationMethod(submission.formMethod) && submission.formAction === state.location.pathname + state.location.search) {\n      // By default on submissions to the current location we REPLACE so that\n      // users don't have to double-click the back button to get to the prior\n      // location.  If the user redirects to a different location from the\n      // action/loader this will be ignored and the redirect will be a PUSH\n      historyAction = Action.Replace;\n    }\n    let preventScrollReset = opts && \"preventScrollReset\" in opts ? opts.preventScrollReset === true : undefined;\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let blockerKey = shouldBlockNavigation({\n      currentLocation,\n      nextLocation,\n      historyAction\n    });\n    if (blockerKey) {\n      // Put the blocker into a blocked state\n      updateBlocker(blockerKey, {\n        state: \"blocked\",\n        location: nextLocation,\n        proceed() {\n          updateBlocker(blockerKey, {\n            state: \"proceeding\",\n            proceed: undefined,\n            reset: undefined,\n            location: nextLocation\n          });\n          // Send the same navigation through\n          navigate(to, opts);\n        },\n        reset() {\n          let blockers = new Map(state.blockers);\n          blockers.set(blockerKey, IDLE_BLOCKER);\n          updateState({\n            blockers\n          });\n        }\n      });\n      return;\n    }\n    return await startNavigation(historyAction, nextLocation, {\n      submission,\n      // Send through the formData serialization error if we have one so we can\n      // render at the right error boundary after we match routes\n      pendingError: error,\n      preventScrollReset,\n      replace: opts && opts.replace,\n      enableViewTransition: opts && opts.unstable_viewTransition,\n      flushSync\n    });\n  }\n  // Revalidate all current loaders.  If a navigation is in progress or if this\n  // is interrupted by a navigation, allow this to \"succeed\" by calling all\n  // loaders during the next loader round\n  function revalidate() {\n    interruptActiveLoads();\n    updateState({\n      revalidation: \"loading\"\n    });\n    // If we're currently submitting an action, we don't need to start a new\n    // navigation, we'll just let the follow up loader execution call all loaders\n    if (state.navigation.state === \"submitting\") {\n      return;\n    }\n    // If we're currently in an idle state, start a new navigation for the current\n    // action/location and mark it as uninterrupted, which will skip the history\n    // update in completeNavigation\n    if (state.navigation.state === \"idle\") {\n      startNavigation(state.historyAction, state.location, {\n        startUninterruptedRevalidation: true\n      });\n      return;\n    }\n    // Otherwise, if we're currently in a loading state, just start a new\n    // navigation to the navigation.location but do not trigger an uninterrupted\n    // revalidation so that history correctly updates once the navigation completes\n    startNavigation(pendingAction || state.historyAction, state.navigation.location, {\n      overrideNavigation: state.navigation\n    });\n  }\n  // Start a navigation to the given action/location.  Can optionally provide a\n  // overrideNavigation which will override the normalLoad in the case of a redirect\n  // navigation\n  async function startNavigation(historyAction, location, opts) {\n    // Abort any in-progress navigations and start a new one. Unset any ongoing\n    // uninterrupted revalidations unless told otherwise, since we want this\n    // new navigation to update history normally\n    pendingNavigationController && pendingNavigationController.abort();\n    pendingNavigationController = null;\n    pendingAction = historyAction;\n    isUninterruptedRevalidation = (opts && opts.startUninterruptedRevalidation) === true;\n    // Save the current scroll position every time we start a new navigation,\n    // and track whether we should reset scroll on completion\n    saveScrollPosition(state.location, state.matches);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    pendingViewTransitionEnabled = (opts && opts.enableViewTransition) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let loadingNavigation = opts && opts.overrideNavigation;\n    let matches = matchRoutes(routesToUse, location, basename);\n    let flushSync = (opts && opts.flushSync) === true;\n    // Short circuit with a 404 on the root error boundary if we match nothing\n    if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(routesToUse);\n      // Cancel all pending deferred on 404s since we don't keep any routes\n      cancelActiveDeferreds();\n      completeNavigation(location, {\n        matches: notFoundMatches,\n        loaderData: {},\n        errors: {\n          [route.id]: error\n        }\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Short circuit if it's only a hash change and not a revalidation or\n    // mutation submission.\n    //\n    // Ignore on initial page loads because since the initial load will always\n    // be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n    // which will default to a navigation to /page\n    if (state.initialized && !isRevalidationRequired && isHashChangeOnly(state.location, location) && !(opts && opts.submission && isMutationMethod(opts.submission.formMethod))) {\n      completeNavigation(location, {\n        matches\n      }, {\n        flushSync\n      });\n      return;\n    }\n    // Create a controller/Request for this navigation\n    pendingNavigationController = new AbortController();\n    let request = createClientSideRequest(init.history, location, pendingNavigationController.signal, opts && opts.submission);\n    let pendingActionData;\n    let pendingError;\n    if (opts && opts.pendingError) {\n      // If we have a pendingError, it means the user attempted a GET submission\n      // with binary FormData so assign here and skip to handleLoaders.  That\n      // way we handle calling loaders above the boundary etc.  It's not really\n      // different from an actionError in that sense.\n      pendingError = {\n        [findNearestBoundary(matches).route.id]: opts.pendingError\n      };\n    } else if (opts && opts.submission && isMutationMethod(opts.submission.formMethod)) {\n      // Call action if we received an action submission\n      let actionOutput = await handleAction(request, location, opts.submission, matches, {\n        replace: opts.replace,\n        flushSync\n      });\n      if (actionOutput.shortCircuited) {\n        return;\n      }\n      pendingActionData = actionOutput.pendingActionData;\n      pendingError = actionOutput.pendingActionError;\n      loadingNavigation = getLoadingNavigation(location, opts.submission);\n      flushSync = false;\n      // Create a GET request for the loaders\n      request = new Request(request.url, {\n        signal: request.signal\n      });\n    }\n    // Call loaders\n    let {\n      shortCircuited,\n      loaderData,\n      errors\n    } = await handleLoaders(request, location, matches, loadingNavigation, opts && opts.submission, opts && opts.fetcherSubmission, opts && opts.replace, flushSync, pendingActionData, pendingError);\n    if (shortCircuited) {\n      return;\n    }\n    // Clean up now that the action/loaders have completed.  Don't clean up if\n    // we short circuited because pendingNavigationController will have already\n    // been assigned to a new controller for the next navigation\n    pendingNavigationController = null;\n    completeNavigation(location, _extends({\n      matches\n    }, pendingActionData ? {\n      actionData: pendingActionData\n    } : {}, {\n      loaderData,\n      errors\n    }));\n  }\n  // Call the action matched by the leaf route for this navigation and handle\n  // redirects/errors\n  async function handleAction(request, location, submission, matches, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    interruptActiveLoads();\n    // Put us in a submitting state\n    let navigation = getSubmittingNavigation(location, submission);\n    updateState({\n      navigation\n    }, {\n      flushSync: opts.flushSync === true\n    });\n    // Call our action and get the result\n    let result;\n    let actionMatch = getTargetMatch(matches, location);\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      result = {\n        type: ResultType.error,\n        error: getInternalRouterError(405, {\n          method: request.method,\n          pathname: location.pathname,\n          routeId: actionMatch.route.id\n        })\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename);\n      if (request.signal.aborted) {\n        return {\n          shortCircuited: true\n        };\n      }\n    }\n    if (isRedirectResult(result)) {\n      let replace;\n      if (opts && opts.replace != null) {\n        replace = opts.replace;\n      } else {\n        // If the user didn't explicity indicate replace behavior, replace if\n        // we redirected to the exact same location we're currently at to avoid\n        // double back-buttons\n        replace = result.location === state.location.pathname + state.location.search;\n      }\n      await startRedirectNavigation(state, result, {\n        submission,\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      // By default, all submissions are REPLACE navigations, but if the\n      // action threw an error that'll be rendered in an errorElement, we fall\n      // back to PUSH so that the user can use the back button to get back to\n      // the pre-submission form location to try again\n      if ((opts && opts.replace) !== true) {\n        pendingAction = Action.Push;\n      }\n      return {\n        // Send back an empty object we can use to clear out any prior actionData\n        pendingActionData: {},\n        pendingActionError: {\n          [boundaryMatch.route.id]: result.error\n        }\n      };\n    }\n    if (isDeferredResult(result)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    return {\n      pendingActionData: {\n        [actionMatch.route.id]: result.data\n      }\n    };\n  }\n  // Call all applicable loaders for the given matches, handling redirects,\n  // errors, etc.\n  async function handleLoaders(request, location, matches, overrideNavigation, submission, fetcherSubmission, replace, flushSync, pendingActionData, pendingError) {\n    // Figure out the right navigation we want to use for data loading\n    let loadingNavigation = overrideNavigation || getLoadingNavigation(location, submission);\n    // If this was a redirect from an action we don't have a \"submission\" but\n    // we have it on the loading navigation so use that if available\n    let activeSubmission = submission || fetcherSubmission || getSubmissionFromNavigation(loadingNavigation);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, activeSubmission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError);\n    // Cancel pending deferreds for no-longer-matched routes or routes we're\n    // about to reload.  Note that if this is an action reload we would have\n    // already cancelled all pending deferreds so this would be a no-op\n    cancelActiveDeferreds(routeId => !(matches && matches.some(m => m.route.id === routeId)) || matchesToLoad && matchesToLoad.some(m => m.route.id === routeId));\n    pendingNavigationLoadId = ++incrementingLoadId;\n    // Short circuit if we have no loaders to run\n    if (matchesToLoad.length === 0 && revalidatingFetchers.length === 0) {\n      let updatedFetchers = markFetchRedirectsDone();\n      completeNavigation(location, _extends({\n        matches,\n        loaderData: {},\n        // Commit pending error if we're short circuiting\n        errors: pendingError || null\n      }, pendingActionData ? {\n        actionData: pendingActionData\n      } : {}, updatedFetchers ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // If this is an uninterrupted revalidation, we remain in our current idle\n    // state.  If not, we need to switch to our loading state and load data,\n    // preserving any new action data or existing action data (in the case of\n    // a revalidation interrupting an actionReload)\n    if (!isUninterruptedRevalidation) {\n      revalidatingFetchers.forEach(rf => {\n        let fetcher = state.fetchers.get(rf.key);\n        let revalidatingFetcher = getLoadingFetcher(undefined, fetcher ? fetcher.data : undefined);\n        state.fetchers.set(rf.key, revalidatingFetcher);\n      });\n      let actionData = pendingActionData || state.actionData;\n      updateState(_extends({\n        navigation: loadingNavigation\n      }, actionData ? Object.keys(actionData).length === 0 ? {\n        actionData: null\n      } : {\n        actionData\n      } : {}, revalidatingFetchers.length > 0 ? {\n        fetchers: new Map(state.fetchers)\n      } : {}), {\n        flushSync\n      });\n    }\n    revalidatingFetchers.forEach(rf => {\n      if (fetchControllers.has(rf.key)) {\n        abortFetcher(rf.key);\n      }\n      if (rf.controller) {\n        // Fetchers use an independent AbortController so that aborting a fetcher\n        // (via deleteFetcher) does not abort the triggering navigation that\n        // triggered the revalidation\n        fetchControllers.set(rf.key, rf.controller);\n      }\n    });\n    // Proxy navigation abort through to revalidation fetchers\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(f => abortFetcher(f.key));\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, request);\n    if (request.signal.aborted) {\n      return {\n        shortCircuited: true\n      };\n    }\n    // Clean up _after_ loaders have completed.  Don't clean up if we short\n    // circuited because fetchControllers would have been aborted and\n    // reassigned to new controllers for the next navigation\n    if (pendingNavigationController) {\n      pendingNavigationController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    }\n    revalidatingFetchers.forEach(rf => fetchControllers.delete(rf.key));\n    // If any loaders returned a redirect Response, start a new REPLACE navigation\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      await startRedirectNavigation(state, redirect.result, {\n        replace\n      });\n      return {\n        shortCircuited: true\n      };\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, matches, matchesToLoad, loaderResults, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Wire up subscribers to update loaderData as promises settle\n    activeDeferreds.forEach((deferredData, routeId) => {\n      deferredData.subscribe(aborted => {\n        // Note: No need to updateState here since the TrackedPromise on\n        // loaderData is stable across resolve/reject\n        // Remove this instance if we were aborted or if promises have settled\n        if (aborted || deferredData.done) {\n          activeDeferreds.delete(routeId);\n        }\n      });\n    });\n    let updatedFetchers = markFetchRedirectsDone();\n    let didAbortFetchLoads = abortStaleFetchLoads(pendingNavigationLoadId);\n    let shouldUpdateFetchers = updatedFetchers || didAbortFetchLoads || revalidatingFetchers.length > 0;\n    return _extends({\n      loaderData,\n      errors\n    }, shouldUpdateFetchers ? {\n      fetchers: new Map(state.fetchers)\n    } : {});\n  }\n  // Trigger a fetcher load/submit for the given fetcher key\n  function fetch(key, routeId, href, opts) {\n    if (isServer) {\n      throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \" + \"You are likely calling a useFetcher() method in the body of your component. \" + \"Try moving it to a useEffect or a callback.\");\n    }\n    if (fetchControllers.has(key)) abortFetcher(key);\n    let flushSync = (opts && opts.unstable_flushSync) === true;\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let normalizedPath = normalizeTo(state.location, state.matches, basename, future.v7_prependBasename, href, routeId, opts == null ? void 0 : opts.relative);\n    let matches = matchRoutes(routesToUse, normalizedPath, basename);\n    if (!matches) {\n      setFetcherError(key, routeId, getInternalRouterError(404, {\n        pathname: normalizedPath\n      }), {\n        flushSync\n      });\n      return;\n    }\n    let {\n      path,\n      submission,\n      error\n    } = normalizeNavigateOptions(future.v7_normalizeFormMethod, true, normalizedPath, opts);\n    if (error) {\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    let match = getTargetMatch(matches, path);\n    pendingPreventScrollReset = (opts && opts.preventScrollReset) === true;\n    if (submission && isMutationMethod(submission.formMethod)) {\n      handleFetcherAction(key, routeId, path, match, matches, flushSync, submission);\n      return;\n    }\n    // Store off the match so we can call it's shouldRevalidate on subsequent\n    // revalidations\n    fetchLoadMatches.set(key, {\n      routeId,\n      path\n    });\n    handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission);\n  }\n  // Call the action for the matched fetcher.submit(), and then handle redirects,\n  // errors, and revalidation\n  async function handleFetcherAction(key, routeId, path, match, requestMatches, flushSync, submission) {\n    interruptActiveLoads();\n    fetchLoadMatches.delete(key);\n    if (!match.route.action && !match.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: submission.formMethod,\n        pathname: path,\n        routeId: routeId\n      });\n      setFetcherError(key, routeId, error, {\n        flushSync\n      });\n      return;\n    }\n    // Put this fetcher into it's submitting state\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getSubmittingFetcher(submission, existingFetcher), {\n      flushSync\n    });\n    // Call the action for the fetcher\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal, submission);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let actionResult = await callLoaderOrAction(\"action\", fetchRequest, match, requestMatches, manifest, mapRouteProperties, basename);\n    if (fetchRequest.signal.aborted) {\n      // We can delete this so long as we weren't aborted by our own fetcher\n      // re-submit which would have put _new_ controller is in fetchControllers\n      if (fetchControllers.get(key) === abortController) {\n        fetchControllers.delete(key);\n      }\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    if (isRedirectResult(actionResult)) {\n      fetchControllers.delete(key);\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our action started, so that\n        // should take precedence over this redirect navigation.  We already\n        // set isRevalidationRequired so all loaders for the new route should\n        // fire unless opted out via shouldRevalidate\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        updateFetcherState(key, getLoadingFetcher(submission));\n        return startRedirectNavigation(state, actionResult, {\n          fetcherSubmission: submission\n        });\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(actionResult)) {\n      setFetcherError(key, routeId, actionResult.error);\n      return;\n    }\n    if (isDeferredResult(actionResult)) {\n      throw getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n    }\n    // Start the data load for current matches, or the next location if we're\n    // in the middle of a navigation\n    let nextLocation = state.navigation.location || state.location;\n    let revalidationRequest = createClientSideRequest(init.history, nextLocation, abortController.signal);\n    let routesToUse = inFlightDataRoutes || dataRoutes;\n    let matches = state.navigation.state !== \"idle\" ? matchRoutes(routesToUse, state.navigation.location, basename) : state.matches;\n    invariant(matches, \"Didn't find any matches after fetcher action\");\n    let loadId = ++incrementingLoadId;\n    fetchReloadIds.set(key, loadId);\n    let loadFetcher = getLoadingFetcher(submission, actionResult.data);\n    state.fetchers.set(key, loadFetcher);\n    let [matchesToLoad, revalidatingFetchers] = getMatchesToLoad(init.history, state, matches, submission, nextLocation, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, {\n      [match.route.id]: actionResult.data\n    }, undefined // No need to send through errors since we short circuit above\n    );\n    // Put all revalidating fetchers into the loading state, except for the\n    // current fetcher which we want to keep in it's current loading state which\n    // contains it's action submission info + action data\n    revalidatingFetchers.filter(rf => rf.key !== key).forEach(rf => {\n      let staleKey = rf.key;\n      let existingFetcher = state.fetchers.get(staleKey);\n      let revalidatingFetcher = getLoadingFetcher(undefined, existingFetcher ? existingFetcher.data : undefined);\n      state.fetchers.set(staleKey, revalidatingFetcher);\n      if (fetchControllers.has(staleKey)) {\n        abortFetcher(staleKey);\n      }\n      if (rf.controller) {\n        fetchControllers.set(staleKey, rf.controller);\n      }\n    });\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n    let abortPendingFetchRevalidations = () => revalidatingFetchers.forEach(rf => abortFetcher(rf.key));\n    abortController.signal.addEventListener(\"abort\", abortPendingFetchRevalidations);\n    let {\n      results,\n      loaderResults,\n      fetcherResults\n    } = await callLoadersAndMaybeResolveData(state.matches, matches, matchesToLoad, revalidatingFetchers, revalidationRequest);\n    if (abortController.signal.aborted) {\n      return;\n    }\n    abortController.signal.removeEventListener(\"abort\", abortPendingFetchRevalidations);\n    fetchReloadIds.delete(key);\n    fetchControllers.delete(key);\n    revalidatingFetchers.forEach(r => fetchControllers.delete(r.key));\n    let redirect = findRedirect(results);\n    if (redirect) {\n      if (redirect.idx >= matchesToLoad.length) {\n        // If this redirect came from a fetcher make sure we mark it in\n        // fetchRedirectIds so it doesn't get revalidated on the next set of\n        // loader executions\n        let fetcherKey = revalidatingFetchers[redirect.idx - matchesToLoad.length].key;\n        fetchRedirectIds.add(fetcherKey);\n      }\n      return startRedirectNavigation(state, redirect.result);\n    }\n    // Process and commit output from loaders\n    let {\n      loaderData,\n      errors\n    } = processLoaderData(state, state.matches, matchesToLoad, loaderResults, undefined, revalidatingFetchers, fetcherResults, activeDeferreds);\n    // Since we let revalidations complete even if the submitting fetcher was\n    // deleted, only put it back to idle if it hasn't been deleted\n    if (state.fetchers.has(key)) {\n      let doneFetcher = getDoneFetcher(actionResult.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n    abortStaleFetchLoads(loadId);\n    // If we are currently in a navigation loading state and this fetcher is\n    // more recent than the navigation, we want the newer data so abort the\n    // navigation and complete it with the fetcher data\n    if (state.navigation.state === \"loading\" && loadId > pendingNavigationLoadId) {\n      invariant(pendingAction, \"Expected pending action\");\n      pendingNavigationController && pendingNavigationController.abort();\n      completeNavigation(state.navigation.location, {\n        matches,\n        loaderData,\n        errors,\n        fetchers: new Map(state.fetchers)\n      });\n    } else {\n      // otherwise just update with the fetcher data, preserving any existing\n      // loaderData for loaders that did not need to reload.  We have to\n      // manually merge here since we aren't going through completeNavigation\n      updateState({\n        errors,\n        loaderData: mergeLoaderData(state.loaderData, loaderData, matches, errors),\n        fetchers: new Map(state.fetchers)\n      });\n      isRevalidationRequired = false;\n    }\n  }\n  // Call the matched loader for fetcher.load(), handling redirects, errors, etc.\n  async function handleFetcherLoader(key, routeId, path, match, matches, flushSync, submission) {\n    let existingFetcher = state.fetchers.get(key);\n    updateFetcherState(key, getLoadingFetcher(submission, existingFetcher ? existingFetcher.data : undefined), {\n      flushSync\n    });\n    // Call the loader for this fetcher route match\n    let abortController = new AbortController();\n    let fetchRequest = createClientSideRequest(init.history, path, abortController.signal);\n    fetchControllers.set(key, abortController);\n    let originatingLoadId = incrementingLoadId;\n    let result = await callLoaderOrAction(\"loader\", fetchRequest, match, matches, manifest, mapRouteProperties, basename);\n    // Deferred isn't supported for fetcher loads, await everything and treat it\n    // as a normal load.  resolveDeferredData will return undefined if this\n    // fetcher gets aborted, so we just leave result untouched and short circuit\n    // below if that happens\n    if (isDeferredResult(result)) {\n      result = (await resolveDeferredData(result, fetchRequest.signal, true)) || result;\n    }\n    // We can delete this so long as we weren't aborted by our our own fetcher\n    // re-load which would have put _new_ controller is in fetchControllers\n    if (fetchControllers.get(key) === abortController) {\n      fetchControllers.delete(key);\n    }\n    if (fetchRequest.signal.aborted) {\n      return;\n    }\n    if (deletedFetchers.has(key)) {\n      updateFetcherState(key, getDoneFetcher(undefined));\n      return;\n    }\n    // If the loader threw a redirect Response, start a new REPLACE navigation\n    if (isRedirectResult(result)) {\n      if (pendingNavigationLoadId > originatingLoadId) {\n        // A new navigation was kicked off after our loader started, so that\n        // should take precedence over this redirect navigation\n        updateFetcherState(key, getDoneFetcher(undefined));\n        return;\n      } else {\n        fetchRedirectIds.add(key);\n        await startRedirectNavigation(state, result);\n        return;\n      }\n    }\n    // Process any non-redirect errors thrown\n    if (isErrorResult(result)) {\n      setFetcherError(key, routeId, result.error);\n      return;\n    }\n    invariant(!isDeferredResult(result), \"Unhandled fetcher deferred data\");\n    // Put the fetcher back into an idle state\n    updateFetcherState(key, getDoneFetcher(result.data));\n  }\n  /**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */\n  async function startRedirectNavigation(state, redirect, _temp2) {\n    let {\n      submission,\n      fetcherSubmission,\n      replace\n    } = _temp2 === void 0 ? {} : _temp2;\n    if (redirect.revalidate) {\n      isRevalidationRequired = true;\n    }\n    let redirectLocation = createLocation(state.location, redirect.location, {\n      _isRedirect: true\n    });\n    invariant(redirectLocation, \"Expected a location on the redirect navigation\");\n    if (isBrowser) {\n      let isDocumentReload = false;\n      if (redirect.reloadDocument) {\n        // Hard reload if the response contained X-Remix-Reload-Document\n        isDocumentReload = true;\n      } else if (ABSOLUTE_URL_REGEX.test(redirect.location)) {\n        const url = init.history.createURL(redirect.location);\n        isDocumentReload =\n        // Hard reload if it's an absolute URL to a new origin\n        url.origin !== routerWindow.location.origin ||\n        // Hard reload if it's an absolute URL that does not match our basename\n        stripBasename(url.pathname, basename) == null;\n      }\n      if (isDocumentReload) {\n        if (replace) {\n          routerWindow.location.replace(redirect.location);\n        } else {\n          routerWindow.location.assign(redirect.location);\n        }\n        return;\n      }\n    }\n    // There's no need to abort on redirects, since we don't detect the\n    // redirect until the action/loaders have settled\n    pendingNavigationController = null;\n    let redirectHistoryAction = replace === true ? Action.Replace : Action.Push;\n    // Use the incoming submission if provided, fallback on the active one in\n    // state.navigation\n    let {\n      formMethod,\n      formAction,\n      formEncType\n    } = state.navigation;\n    if (!submission && !fetcherSubmission && formMethod && formAction && formEncType) {\n      submission = getSubmissionFromNavigation(state.navigation);\n    }\n    // If this was a 307/308 submission we want to preserve the HTTP method and\n    // re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n    // redirected location\n    let activeSubmission = submission || fetcherSubmission;\n    if (redirectPreserveMethodStatusCodes.has(redirect.status) && activeSubmission && isMutationMethod(activeSubmission.formMethod)) {\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        submission: _extends({}, activeSubmission, {\n          formAction: redirect.location\n        }),\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    } else {\n      // If we have a navigation submission, we will preserve it through the\n      // redirect navigation\n      let overrideNavigation = getLoadingNavigation(redirectLocation, submission);\n      await startNavigation(redirectHistoryAction, redirectLocation, {\n        overrideNavigation,\n        // Send fetcher submissions through for shouldRevalidate\n        fetcherSubmission,\n        // Preserve this flag across redirects\n        preventScrollReset: pendingPreventScrollReset\n      });\n    }\n  }\n  async function callLoadersAndMaybeResolveData(currentMatches, matches, matchesToLoad, fetchersToLoad, request) {\n    // Call all navigation loaders and revalidating fetcher loaders in parallel,\n    // then slice off the results into separate arrays so we can handle them\n    // accordingly\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename)), ...fetchersToLoad.map(f => {\n      if (f.matches && f.match && f.controller) {\n        return callLoaderOrAction(\"loader\", createClientSideRequest(init.history, f.path, f.controller.signal), f.match, f.matches, manifest, mapRouteProperties, basename);\n      } else {\n        let error = {\n          type: ResultType.error,\n          error: getInternalRouterError(404, {\n            pathname: f.path\n          })\n        };\n        return error;\n      }\n    })]);\n    let loaderResults = results.slice(0, matchesToLoad.length);\n    let fetcherResults = results.slice(matchesToLoad.length);\n    await Promise.all([resolveDeferredResults(currentMatches, matchesToLoad, loaderResults, loaderResults.map(() => request.signal), false, state.loaderData), resolveDeferredResults(currentMatches, fetchersToLoad.map(f => f.match), fetcherResults, fetchersToLoad.map(f => f.controller ? f.controller.signal : null), true)]);\n    return {\n      results,\n      loaderResults,\n      fetcherResults\n    };\n  }\n  function interruptActiveLoads() {\n    // Every interruption triggers a revalidation\n    isRevalidationRequired = true;\n    // Cancel pending route-level deferreds and mark cancelled routes for\n    // revalidation\n    cancelledDeferredRoutes.push(...cancelActiveDeferreds());\n    // Abort in-flight fetcher loads\n    fetchLoadMatches.forEach((_, key) => {\n      if (fetchControllers.has(key)) {\n        cancelledFetcherLoads.push(key);\n        abortFetcher(key);\n      }\n    });\n  }\n  function updateFetcherState(key, fetcher, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    state.fetchers.set(key, fetcher);\n    updateState({\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function setFetcherError(key, routeId, error, opts) {\n    if (opts === void 0) {\n      opts = {};\n    }\n    let boundaryMatch = findNearestBoundary(state.matches, routeId);\n    deleteFetcher(key);\n    updateState({\n      errors: {\n        [boundaryMatch.route.id]: error\n      },\n      fetchers: new Map(state.fetchers)\n    }, {\n      flushSync: (opts && opts.flushSync) === true\n    });\n  }\n  function getFetcher(key) {\n    if (future.v7_fetcherPersist) {\n      activeFetchers.set(key, (activeFetchers.get(key) || 0) + 1);\n      // If this fetcher was previously marked for deletion, unmark it since we\n      // have a new instance\n      if (deletedFetchers.has(key)) {\n        deletedFetchers.delete(key);\n      }\n    }\n    return state.fetchers.get(key) || IDLE_FETCHER;\n  }\n  function deleteFetcher(key) {\n    let fetcher = state.fetchers.get(key);\n    // Don't abort the controller if this is a deletion of a fetcher.submit()\n    // in it's loading phase since - we don't want to abort the corresponding\n    // revalidation and want them to complete and land\n    if (fetchControllers.has(key) && !(fetcher && fetcher.state === \"loading\" && fetchReloadIds.has(key))) {\n      abortFetcher(key);\n    }\n    fetchLoadMatches.delete(key);\n    fetchReloadIds.delete(key);\n    fetchRedirectIds.delete(key);\n    deletedFetchers.delete(key);\n    state.fetchers.delete(key);\n  }\n  function deleteFetcherAndUpdateState(key) {\n    if (future.v7_fetcherPersist) {\n      let count = (activeFetchers.get(key) || 0) - 1;\n      if (count <= 0) {\n        activeFetchers.delete(key);\n        deletedFetchers.add(key);\n      } else {\n        activeFetchers.set(key, count);\n      }\n    } else {\n      deleteFetcher(key);\n    }\n    updateState({\n      fetchers: new Map(state.fetchers)\n    });\n  }\n  function abortFetcher(key) {\n    let controller = fetchControllers.get(key);\n    invariant(controller, \"Expected fetch controller: \" + key);\n    controller.abort();\n    fetchControllers.delete(key);\n  }\n  function markFetchersDone(keys) {\n    for (let key of keys) {\n      let fetcher = getFetcher(key);\n      let doneFetcher = getDoneFetcher(fetcher.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  function markFetchRedirectsDone() {\n    let doneKeys = [];\n    let updatedFetchers = false;\n    for (let key of fetchRedirectIds) {\n      let fetcher = state.fetchers.get(key);\n      invariant(fetcher, \"Expected fetcher: \" + key);\n      if (fetcher.state === \"loading\") {\n        fetchRedirectIds.delete(key);\n        doneKeys.push(key);\n        updatedFetchers = true;\n      }\n    }\n    markFetchersDone(doneKeys);\n    return updatedFetchers;\n  }\n  function abortStaleFetchLoads(landedId) {\n    let yeetedKeys = [];\n    for (let [key, id] of fetchReloadIds) {\n      if (id < landedId) {\n        let fetcher = state.fetchers.get(key);\n        invariant(fetcher, \"Expected fetcher: \" + key);\n        if (fetcher.state === \"loading\") {\n          abortFetcher(key);\n          fetchReloadIds.delete(key);\n          yeetedKeys.push(key);\n        }\n      }\n    }\n    markFetchersDone(yeetedKeys);\n    return yeetedKeys.length > 0;\n  }\n  function getBlocker(key, fn) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    if (blockerFunctions.get(key) !== fn) {\n      blockerFunctions.set(key, fn);\n    }\n    return blocker;\n  }\n  function deleteBlocker(key) {\n    state.blockers.delete(key);\n    blockerFunctions.delete(key);\n  }\n  // Utility function to update blockers, ensuring valid state transitions\n  function updateBlocker(key, newBlocker) {\n    let blocker = state.blockers.get(key) || IDLE_BLOCKER;\n    // Poor mans state machine :)\n    // https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\n    invariant(blocker.state === \"unblocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"blocked\" || blocker.state === \"blocked\" && newBlocker.state === \"proceeding\" || blocker.state === \"blocked\" && newBlocker.state === \"unblocked\" || blocker.state === \"proceeding\" && newBlocker.state === \"unblocked\", \"Invalid blocker state transition: \" + blocker.state + \" -> \" + newBlocker.state);\n    let blockers = new Map(state.blockers);\n    blockers.set(key, newBlocker);\n    updateState({\n      blockers\n    });\n  }\n  function shouldBlockNavigation(_ref2) {\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = _ref2;\n    if (blockerFunctions.size === 0) {\n      return;\n    }\n    // We ony support a single active blocker at the moment since we don't have\n    // any compelling use cases for multi-blocker yet\n    if (blockerFunctions.size > 1) {\n      warning(false, \"A router only supports one blocker at a time\");\n    }\n    let entries = Array.from(blockerFunctions.entries());\n    let [blockerKey, blockerFunction] = entries[entries.length - 1];\n    let blocker = state.blockers.get(blockerKey);\n    if (blocker && blocker.state === \"proceeding\") {\n      // If the blocker is currently proceeding, we don't need to re-check\n      // it and can let this navigation continue\n      return;\n    }\n    // At this point, we know we're unblocked/blocked so we need to check the\n    // user-provided blocker function\n    if (blockerFunction({\n      currentLocation,\n      nextLocation,\n      historyAction\n    })) {\n      return blockerKey;\n    }\n  }\n  function cancelActiveDeferreds(predicate) {\n    let cancelledRouteIds = [];\n    activeDeferreds.forEach((dfd, routeId) => {\n      if (!predicate || predicate(routeId)) {\n        // Cancel the deferred - but do not remove from activeDeferreds here -\n        // we rely on the subscribers to do that so our tests can assert proper\n        // cleanup via _internalActiveDeferreds\n        dfd.cancel();\n        cancelledRouteIds.push(routeId);\n        activeDeferreds.delete(routeId);\n      }\n    });\n    return cancelledRouteIds;\n  }\n  // Opt in to capturing and reporting scroll positions during navigations,\n  // used by the <ScrollRestoration> component\n  function enableScrollRestoration(positions, getPosition, getKey) {\n    savedScrollPositions = positions;\n    getScrollPosition = getPosition;\n    getScrollRestorationKey = getKey || null;\n    // Perform initial hydration scroll restoration, since we miss the boat on\n    // the initial updateState() because we've not yet rendered <ScrollRestoration/>\n    // and therefore have no savedScrollPositions available\n    if (!initialScrollRestored && state.navigation === IDLE_NAVIGATION) {\n      initialScrollRestored = true;\n      let y = getSavedScrollPosition(state.location, state.matches);\n      if (y != null) {\n        updateState({\n          restoreScrollPosition: y\n        });\n      }\n    }\n    return () => {\n      savedScrollPositions = null;\n      getScrollPosition = null;\n      getScrollRestorationKey = null;\n    };\n  }\n  function getScrollKey(location, matches) {\n    if (getScrollRestorationKey) {\n      let key = getScrollRestorationKey(location, matches.map(m => convertRouteMatchToUiMatch(m, state.loaderData)));\n      return key || location.key;\n    }\n    return location.key;\n  }\n  function saveScrollPosition(location, matches) {\n    if (savedScrollPositions && getScrollPosition) {\n      let key = getScrollKey(location, matches);\n      savedScrollPositions[key] = getScrollPosition();\n    }\n  }\n  function getSavedScrollPosition(location, matches) {\n    if (savedScrollPositions) {\n      let key = getScrollKey(location, matches);\n      let y = savedScrollPositions[key];\n      if (typeof y === \"number\") {\n        return y;\n      }\n    }\n    return null;\n  }\n  function _internalSetRoutes(newRoutes) {\n    manifest = {};\n    inFlightDataRoutes = convertRoutesToDataRoutes(newRoutes, mapRouteProperties, undefined, manifest);\n  }\n  router = {\n    get basename() {\n      return basename;\n    },\n    get state() {\n      return state;\n    },\n    get routes() {\n      return dataRoutes;\n    },\n    get window() {\n      return routerWindow;\n    },\n    initialize,\n    subscribe,\n    enableScrollRestoration,\n    navigate,\n    fetch,\n    revalidate,\n    // Passthrough to history-aware createHref used by useHref so we get proper\n    // hash-aware URLs in DOM paths\n    createHref: to => init.history.createHref(to),\n    encodeLocation: to => init.history.encodeLocation(to),\n    getFetcher,\n    deleteFetcher: deleteFetcherAndUpdateState,\n    dispose,\n    getBlocker,\n    deleteBlocker,\n    _internalFetchControllers: fetchControllers,\n    _internalActiveDeferreds: activeDeferreds,\n    // TODO: Remove setRoutes, it's temporary to avoid dealing with\n    // updating the tree while validating the update algorithm.\n    _internalSetRoutes\n  };\n  return router;\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL = Symbol(\"deferred\");\nfunction createStaticHandler(routes, opts) {\n  invariant(routes.length > 0, \"You must provide a non-empty routes array to createStaticHandler\");\n  let manifest = {};\n  let basename = (opts ? opts.basename : null) || \"/\";\n  let mapRouteProperties;\n  if (opts != null && opts.mapRouteProperties) {\n    mapRouteProperties = opts.mapRouteProperties;\n  } else if (opts != null && opts.detectErrorBoundary) {\n    // If they are still using the deprecated version, wrap it with the new API\n    let detectErrorBoundary = opts.detectErrorBoundary;\n    mapRouteProperties = route => ({\n      hasErrorBoundary: detectErrorBoundary(route)\n    });\n  } else {\n    mapRouteProperties = defaultMapRouteProperties;\n  }\n  let dataRoutes = convertRoutesToDataRoutes(routes, mapRouteProperties, undefined, manifest);\n  /**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */\n  async function query(request, _temp3) {\n    let {\n      requestContext\n    } = _temp3 === void 0 ? {} : _temp3;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\") {\n      let error = getInternalRouterError(405, {\n        method\n      });\n      let {\n        matches: methodNotAllowedMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: methodNotAllowedMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    } else if (!matches) {\n      let error = getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n      let {\n        matches: notFoundMatches,\n        route\n      } = getShortCircuitMatches(dataRoutes);\n      return {\n        basename,\n        location,\n        matches: notFoundMatches,\n        loaderData: {},\n        actionData: null,\n        errors: {\n          [route.id]: error\n        },\n        statusCode: error.status,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let result = await queryImpl(request, location, matches, requestContext);\n    if (isResponse(result)) {\n      return result;\n    }\n    // When returning StaticHandlerContext, we patch back in the location here\n    // since we need it for React Context.  But this helps keep our submit and\n    // loadRouteData operating on a Request instead of a Location\n    return _extends({\n      location,\n      basename\n    }, result);\n  }\n  /**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */\n  async function queryRoute(request, _temp4) {\n    let {\n      routeId,\n      requestContext\n    } = _temp4 === void 0 ? {} : _temp4;\n    let url = new URL(request.url);\n    let method = request.method;\n    let location = createLocation(\"\", createPath(url), null, \"default\");\n    let matches = matchRoutes(dataRoutes, location, basename);\n    // SSR supports HEAD requests while SPA doesn't\n    if (!isValidMethod(method) && method !== \"HEAD\" && method !== \"OPTIONS\") {\n      throw getInternalRouterError(405, {\n        method\n      });\n    } else if (!matches) {\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let match = routeId ? matches.find(m => m.route.id === routeId) : getTargetMatch(matches, location);\n    if (routeId && !match) {\n      throw getInternalRouterError(403, {\n        pathname: location.pathname,\n        routeId\n      });\n    } else if (!match) {\n      // This should never hit I don't think?\n      throw getInternalRouterError(404, {\n        pathname: location.pathname\n      });\n    }\n    let result = await queryImpl(request, location, matches, requestContext, match);\n    if (isResponse(result)) {\n      return result;\n    }\n    let error = result.errors ? Object.values(result.errors)[0] : undefined;\n    if (error !== undefined) {\n      // If we got back result.errors, that means the loader/action threw\n      // _something_ that wasn't a Response, but it's not guaranteed/required\n      // to be an `instanceof Error` either, so we have to use throw here to\n      // preserve the \"error\" state outside of queryImpl.\n      throw error;\n    }\n    // Pick off the right state value to return\n    if (result.actionData) {\n      return Object.values(result.actionData)[0];\n    }\n    if (result.loaderData) {\n      var _result$activeDeferre;\n      let data = Object.values(result.loaderData)[0];\n      if ((_result$activeDeferre = result.activeDeferreds) != null && _result$activeDeferre[match.route.id]) {\n        data[UNSAFE_DEFERRED_SYMBOL] = result.activeDeferreds[match.route.id];\n      }\n      return data;\n    }\n    return undefined;\n  }\n  async function queryImpl(request, location, matches, requestContext, routeMatch) {\n    invariant(request.signal, \"query()/queryRoute() requests must contain an AbortController signal\");\n    try {\n      if (isMutationMethod(request.method.toLowerCase())) {\n        let result = await submit(request, matches, routeMatch || getTargetMatch(matches, location), requestContext, routeMatch != null);\n        return result;\n      }\n      let result = await loadRouteData(request, matches, requestContext, routeMatch);\n      return isResponse(result) ? result : _extends({}, result, {\n        actionData: null,\n        actionHeaders: {}\n      });\n    } catch (e) {\n      // If the user threw/returned a Response in callLoaderOrAction, we throw\n      // it to bail out and then return or throw here based on whether the user\n      // returned or threw\n      if (isQueryRouteResponse(e)) {\n        if (e.type === ResultType.error) {\n          throw e.response;\n        }\n        return e.response;\n      }\n      // Redirects are always returned since they don't propagate to catch\n      // boundaries\n      if (isRedirectResponse(e)) {\n        return e;\n      }\n      throw e;\n    }\n  }\n  async function submit(request, matches, actionMatch, requestContext, isRouteRequest) {\n    let result;\n    if (!actionMatch.route.action && !actionMatch.route.lazy) {\n      let error = getInternalRouterError(405, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: actionMatch.route.id\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    } else {\n      result = await callLoaderOrAction(\"action\", request, actionMatch, matches, manifest, mapRouteProperties, basename, {\n        isStaticRequest: true,\n        isRouteRequest,\n        requestContext\n      });\n      if (request.signal.aborted) {\n        let method = isRouteRequest ? \"queryRoute\" : \"query\";\n        throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n      }\n    }\n    if (isRedirectResult(result)) {\n      // Uhhhh - this should never happen, we should always throw these from\n      // callLoaderOrAction, but the type narrowing here keeps TS happy and we\n      // can get back on the \"throw all redirect responses\" train here should\n      // this ever happen :/\n      throw new Response(null, {\n        status: result.status,\n        headers: {\n          Location: result.location\n        }\n      });\n    }\n    if (isDeferredResult(result)) {\n      let error = getInternalRouterError(400, {\n        type: \"defer-action\"\n      });\n      if (isRouteRequest) {\n        throw error;\n      }\n      result = {\n        type: ResultType.error,\n        error\n      };\n    }\n    if (isRouteRequest) {\n      // Note: This should only be non-Response values if we get here, since\n      // isRouteRequest should throw any Response received in callLoaderOrAction\n      if (isErrorResult(result)) {\n        throw result.error;\n      }\n      return {\n        matches: [actionMatch],\n        loaderData: {},\n        actionData: {\n          [actionMatch.route.id]: result.data\n        },\n        errors: null,\n        // Note: statusCode + headers are unused here since queryRoute will\n        // return the raw Response or value\n        statusCode: 200,\n        loaderHeaders: {},\n        actionHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    if (isErrorResult(result)) {\n      // Store off the pending error - we use it to determine which loaders\n      // to call and will commit it when we complete the navigation\n      let boundaryMatch = findNearestBoundary(matches, actionMatch.route.id);\n      let context = await loadRouteData(request, matches, requestContext, undefined, {\n        [boundaryMatch.route.id]: result.error\n      });\n      // action status codes take precedence over loader status codes\n      return _extends({}, context, {\n        statusCode: isRouteErrorResponse(result.error) ? result.error.status : 500,\n        actionData: null,\n        actionHeaders: _extends({}, result.headers ? {\n          [actionMatch.route.id]: result.headers\n        } : {})\n      });\n    }\n    // Create a GET request for the loaders\n    let loaderRequest = new Request(request.url, {\n      headers: request.headers,\n      redirect: request.redirect,\n      signal: request.signal\n    });\n    let context = await loadRouteData(loaderRequest, matches, requestContext);\n    return _extends({}, context, result.statusCode ? {\n      statusCode: result.statusCode\n    } : {}, {\n      actionData: {\n        [actionMatch.route.id]: result.data\n      },\n      actionHeaders: _extends({}, result.headers ? {\n        [actionMatch.route.id]: result.headers\n      } : {})\n    });\n  }\n  async function loadRouteData(request, matches, requestContext, routeMatch, pendingActionError) {\n    let isRouteRequest = routeMatch != null;\n    // Short circuit if we have no loaders to run (queryRoute())\n    if (isRouteRequest && !(routeMatch != null && routeMatch.route.loader) && !(routeMatch != null && routeMatch.route.lazy)) {\n      throw getInternalRouterError(400, {\n        method: request.method,\n        pathname: new URL(request.url).pathname,\n        routeId: routeMatch == null ? void 0 : routeMatch.route.id\n      });\n    }\n    let requestMatches = routeMatch ? [routeMatch] : getLoaderMatchesUntilBoundary(matches, Object.keys(pendingActionError || {})[0]);\n    let matchesToLoad = requestMatches.filter(m => m.route.loader || m.route.lazy);\n    // Short circuit if we have no loaders to run (query())\n    if (matchesToLoad.length === 0) {\n      return {\n        matches,\n        // Add a null for all matched routes for proper revalidation on the client\n        loaderData: matches.reduce((acc, m) => Object.assign(acc, {\n          [m.route.id]: null\n        }), {}),\n        errors: pendingActionError || null,\n        statusCode: 200,\n        loaderHeaders: {},\n        activeDeferreds: null\n      };\n    }\n    let results = await Promise.all([...matchesToLoad.map(match => callLoaderOrAction(\"loader\", request, match, matches, manifest, mapRouteProperties, basename, {\n      isStaticRequest: true,\n      isRouteRequest,\n      requestContext\n    }))]);\n    if (request.signal.aborted) {\n      let method = isRouteRequest ? \"queryRoute\" : \"query\";\n      throw new Error(method + \"() call aborted: \" + request.method + \" \" + request.url);\n    }\n    // Process and commit output from loaders\n    let activeDeferreds = new Map();\n    let context = processRouteLoaderData(matches, matchesToLoad, results, pendingActionError, activeDeferreds);\n    // Add a null for any non-loader matches for proper revalidation on the client\n    let executedLoaders = new Set(matchesToLoad.map(match => match.route.id));\n    matches.forEach(match => {\n      if (!executedLoaders.has(match.route.id)) {\n        context.loaderData[match.route.id] = null;\n      }\n    });\n    return _extends({}, context, {\n      matches,\n      activeDeferreds: activeDeferreds.size > 0 ? Object.fromEntries(activeDeferreds.entries()) : null\n    });\n  }\n  return {\n    dataRoutes,\n    query,\n    queryRoute\n  };\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */\nfunction getStaticContextFromError(routes, context, error) {\n  let newContext = _extends({}, context, {\n    statusCode: 500,\n    errors: {\n      [context._deepestRenderedBoundaryId || routes[0].id]: error\n    }\n  });\n  return newContext;\n}\nfunction isSubmissionNavigation(opts) {\n  return opts != null && (\"formData\" in opts && opts.formData != null || \"body\" in opts && opts.body !== undefined);\n}\nfunction normalizeTo(location, matches, basename, prependBasename, to, fromRouteId, relative) {\n  let contextualMatches;\n  let activeRouteMatch;\n  if (fromRouteId) {\n    // Grab matches up to the calling route so our route-relative logic is\n    // relative to the correct source route\n    contextualMatches = [];\n    for (let match of matches) {\n      contextualMatches.push(match);\n      if (match.route.id === fromRouteId) {\n        activeRouteMatch = match;\n        break;\n      }\n    }\n  } else {\n    contextualMatches = matches;\n    activeRouteMatch = matches[matches.length - 1];\n  }\n  // Resolve the relative path\n  let path = resolveTo(to ? to : \".\", getResolveToMatches(contextualMatches), stripBasename(location.pathname, basename) || location.pathname, relative === \"path\");\n  // When `to` is not specified we inherit search/hash from the current\n  // location, unlike when to=\".\" and we just inherit the path.\n  // See https://github.com/remix-run/remix/issues/927\n  if (to == null) {\n    path.search = location.search;\n    path.hash = location.hash;\n  }\n  // Add an ?index param for matched index routes if we don't already have one\n  if ((to == null || to === \"\" || to === \".\") && activeRouteMatch && activeRouteMatch.route.index && !hasNakedIndexQuery(path.search)) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname.  If\n  // this is a root navigation, then just use the raw basename which allows\n  // the basename to have full control over the presence of a trailing slash\n  // on root actions\n  if (prependBasename && basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod, isFetcher, path, opts) {\n  // Return location verbatim on non-submission navigations\n  if (!opts || !isSubmissionNavigation(opts)) {\n    return {\n      path\n    };\n  }\n  if (opts.formMethod && !isValidMethod(opts.formMethod)) {\n    return {\n      path,\n      error: getInternalRouterError(405, {\n        method: opts.formMethod\n      })\n    };\n  }\n  let getInvalidBodyError = () => ({\n    path,\n    error: getInternalRouterError(400, {\n      type: \"invalid-body\"\n    })\n  });\n  // Create a Submission on non-GET navigations\n  let rawFormMethod = opts.formMethod || \"get\";\n  let formMethod = normalizeFormMethod ? rawFormMethod.toUpperCase() : rawFormMethod.toLowerCase();\n  let formAction = stripHashFromPath(path);\n  if (opts.body !== undefined) {\n    if (opts.formEncType === \"text/plain\") {\n      // text only support POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      let text = typeof opts.body === \"string\" ? opts.body : opts.body instanceof FormData || opts.body instanceof URLSearchParams ?\n      // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\n      Array.from(opts.body.entries()).reduce((acc, _ref3) => {\n        let [name, value] = _ref3;\n        return \"\" + acc + name + \"=\" + value + \"\\n\";\n      }, \"\") : String(opts.body);\n      return {\n        path,\n        submission: {\n          formMethod,\n          formAction,\n          formEncType: opts.formEncType,\n          formData: undefined,\n          json: undefined,\n          text\n        }\n      };\n    } else if (opts.formEncType === \"application/json\") {\n      // json only supports POST/PUT/PATCH/DELETE submissions\n      if (!isMutationMethod(formMethod)) {\n        return getInvalidBodyError();\n      }\n      try {\n        let json = typeof opts.body === \"string\" ? JSON.parse(opts.body) : opts.body;\n        return {\n          path,\n          submission: {\n            formMethod,\n            formAction,\n            formEncType: opts.formEncType,\n            formData: undefined,\n            json,\n            text: undefined\n          }\n        };\n      } catch (e) {\n        return getInvalidBodyError();\n      }\n    }\n  }\n  invariant(typeof FormData === \"function\", \"FormData is not available in this environment\");\n  let searchParams;\n  let formData;\n  if (opts.formData) {\n    searchParams = convertFormDataToSearchParams(opts.formData);\n    formData = opts.formData;\n  } else if (opts.body instanceof FormData) {\n    searchParams = convertFormDataToSearchParams(opts.body);\n    formData = opts.body;\n  } else if (opts.body instanceof URLSearchParams) {\n    searchParams = opts.body;\n    formData = convertSearchParamsToFormData(searchParams);\n  } else if (opts.body == null) {\n    searchParams = new URLSearchParams();\n    formData = new FormData();\n  } else {\n    try {\n      searchParams = new URLSearchParams(opts.body);\n      formData = convertSearchParamsToFormData(searchParams);\n    } catch (e) {\n      return getInvalidBodyError();\n    }\n  }\n  let submission = {\n    formMethod,\n    formAction,\n    formEncType: opts && opts.formEncType || \"application/x-www-form-urlencoded\",\n    formData,\n    json: undefined,\n    text: undefined\n  };\n  if (isMutationMethod(submission.formMethod)) {\n    return {\n      path,\n      submission\n    };\n  }\n  // Flatten submission onto URLSearchParams for GET submissions\n  let parsedPath = parsePath(path);\n  // On GET navigation submissions we can drop the ?index param from the\n  // resulting location since all loaders will run.  But fetcher GET submissions\n  // only run a single loader so we need to preserve any incoming ?index params\n  if (isFetcher && parsedPath.search && hasNakedIndexQuery(parsedPath.search)) {\n    searchParams.append(\"index\", \"\");\n  }\n  parsedPath.search = \"?\" + searchParams;\n  return {\n    path: createPath(parsedPath),\n    submission\n  };\n}\n// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches, boundaryId) {\n  let boundaryMatches = matches;\n  if (boundaryId) {\n    let index = matches.findIndex(m => m.route.id === boundaryId);\n    if (index >= 0) {\n      boundaryMatches = matches.slice(0, index);\n    }\n  }\n  return boundaryMatches;\n}\nfunction getMatchesToLoad(history, state, matches, submission, location, isRevalidationRequired, cancelledDeferredRoutes, cancelledFetcherLoads, deletedFetchers, fetchLoadMatches, fetchRedirectIds, routesToUse, basename, pendingActionData, pendingError) {\n  let actionResult = pendingError ? Object.values(pendingError)[0] : pendingActionData ? Object.values(pendingActionData)[0] : undefined;\n  let currentUrl = history.createURL(state.location);\n  let nextUrl = history.createURL(location);\n  // Pick navigation matches that are net-new or qualify for revalidation\n  let boundaryId = pendingError ? Object.keys(pendingError)[0] : undefined;\n  let boundaryMatches = getLoaderMatchesUntilBoundary(matches, boundaryId);\n  let navigationMatches = boundaryMatches.filter((match, index) => {\n    if (match.route.lazy) {\n      // We haven't loaded this route yet so we don't know if it's got a loader!\n      return true;\n    }\n    if (match.route.loader == null) {\n      return false;\n    }\n    // Always call the loader on new route instances and pending defer cancellations\n    if (isNewLoader(state.loaderData, state.matches[index], match) || cancelledDeferredRoutes.some(id => id === match.route.id)) {\n      return true;\n    }\n    // This is the default implementation for when we revalidate.  If the route\n    // provides it's own implementation, then we give them full control but\n    // provide this value so they can leverage it if needed after they check\n    // their own specific use cases\n    let currentRouteMatch = state.matches[index];\n    let nextRouteMatch = match;\n    return shouldRevalidateLoader(match, _extends({\n      currentUrl,\n      currentParams: currentRouteMatch.params,\n      nextUrl,\n      nextParams: nextRouteMatch.params\n    }, submission, {\n      actionResult,\n      defaultShouldRevalidate:\n      // Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\n      isRevalidationRequired ||\n      // Clicked the same link, resubmitted a GET form\n      currentUrl.pathname + currentUrl.search === nextUrl.pathname + nextUrl.search ||\n      // Search params affect all loaders\n      currentUrl.search !== nextUrl.search || isNewRouteInstance(currentRouteMatch, nextRouteMatch)\n    }));\n  });\n  // Pick fetcher.loads that need to be revalidated\n  let revalidatingFetchers = [];\n  fetchLoadMatches.forEach((f, key) => {\n    // Don't revalidate if fetcher won't be present in the subsequent render\n    if (!matches.some(m => m.route.id === f.routeId) || deletedFetchers.has(key)) {\n      return;\n    }\n    let fetcherMatches = matchRoutes(routesToUse, f.path, basename);\n    // If the fetcher path no longer matches, push it in with null matches so\n    // we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n    // currently only a use-case for Remix HMR where the route tree can change\n    // at runtime and remove a route previously loaded via a fetcher\n    if (!fetcherMatches) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: null,\n        match: null,\n        controller: null\n      });\n      return;\n    }\n    // Revalidating fetchers are decoupled from the route matches since they\n    // load from a static href.  They revalidate based on explicit revalidation\n    // (submission, useRevalidator, or X-Remix-Revalidate)\n    let fetcher = state.fetchers.get(key);\n    let fetcherMatch = getTargetMatch(fetcherMatches, f.path);\n    let shouldRevalidate = false;\n    if (fetchRedirectIds.has(key)) {\n      // Never trigger a revalidation of an actively redirecting fetcher\n      shouldRevalidate = false;\n    } else if (cancelledFetcherLoads.includes(key)) {\n      // Always revalidate if the fetcher was cancelled\n      shouldRevalidate = true;\n    } else if (fetcher && fetcher.state !== \"idle\" && fetcher.data === undefined) {\n      // If the fetcher hasn't ever completed loading yet, then this isn't a\n      // revalidation, it would just be a brand new load if an explicit\n      // revalidation is required\n      shouldRevalidate = isRevalidationRequired;\n    } else {\n      // Otherwise fall back on any user-defined shouldRevalidate, defaulting\n      // to explicit revalidations only\n      shouldRevalidate = shouldRevalidateLoader(fetcherMatch, _extends({\n        currentUrl,\n        currentParams: state.matches[state.matches.length - 1].params,\n        nextUrl,\n        nextParams: matches[matches.length - 1].params\n      }, submission, {\n        actionResult,\n        defaultShouldRevalidate: isRevalidationRequired\n      }));\n    }\n    if (shouldRevalidate) {\n      revalidatingFetchers.push({\n        key,\n        routeId: f.routeId,\n        path: f.path,\n        matches: fetcherMatches,\n        match: fetcherMatch,\n        controller: new AbortController()\n      });\n    }\n  });\n  return [navigationMatches, revalidatingFetchers];\n}\nfunction isNewLoader(currentLoaderData, currentMatch, match) {\n  let isNew =\n  // [a] -> [a, b]\n  !currentMatch ||\n  // [a, b] -> [a, c]\n  match.route.id !== currentMatch.route.id;\n  // Handle the case that we don't have data for a re-used route, potentially\n  // from a prior error or from a cancelled pending deferred\n  let isMissingData = currentLoaderData[match.route.id] === undefined;\n  // Always load if this is a net-new route or we don't yet have data\n  return isNew || isMissingData;\n}\nfunction isNewRouteInstance(currentMatch, match) {\n  let currentPath = currentMatch.route.path;\n  return (\n    // param change for this match, /users/123 -> /users/456\n    currentMatch.pathname !== match.pathname ||\n    // splat param changed, which is not present in match.path\n    // e.g. /files/images/avatar.jpg -> files/finances.xls\n    currentPath != null && currentPath.endsWith(\"*\") && currentMatch.params[\"*\"] !== match.params[\"*\"]\n  );\n}\nfunction shouldRevalidateLoader(loaderMatch, arg) {\n  if (loaderMatch.route.shouldRevalidate) {\n    let routeChoice = loaderMatch.route.shouldRevalidate(arg);\n    if (typeof routeChoice === \"boolean\") {\n      return routeChoice;\n    }\n  }\n  return arg.defaultShouldRevalidate;\n}\n/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */\nasync function loadLazyRouteModule(route, mapRouteProperties, manifest) {\n  if (!route.lazy) {\n    return;\n  }\n  let lazyRoute = await route.lazy();\n  // If the lazy route function was executed and removed by another parallel\n  // call then we can return - first lazy() to finish wins because the return\n  // value of lazy is expected to be static\n  if (!route.lazy) {\n    return;\n  }\n  let routeToUpdate = manifest[route.id];\n  invariant(routeToUpdate, \"No route found in manifest\");\n  // Update the route in place.  This should be safe because there's no way\n  // we could yet be sitting on this route as we can't get there without\n  // resolving lazy() first.\n  //\n  // This is different than the HMR \"update\" use-case where we may actively be\n  // on the route being updated.  The main concern boils down to \"does this\n  // mutation affect any ongoing navigations or any current state.matches\n  // values?\".  If not, it should be safe to update in place.\n  let routeUpdates = {};\n  for (let lazyRouteProperty in lazyRoute) {\n    let staticRouteValue = routeToUpdate[lazyRouteProperty];\n    let isPropertyStaticallyDefined = staticRouteValue !== undefined &&\n    // This property isn't static since it should always be updated based\n    // on the route updates\n    lazyRouteProperty !== \"hasErrorBoundary\";\n    warning(!isPropertyStaticallyDefined, \"Route \\\"\" + routeToUpdate.id + \"\\\" has a static property \\\"\" + lazyRouteProperty + \"\\\" \" + \"defined but its lazy function is also returning a value for this property. \" + (\"The lazy route property \\\"\" + lazyRouteProperty + \"\\\" will be ignored.\"));\n    if (!isPropertyStaticallyDefined && !immutableRouteKeys.has(lazyRouteProperty)) {\n      routeUpdates[lazyRouteProperty] = lazyRoute[lazyRouteProperty];\n    }\n  }\n  // Mutate the route with the provided updates.  Do this first so we pass\n  // the updated version to mapRouteProperties\n  Object.assign(routeToUpdate, routeUpdates);\n  // Mutate the `hasErrorBoundary` property on the route based on the route\n  // updates and remove the `lazy` function so we don't resolve the lazy\n  // route again.\n  Object.assign(routeToUpdate, _extends({}, mapRouteProperties(routeToUpdate), {\n    lazy: undefined\n  }));\n}\nasync function callLoaderOrAction(type, request, match, matches, manifest, mapRouteProperties, basename, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let resultType;\n  let result;\n  let onReject;\n  let runHandler = handler => {\n    // Setup a promise we can race against so that abort signals short circuit\n    let reject;\n    let abortPromise = new Promise((_, r) => reject = r);\n    onReject = () => reject();\n    request.signal.addEventListener(\"abort\", onReject);\n    return Promise.race([handler({\n      request,\n      params: match.params,\n      context: opts.requestContext\n    }), abortPromise]);\n  };\n  try {\n    let handler = match.route[type];\n    if (match.route.lazy) {\n      if (handler) {\n        // Run statically defined handler in parallel with lazy()\n        let handlerError;\n        let values = await Promise.all([\n        // If the handler throws, don't let it immediately bubble out,\n        // since we need to let the lazy() execution finish so we know if this\n        // route has a boundary that can handle the error\n        runHandler(handler).catch(e => {\n          handlerError = e;\n        }), loadLazyRouteModule(match.route, mapRouteProperties, manifest)]);\n        if (handlerError) {\n          throw handlerError;\n        }\n        result = values[0];\n      } else {\n        // Load lazy route module, then run any returned handler\n        await loadLazyRouteModule(match.route, mapRouteProperties, manifest);\n        handler = match.route[type];\n        if (handler) {\n          // Handler still run even if we got interrupted to maintain consistency\n          // with un-abortable behavior of handler execution on non-lazy or\n          // previously-lazy-loaded routes\n          result = await runHandler(handler);\n        } else if (type === \"action\") {\n          let url = new URL(request.url);\n          let pathname = url.pathname + url.search;\n          throw getInternalRouterError(405, {\n            method: request.method,\n            pathname,\n            routeId: match.route.id\n          });\n        } else {\n          // lazy() route has no loader to run.  Short circuit here so we don't\n          // hit the invariant below that errors on returning undefined.\n          return {\n            type: ResultType.data,\n            data: undefined\n          };\n        }\n      }\n    } else if (!handler) {\n      let url = new URL(request.url);\n      let pathname = url.pathname + url.search;\n      throw getInternalRouterError(404, {\n        pathname\n      });\n    } else {\n      result = await runHandler(handler);\n    }\n    invariant(result !== undefined, \"You defined \" + (type === \"action\" ? \"an action\" : \"a loader\") + \" for route \" + (\"\\\"\" + match.route.id + \"\\\" but didn't return anything from your `\" + type + \"` \") + \"function. Please return a value or `null`.\");\n  } catch (e) {\n    resultType = ResultType.error;\n    result = e;\n  } finally {\n    if (onReject) {\n      request.signal.removeEventListener(\"abort\", onReject);\n    }\n  }\n  if (isResponse(result)) {\n    let status = result.status;\n    // Process redirects\n    if (redirectStatusCodes.has(status)) {\n      let location = result.headers.get(\"Location\");\n      invariant(location, \"Redirects returned/thrown from loaders/actions must have a Location header\");\n      // Support relative routing in internal redirects\n      if (!ABSOLUTE_URL_REGEX.test(location)) {\n        location = normalizeTo(new URL(request.url), matches.slice(0, matches.indexOf(match) + 1), basename, true, location);\n      } else if (!opts.isStaticRequest) {\n        // Strip off the protocol+origin for same-origin + same-basename absolute\n        // redirects. If this is a static request, we can let it go back to the\n        // browser as-is\n        let currentUrl = new URL(request.url);\n        let url = location.startsWith(\"//\") ? new URL(currentUrl.protocol + location) : new URL(location);\n        let isSameBasename = stripBasename(url.pathname, basename) != null;\n        if (url.origin === currentUrl.origin && isSameBasename) {\n          location = url.pathname + url.search + url.hash;\n        }\n      }\n      // Don't process redirects in the router during static requests requests.\n      // Instead, throw the Response and let the server handle it with an HTTP\n      // redirect.  We also update the Location header in place in this flow so\n      // basename and relative routing is taken into account\n      if (opts.isStaticRequest) {\n        result.headers.set(\"Location\", location);\n        throw result;\n      }\n      return {\n        type: ResultType.redirect,\n        status,\n        location,\n        revalidate: result.headers.get(\"X-Remix-Revalidate\") !== null,\n        reloadDocument: result.headers.get(\"X-Remix-Reload-Document\") !== null\n      };\n    }\n    // For SSR single-route requests, we want to hand Responses back directly\n    // without unwrapping.  We do this with the QueryRouteResponse wrapper\n    // interface so we can know whether it was returned or thrown\n    if (opts.isRouteRequest) {\n      let queryRouteResponse = {\n        type: resultType === ResultType.error ? ResultType.error : ResultType.data,\n        response: result\n      };\n      throw queryRouteResponse;\n    }\n    let data;\n    let contentType = result.headers.get(\"Content-Type\");\n    // Check between word boundaries instead of startsWith() due to the last\n    // paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\n    if (contentType && /\\bapplication\\/json\\b/.test(contentType)) {\n      data = await result.json();\n    } else {\n      data = await result.text();\n    }\n    if (resultType === ResultType.error) {\n      return {\n        type: resultType,\n        error: new ErrorResponseImpl(status, result.statusText, data),\n        headers: result.headers\n      };\n    }\n    return {\n      type: ResultType.data,\n      data,\n      statusCode: result.status,\n      headers: result.headers\n    };\n  }\n  if (resultType === ResultType.error) {\n    return {\n      type: resultType,\n      error: result\n    };\n  }\n  if (isDeferredData(result)) {\n    var _result$init, _result$init2;\n    return {\n      type: ResultType.deferred,\n      deferredData: result,\n      statusCode: (_result$init = result.init) == null ? void 0 : _result$init.status,\n      headers: ((_result$init2 = result.init) == null ? void 0 : _result$init2.headers) && new Headers(result.init.headers)\n    };\n  }\n  return {\n    type: ResultType.data,\n    data: result\n  };\n}\n// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history, location, signal, submission) {\n  let url = history.createURL(stripHashFromPath(location)).toString();\n  let init = {\n    signal\n  };\n  if (submission && isMutationMethod(submission.formMethod)) {\n    let {\n      formMethod,\n      formEncType\n    } = submission;\n    // Didn't think we needed this but it turns out unlike other methods, patch\n    // won't be properly normalized to uppercase and results in a 405 error.\n    // See: https://fetch.spec.whatwg.org/#concept-method\n    init.method = formMethod.toUpperCase();\n    if (formEncType === \"application/json\") {\n      init.headers = new Headers({\n        \"Content-Type\": formEncType\n      });\n      init.body = JSON.stringify(submission.json);\n    } else if (formEncType === \"text/plain\") {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.text;\n    } else if (formEncType === \"application/x-www-form-urlencoded\" && submission.formData) {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = convertFormDataToSearchParams(submission.formData);\n    } else {\n      // Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\n      init.body = submission.formData;\n    }\n  }\n  return new Request(url, init);\n}\nfunction convertFormDataToSearchParams(formData) {\n  let searchParams = new URLSearchParams();\n  for (let [key, value] of formData.entries()) {\n    // https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\n    searchParams.append(key, typeof value === \"string\" ? value : value.name);\n  }\n  return searchParams;\n}\nfunction convertSearchParamsToFormData(searchParams) {\n  let formData = new FormData();\n  for (let [key, value] of searchParams.entries()) {\n    formData.append(key, value);\n  }\n  return formData;\n}\nfunction processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds) {\n  // Fill in loaderData/errors from our loaders\n  let loaderData = {};\n  let errors = null;\n  let statusCode;\n  let foundError = false;\n  let loaderHeaders = {};\n  // Process loader results into state.loaderData/state.errors\n  results.forEach((result, index) => {\n    let id = matchesToLoad[index].route.id;\n    invariant(!isRedirectResult(result), \"Cannot handle redirect results in processLoaderData\");\n    if (isErrorResult(result)) {\n      // Look upwards from the matched route for the closest ancestor\n      // error boundary, defaulting to the root match\n      let boundaryMatch = findNearestBoundary(matches, id);\n      let error = result.error;\n      // If we have a pending action error, we report it at the highest-route\n      // that throws a loader error, and then clear it out to indicate that\n      // it was consumed\n      if (pendingError) {\n        error = Object.values(pendingError)[0];\n        pendingError = undefined;\n      }\n      errors = errors || {};\n      // Prefer higher error values if lower errors bubble to the same boundary\n      if (errors[boundaryMatch.route.id] == null) {\n        errors[boundaryMatch.route.id] = error;\n      }\n      // Clear our any prior loaderData for the throwing route\n      loaderData[id] = undefined;\n      // Once we find our first (highest) error, we set the status code and\n      // prevent deeper status codes from overriding\n      if (!foundError) {\n        foundError = true;\n        statusCode = isRouteErrorResponse(result.error) ? result.error.status : 500;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    } else {\n      if (isDeferredResult(result)) {\n        activeDeferreds.set(id, result.deferredData);\n        loaderData[id] = result.deferredData.data;\n      } else {\n        loaderData[id] = result.data;\n      }\n      // Error status codes always override success status codes, but if all\n      // loaders are successful we take the deepest status code.\n      if (result.statusCode != null && result.statusCode !== 200 && !foundError) {\n        statusCode = result.statusCode;\n      }\n      if (result.headers) {\n        loaderHeaders[id] = result.headers;\n      }\n    }\n  });\n  // If we didn't consume the pending action error (i.e., all loaders\n  // resolved), then consume it here.  Also clear out any loaderData for the\n  // throwing route\n  if (pendingError) {\n    errors = pendingError;\n    loaderData[Object.keys(pendingError)[0]] = undefined;\n  }\n  return {\n    loaderData,\n    errors,\n    statusCode: statusCode || 200,\n    loaderHeaders\n  };\n}\nfunction processLoaderData(state, matches, matchesToLoad, results, pendingError, revalidatingFetchers, fetcherResults, activeDeferreds) {\n  let {\n    loaderData,\n    errors\n  } = processRouteLoaderData(matches, matchesToLoad, results, pendingError, activeDeferreds);\n  // Process results from our revalidating fetchers\n  for (let index = 0; index < revalidatingFetchers.length; index++) {\n    let {\n      key,\n      match,\n      controller\n    } = revalidatingFetchers[index];\n    invariant(fetcherResults !== undefined && fetcherResults[index] !== undefined, \"Did not find corresponding fetcher result\");\n    let result = fetcherResults[index];\n    // Process fetcher non-redirect errors\n    if (controller && controller.signal.aborted) {\n      // Nothing to do for aborted fetchers\n      continue;\n    } else if (isErrorResult(result)) {\n      let boundaryMatch = findNearestBoundary(state.matches, match == null ? void 0 : match.route.id);\n      if (!(errors && errors[boundaryMatch.route.id])) {\n        errors = _extends({}, errors, {\n          [boundaryMatch.route.id]: result.error\n        });\n      }\n      state.fetchers.delete(key);\n    } else if (isRedirectResult(result)) {\n      // Should never get here, redirects should get processed above, but we\n      // keep this to type narrow to a success result in the else\n      invariant(false, \"Unhandled fetcher revalidation redirect\");\n    } else if (isDeferredResult(result)) {\n      // Should never get here, deferred data should be awaited for fetchers\n      // in resolveDeferredResults\n      invariant(false, \"Unhandled fetcher deferred data\");\n    } else {\n      let doneFetcher = getDoneFetcher(result.data);\n      state.fetchers.set(key, doneFetcher);\n    }\n  }\n  return {\n    loaderData,\n    errors\n  };\n}\nfunction mergeLoaderData(loaderData, newLoaderData, matches, errors) {\n  let mergedLoaderData = _extends({}, newLoaderData);\n  for (let match of matches) {\n    let id = match.route.id;\n    if (newLoaderData.hasOwnProperty(id)) {\n      if (newLoaderData[id] !== undefined) {\n        mergedLoaderData[id] = newLoaderData[id];\n      }\n    } else if (loaderData[id] !== undefined && match.route.loader) {\n      // Preserve existing keys not included in newLoaderData and where a loader\n      // wasn't removed by HMR\n      mergedLoaderData[id] = loaderData[id];\n    }\n    if (errors && errors.hasOwnProperty(id)) {\n      // Don't keep any loader data below the boundary\n      break;\n    }\n  }\n  return mergedLoaderData;\n}\n// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches, routeId) {\n  let eligibleMatches = routeId ? matches.slice(0, matches.findIndex(m => m.route.id === routeId) + 1) : [...matches];\n  return eligibleMatches.reverse().find(m => m.route.hasErrorBoundary === true) || matches[0];\n}\nfunction getShortCircuitMatches(routes) {\n  // Prefer a root layout route if present, otherwise shim in a route object\n  let route = routes.length === 1 ? routes[0] : routes.find(r => r.index || !r.path || r.path === \"/\") || {\n    id: \"__shim-error-route__\"\n  };\n  return {\n    matches: [{\n      params: {},\n      pathname: \"\",\n      pathnameBase: \"\",\n      route\n    }],\n    route\n  };\n}\nfunction getInternalRouterError(status, _temp5) {\n  let {\n    pathname,\n    routeId,\n    method,\n    type\n  } = _temp5 === void 0 ? {} : _temp5;\n  let statusText = \"Unknown Server Error\";\n  let errorMessage = \"Unknown @remix-run/router error\";\n  if (status === 400) {\n    statusText = \"Bad Request\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide a `loader` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (type === \"defer-action\") {\n      errorMessage = \"defer() is not supported in actions\";\n    } else if (type === \"invalid-body\") {\n      errorMessage = \"Unable to encode submission body\";\n    }\n  } else if (status === 403) {\n    statusText = \"Forbidden\";\n    errorMessage = \"Route \\\"\" + routeId + \"\\\" does not match URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 404) {\n    statusText = \"Not Found\";\n    errorMessage = \"No route matches URL \\\"\" + pathname + \"\\\"\";\n  } else if (status === 405) {\n    statusText = \"Method Not Allowed\";\n    if (method && pathname && routeId) {\n      errorMessage = \"You made a \" + method.toUpperCase() + \" request to \\\"\" + pathname + \"\\\" but \" + (\"did not provide an `action` for route \\\"\" + routeId + \"\\\", \") + \"so there is no way to handle the request.\";\n    } else if (method) {\n      errorMessage = \"Invalid request method \\\"\" + method.toUpperCase() + \"\\\"\";\n    }\n  }\n  return new ErrorResponseImpl(status || 500, statusText, new Error(errorMessage), true);\n}\n// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results) {\n  for (let i = results.length - 1; i >= 0; i--) {\n    let result = results[i];\n    if (isRedirectResult(result)) {\n      return {\n        result,\n        idx: i\n      };\n    }\n  }\n}\nfunction stripHashFromPath(path) {\n  let parsedPath = typeof path === \"string\" ? parsePath(path) : path;\n  return createPath(_extends({}, parsedPath, {\n    hash: \"\"\n  }));\n}\nfunction isHashChangeOnly(a, b) {\n  if (a.pathname !== b.pathname || a.search !== b.search) {\n    return false;\n  }\n  if (a.hash === \"\") {\n    // /page -> /page#hash\n    return b.hash !== \"\";\n  } else if (a.hash === b.hash) {\n    // /page#hash -> /page#hash\n    return true;\n  } else if (b.hash !== \"\") {\n    // /page#hash -> /page#other\n    return true;\n  }\n  // If the hash is removed the browser will re-perform a request to the server\n  // /page#hash -> /page\n  return false;\n}\nfunction isDeferredResult(result) {\n  return result.type === ResultType.deferred;\n}\nfunction isErrorResult(result) {\n  return result.type === ResultType.error;\n}\nfunction isRedirectResult(result) {\n  return (result && result.type) === ResultType.redirect;\n}\nfunction isDeferredData(value) {\n  let deferred = value;\n  return deferred && typeof deferred === \"object\" && typeof deferred.data === \"object\" && typeof deferred.subscribe === \"function\" && typeof deferred.cancel === \"function\" && typeof deferred.resolveData === \"function\";\n}\nfunction isResponse(value) {\n  return value != null && typeof value.status === \"number\" && typeof value.statusText === \"string\" && typeof value.headers === \"object\" && typeof value.body !== \"undefined\";\n}\nfunction isRedirectResponse(result) {\n  if (!isResponse(result)) {\n    return false;\n  }\n  let status = result.status;\n  let location = result.headers.get(\"Location\");\n  return status >= 300 && status <= 399 && location != null;\n}\nfunction isQueryRouteResponse(obj) {\n  return obj && isResponse(obj.response) && (obj.type === ResultType.data || obj.type === ResultType.error);\n}\nfunction isValidMethod(method) {\n  return validRequestMethods.has(method.toLowerCase());\n}\nfunction isMutationMethod(method) {\n  return validMutationMethods.has(method.toLowerCase());\n}\nasync function resolveDeferredResults(currentMatches, matchesToLoad, results, signals, isFetcher, currentLoaderData) {\n  for (let index = 0; index < results.length; index++) {\n    let result = results[index];\n    let match = matchesToLoad[index];\n    // If we don't have a match, then we can have a deferred result to do\n    // anything with.  This is for revalidating fetchers where the route was\n    // removed during HMR\n    if (!match) {\n      continue;\n    }\n    let currentMatch = currentMatches.find(m => m.route.id === match.route.id);\n    let isRevalidatingLoader = currentMatch != null && !isNewRouteInstance(currentMatch, match) && (currentLoaderData && currentLoaderData[match.route.id]) !== undefined;\n    if (isDeferredResult(result) && (isFetcher || isRevalidatingLoader)) {\n      // Note: we do not have to touch activeDeferreds here since we race them\n      // against the signal in resolveDeferredData and they'll get aborted\n      // there if needed\n      let signal = signals[index];\n      invariant(signal, \"Expected an AbortSignal for revalidating fetcher deferred result\");\n      await resolveDeferredData(result, signal, isFetcher).then(result => {\n        if (result) {\n          results[index] = result || results[index];\n        }\n      });\n    }\n  }\n}\nasync function resolveDeferredData(result, signal, unwrap) {\n  if (unwrap === void 0) {\n    unwrap = false;\n  }\n  let aborted = await result.deferredData.resolveData(signal);\n  if (aborted) {\n    return;\n  }\n  if (unwrap) {\n    try {\n      return {\n        type: ResultType.data,\n        data: result.deferredData.unwrappedData\n      };\n    } catch (e) {\n      // Handle any TrackedPromise._error values encountered while unwrapping\n      return {\n        type: ResultType.error,\n        error: e\n      };\n    }\n  }\n  return {\n    type: ResultType.data,\n    data: result.deferredData.data\n  };\n}\nfunction hasNakedIndexQuery(search) {\n  return new URLSearchParams(search).getAll(\"index\").some(v => v === \"\");\n}\nfunction getTargetMatch(matches, location) {\n  let search = typeof location === \"string\" ? parsePath(location).search : location.search;\n  if (matches[matches.length - 1].route.index && hasNakedIndexQuery(search || \"\")) {\n    // Return the leaf index route when index is present\n    return matches[matches.length - 1];\n  }\n  // Otherwise grab the deepest \"path contributing\" match (ignoring index and\n  // pathless layout routes)\n  let pathMatches = getPathContributingMatches(matches);\n  return pathMatches[pathMatches.length - 1];\n}\nfunction getSubmissionFromNavigation(navigation) {\n  let {\n    formMethod,\n    formAction,\n    formEncType,\n    text,\n    formData,\n    json\n  } = navigation;\n  if (!formMethod || !formAction || !formEncType) {\n    return;\n  }\n  if (text != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json: undefined,\n      text\n    };\n  } else if (formData != null) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData,\n      json: undefined,\n      text: undefined\n    };\n  } else if (json !== undefined) {\n    return {\n      formMethod,\n      formAction,\n      formEncType,\n      formData: undefined,\n      json,\n      text: undefined\n    };\n  }\n}\nfunction getLoadingNavigation(location, submission) {\n  if (submission) {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text\n    };\n    return navigation;\n  } else {\n    let navigation = {\n      state: \"loading\",\n      location,\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined\n    };\n    return navigation;\n  }\n}\nfunction getSubmittingNavigation(location, submission) {\n  let navigation = {\n    state: \"submitting\",\n    location,\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text\n  };\n  return navigation;\n}\nfunction getLoadingFetcher(submission, data) {\n  if (submission) {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: submission.formMethod,\n      formAction: submission.formAction,\n      formEncType: submission.formEncType,\n      formData: submission.formData,\n      json: submission.json,\n      text: submission.text,\n      data\n    };\n    return fetcher;\n  } else {\n    let fetcher = {\n      state: \"loading\",\n      formMethod: undefined,\n      formAction: undefined,\n      formEncType: undefined,\n      formData: undefined,\n      json: undefined,\n      text: undefined,\n      data\n    };\n    return fetcher;\n  }\n}\nfunction getSubmittingFetcher(submission, existingFetcher) {\n  let fetcher = {\n    state: \"submitting\",\n    formMethod: submission.formMethod,\n    formAction: submission.formAction,\n    formEncType: submission.formEncType,\n    formData: submission.formData,\n    json: submission.json,\n    text: submission.text,\n    data: existingFetcher ? existingFetcher.data : undefined\n  };\n  return fetcher;\n}\nfunction getDoneFetcher(data) {\n  let fetcher = {\n    state: \"idle\",\n    formMethod: undefined,\n    formAction: undefined,\n    formEncType: undefined,\n    formData: undefined,\n    json: undefined,\n    text: undefined,\n    data\n  };\n  return fetcher;\n}\nfunction restoreAppliedTransitions(_window, transitions) {\n  try {\n    let sessionPositions = _window.sessionStorage.getItem(TRANSITIONS_STORAGE_KEY);\n    if (sessionPositions) {\n      let json = JSON.parse(sessionPositions);\n      for (let [k, v] of Object.entries(json || {})) {\n        if (v && Array.isArray(v)) {\n          transitions.set(k, new Set(v || []));\n        }\n      }\n    }\n  } catch (e) {\n    // no-op, use default empty object\n  }\n}\nfunction persistAppliedTransitions(_window, transitions) {\n  if (transitions.size > 0) {\n    let json = {};\n    for (let [k, v] of transitions) {\n      json[k] = [...v];\n    }\n    try {\n      _window.sessionStorage.setItem(TRANSITIONS_STORAGE_KEY, JSON.stringify(json));\n    } catch (error) {\n      warning(false, \"Failed to save applied view transitions in sessionStorage (\" + error + \").\");\n    }\n  }\n}\n//#endregion\n\nexport { AbortedDeferredError, Action, IDLE_BLOCKER, IDLE_FETCHER, IDLE_NAVIGATION, UNSAFE_DEFERRED_SYMBOL, DeferredData as UNSAFE_DeferredData, ErrorResponseImpl as UNSAFE_ErrorResponseImpl, convertRouteMatchToUiMatch as UNSAFE_convertRouteMatchToUiMatch, convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes, getResolveToMatches as UNSAFE_getResolveToMatches, invariant as UNSAFE_invariant, warning as UNSAFE_warning, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, createRouter, createStaticHandler, defer, generatePath, getStaticContextFromError, getToPathname, isDeferredData, isRouteErrorResponse, joinPaths, json, matchPath, matchRoutes, normalizePathname, parsePath, redirect, redirectDocument, resolvePath, resolveTo, stripBasename };\n//# sourceMappingURL=router.js.map\n","/**\n * React Router v6.20.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport { UNSAFE_invariant, joinPaths, matchPath, UNSAFE_getResolveToMatches, UNSAFE_warning, resolveTo, parsePath, matchRoutes, Action, UNSAFE_convertRouteMatchToUiMatch, stripBasename, IDLE_BLOCKER, isRouteErrorResponse, createMemoryHistory, AbortedDeferredError, createRouter } from '@remix-run/router';\nexport { AbortedDeferredError, Action as NavigationType, createPath, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, resolvePath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterContext.displayName = \"DataRouter\";\n}\nconst DataRouterStateContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  DataRouterStateContext.displayName = \"DataRouterState\";\n}\nconst AwaitContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  AwaitContext.displayName = \"Await\";\n}\n\n/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level `<Router>` API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */\n\nconst NavigationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\nconst LocationContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\nconst RouteContext = /*#__PURE__*/React.createContext({\n  outlet: null,\n  matches: [],\n  isDataRoute: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\nconst RouteErrorContext = /*#__PURE__*/React.createContext(null);\nif (process.env.NODE_ENV !== \"production\") {\n  RouteErrorContext.displayName = \"RouteError\";\n}\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */\nfunction useHref(to, _temp) {\n  let {\n    relative\n  } = _temp === void 0 ? {} : _temp;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to, {\n    relative\n  });\n  let joinedPathname = pathname;\n\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the href.  If this is a root navigation, then just use the raw\n  // basename which allows the basename to have full control over the presence\n  // of a trailing slash on root links\n  if (basename !== \"/\") {\n    joinedPathname = pathname === \"/\" ? basename : joinPaths([basename, pathname]);\n  }\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n\n/**\n * Returns true if this component is a descendant of a `<Router>`.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */\nfunction useInRouterContext() {\n  return React.useContext(LocationContext) != null;\n}\n\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  return React.useContext(LocationContext).location;\n}\n\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */\nfunction useNavigationType() {\n  return React.useContext(LocationContext).navigationType;\n}\n\n/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * `<NavLink>`.\n *\n * @see https://reactrouter.com/hooks/use-match\n */\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return React.useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\n\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\nconst navigateEffectWarning = \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\";\n\n// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb) {\n  let isStatic = React.useContext(NavigationContext).static;\n  if (!isStatic) {\n    // We should be able to get rid of this once react 18.3 is released\n    // See: https://github.com/facebook/react/pull/26395\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(cb);\n  }\n}\n\n/**\n * Returns an imperative method for changing the location. Used by `<Link>`s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */\nfunction useNavigate() {\n  let {\n    isDataRoute\n  } = React.useContext(RouteContext);\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  return isDataRoute ? useNavigateStable() : useNavigateUnstable();\n}\nfunction useNavigateUnstable() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let dataRouterContext = React.useContext(DataRouterContext);\n  let {\n    basename,\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches));\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our history listener yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, options.relative === \"path\");\n\n    // If we're operating within a basename, prepend it to the pathname prior\n    // to handing off to history (but only if we're not in a data router,\n    // otherwise it'll prepend the basename inside of the router).\n    // If this is a root navigation, then we navigate to the raw basename\n    // which allows the basename to have full control over the presence of a\n    // trailing slash on root links\n    if (dataRouterContext == null && basename !== \"/\") {\n      path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n    }\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state, options);\n  }, [basename, navigator, routePathnamesJson, locationPathname, dataRouterContext]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/React.createContext(null);\n\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */\nfunction useOutletContext() {\n  return React.useContext(OutletContext);\n}\n\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by `<Outlet>` to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */\nfunction useOutlet(context) {\n  let outlet = React.useContext(RouteContext).outlet;\n  if (outlet) {\n    return /*#__PURE__*/React.createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n  return outlet;\n}\n\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */\nfunction useParams() {\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */\nfunction useResolvedPath(to, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(UNSAFE_getResolveToMatches(matches));\n  return React.useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname, relative === \"path\"), [to, routePathnamesJson, locationPathname, relative]);\n}\n\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an `<Outlet>` to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */\nfunction useRoutes(routes, locationArg) {\n  return useRoutesImpl(routes, locationArg);\n}\n\n// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes, locationArg, dataRouterState) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  let {\n    navigator\n  } = React.useContext(NavigationContext);\n  let {\n    matches: parentMatches\n  } = React.useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n  let locationFromContext = useLocation();\n  let location;\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : UNSAFE_invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(matches == null || matches[matches.length - 1].route.element !== undefined || matches[matches.length - 1].route.Component !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \" + \"does not have an element or Component. This means it will render an <Outlet /> with a \" + \"null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n  let renderedMatches = _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathname).pathname : match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase,\n    // Re-encode pathnames that were decoded inside matchRoutes\n    navigator.encodeLocation ? navigator.encodeLocation(match.pathnameBase).pathname : match.pathnameBase])\n  })), parentMatches, dataRouterState);\n\n  // When a user passes in a `locationArg`, the associated routes need to\n  // be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n  // to use the scoped location instead of the global location.\n  if (locationArg && renderedMatches) {\n    return /*#__PURE__*/React.createElement(LocationContext.Provider, {\n      value: {\n        location: _extends({\n          pathname: \"/\",\n          search: \"\",\n          hash: \"\",\n          state: null,\n          key: \"default\"\n        }, location),\n        navigationType: Action.Pop\n      }\n    }, renderedMatches);\n  }\n  return renderedMatches;\n}\nfunction DefaultErrorComponent() {\n  let error = useRouteError();\n  let message = isRouteErrorResponse(error) ? error.status + \" \" + error.statusText : error instanceof Error ? error.message : JSON.stringify(error);\n  let stack = error instanceof Error ? error.stack : null;\n  let lightgrey = \"rgba(200,200,200, 0.5)\";\n  let preStyles = {\n    padding: \"0.5rem\",\n    backgroundColor: lightgrey\n  };\n  let codeStyles = {\n    padding: \"2px 4px\",\n    backgroundColor: lightgrey\n  };\n  let devInfo = null;\n  if (process.env.NODE_ENV !== \"production\") {\n    console.error(\"Error handled by React Router default ErrorBoundary:\", error);\n    devInfo = /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"p\", null, \"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"), /*#__PURE__*/React.createElement(\"p\", null, \"You can provide a way better UX than this when your app throws errors by providing your own \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"ErrorBoundary\"), \" or\", \" \", /*#__PURE__*/React.createElement(\"code\", {\n      style: codeStyles\n    }, \"errorElement\"), \" prop on your route.\"));\n  }\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(\"h2\", null, \"Unexpected Application Error!\"), /*#__PURE__*/React.createElement(\"h3\", {\n    style: {\n      fontStyle: \"italic\"\n    }\n  }, message), stack ? /*#__PURE__*/React.createElement(\"pre\", {\n    style: preStyles\n  }, stack) : null, devInfo);\n}\nconst defaultErrorElement = /*#__PURE__*/React.createElement(DefaultErrorComponent, null);\nclass RenderErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      location: props.location,\n      revalidation: props.revalidation,\n      error: props.error\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error: error\n    };\n  }\n  static getDerivedStateFromProps(props, state) {\n    // When we get into an error state, the user will likely click \"back\" to the\n    // previous page that didn't have an error. Because this wraps the entire\n    // application, that will have no effect--the error page continues to display.\n    // This gives us a mechanism to recover from the error when the location changes.\n    //\n    // Whether we're in an error state or not, we update the location in state\n    // so that when we are in an error state, it gets reset when a new location\n    // comes in and the user recovers from the error.\n    if (state.location !== props.location || state.revalidation !== \"idle\" && props.revalidation === \"idle\") {\n      return {\n        error: props.error,\n        location: props.location,\n        revalidation: props.revalidation\n      };\n    }\n\n    // If we're not changing locations, preserve the location but still surface\n    // any new errors that may come through. We retain the existing error, we do\n    // this because the error provided from the app state may be cleared without\n    // the location changing.\n    return {\n      error: props.error || state.error,\n      location: state.location,\n      revalidation: props.revalidation || state.revalidation\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"React Router caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    return this.state.error ? /*#__PURE__*/React.createElement(RouteContext.Provider, {\n      value: this.props.routeContext\n    }, /*#__PURE__*/React.createElement(RouteErrorContext.Provider, {\n      value: this.state.error,\n      children: this.props.component\n    })) : this.props.children;\n  }\n}\nfunction RenderedRoute(_ref) {\n  let {\n    routeContext,\n    match,\n    children\n  } = _ref;\n  let dataRouterContext = React.useContext(DataRouterContext);\n\n  // Track how deep we got in our render pass to emulate SSR componentDidCatch\n  // in a DataStaticRouter\n  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match.route.errorElement || match.route.ErrorBoundary)) {\n    dataRouterContext.staticContext._deepestRenderedBoundaryId = match.route.id;\n  }\n  return /*#__PURE__*/React.createElement(RouteContext.Provider, {\n    value: routeContext\n  }, children);\n}\nfunction _renderMatches(matches, parentMatches, dataRouterState) {\n  var _dataRouterState2;\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n  if (dataRouterState === void 0) {\n    dataRouterState = null;\n  }\n  if (matches == null) {\n    var _dataRouterState;\n    if ((_dataRouterState = dataRouterState) != null && _dataRouterState.errors) {\n      // Don't bail if we have data router errors so we can render them in the\n      // boundary.  Use the pre-matched (or shimmed) matches\n      matches = dataRouterState.matches;\n    } else {\n      return null;\n    }\n  }\n  let renderedMatches = matches;\n\n  // If we have data errors, trim matches to the highest error boundary\n  let errors = (_dataRouterState2 = dataRouterState) == null ? void 0 : _dataRouterState2.errors;\n  if (errors != null) {\n    let errorIndex = renderedMatches.findIndex(m => m.route.id && (errors == null ? void 0 : errors[m.route.id]));\n    !(errorIndex >= 0) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"Could not find a matching route for errors on route IDs: \" + Object.keys(errors).join(\",\")) : UNSAFE_invariant(false) : void 0;\n    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));\n  }\n  return renderedMatches.reduceRight((outlet, match, index) => {\n    let error = match.route.id ? errors == null ? void 0 : errors[match.route.id] : null;\n    // Only data routers handle errors\n    let errorElement = null;\n    if (dataRouterState) {\n      errorElement = match.route.errorElement || defaultErrorElement;\n    }\n    let matches = parentMatches.concat(renderedMatches.slice(0, index + 1));\n    let getChildren = () => {\n      let children;\n      if (error) {\n        children = errorElement;\n      } else if (match.route.Component) {\n        // Note: This is a de-optimized path since React won't re-use the\n        // ReactElement since it's identity changes with each new\n        // React.createElement call.  We keep this so folks can use\n        // `<Route Component={...}>` in `<Routes>` but generally `Component`\n        // usage is only advised in `RouterProvider` when we can convert it to\n        // `element` ahead of time.\n        children = /*#__PURE__*/React.createElement(match.route.Component, null);\n      } else if (match.route.element) {\n        children = match.route.element;\n      } else {\n        children = outlet;\n      }\n      return /*#__PURE__*/React.createElement(RenderedRoute, {\n        match: match,\n        routeContext: {\n          outlet,\n          matches,\n          isDataRoute: dataRouterState != null\n        },\n        children: children\n      });\n    };\n    // Only wrap in an error boundary within data router usages when we have an\n    // ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n    // an ancestor ErrorBoundary/errorElement\n    return dataRouterState && (match.route.ErrorBoundary || match.route.errorElement || index === 0) ? /*#__PURE__*/React.createElement(RenderErrorBoundary, {\n      location: dataRouterState.location,\n      revalidation: dataRouterState.revalidation,\n      component: errorElement,\n      error: error,\n      children: getChildren(),\n      routeContext: {\n        outlet: null,\n        matches,\n        isDataRoute: true\n      }\n    }) : getChildren();\n  }, null);\n}\nvar DataRouterHook = /*#__PURE__*/function (DataRouterHook) {\n  DataRouterHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterHook[\"UseNavigateStable\"] = \"useNavigate\";\n  return DataRouterHook;\n}(DataRouterHook || {});\nvar DataRouterStateHook = /*#__PURE__*/function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseBlocker\"] = \"useBlocker\";\n  DataRouterStateHook[\"UseLoaderData\"] = \"useLoaderData\";\n  DataRouterStateHook[\"UseActionData\"] = \"useActionData\";\n  DataRouterStateHook[\"UseRouteError\"] = \"useRouteError\";\n  DataRouterStateHook[\"UseNavigation\"] = \"useNavigation\";\n  DataRouterStateHook[\"UseRouteLoaderData\"] = \"useRouteLoaderData\";\n  DataRouterStateHook[\"UseMatches\"] = \"useMatches\";\n  DataRouterStateHook[\"UseRevalidator\"] = \"useRevalidator\";\n  DataRouterStateHook[\"UseNavigateStable\"] = \"useNavigate\";\n  DataRouterStateHook[\"UseRouteId\"] = \"useRouteId\";\n  return DataRouterStateHook;\n}(DataRouterStateHook || {});\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\nfunction useRouteContext(hookName) {\n  let route = React.useContext(RouteContext);\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return route;\n}\n\n// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName) {\n  let route = useRouteContext(hookName);\n  let thisRoute = route.matches[route.matches.length - 1];\n  !thisRoute.route.id ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, hookName + \" can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  return thisRoute.route.id;\n}\n\n/**\n * Returns the ID for the nearest contextual route\n */\nfunction useRouteId() {\n  return useCurrentRouteId(DataRouterStateHook.UseRouteId);\n}\n\n/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */\nfunction useNavigation() {\n  let state = useDataRouterState(DataRouterStateHook.UseNavigation);\n  return state.navigation;\n}\n\n/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */\nfunction useRevalidator() {\n  let dataRouterContext = useDataRouterContext(DataRouterHook.UseRevalidator);\n  let state = useDataRouterState(DataRouterStateHook.UseRevalidator);\n  return React.useMemo(() => ({\n    revalidate: dataRouterContext.router.revalidate,\n    state: state.revalidation\n  }), [dataRouterContext.router.revalidate, state.revalidation]);\n}\n\n/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */\nfunction useMatches() {\n  let {\n    matches,\n    loaderData\n  } = useDataRouterState(DataRouterStateHook.UseMatches);\n  return React.useMemo(() => matches.map(m => UNSAFE_convertRouteMatchToUiMatch(m, loaderData)), [matches, loaderData]);\n}\n\n/**\n * Returns the loader data for the nearest ancestor Route loader\n */\nfunction useLoaderData() {\n  let state = useDataRouterState(DataRouterStateHook.UseLoaderData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  if (state.errors && state.errors[routeId] != null) {\n    console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \" + routeId + \")\");\n    return undefined;\n  }\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the loaderData for the given routeId\n */\nfunction useRouteLoaderData(routeId) {\n  let state = useDataRouterState(DataRouterStateHook.UseRouteLoaderData);\n  return state.loaderData[routeId];\n}\n\n/**\n * Returns the action data for the nearest ancestor Route action\n */\nfunction useActionData() {\n  let state = useDataRouterState(DataRouterStateHook.UseActionData);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseLoaderData);\n  return state.actionData ? state.actionData[routeId] : undefined;\n}\n\n/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */\nfunction useRouteError() {\n  var _state$errors;\n  let error = React.useContext(RouteErrorContext);\n  let state = useDataRouterState(DataRouterStateHook.UseRouteError);\n  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);\n\n  // If this was a render error, we put it in a RouteError context inside\n  // of RenderErrorBoundary\n  if (error) {\n    return error;\n  }\n\n  // Otherwise look for errors from our data router state\n  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];\n}\n\n/**\n * Returns the happy-path data from the nearest ancestor `<Await />` value\n */\nfunction useAsyncValue() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._data;\n}\n\n/**\n * Returns the error from the nearest ancestor `<Await />` value\n */\nfunction useAsyncError() {\n  let value = React.useContext(AwaitContext);\n  return value == null ? void 0 : value._error;\n}\nlet blockerId = 0;\n\n/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */\nfunction useBlocker(shouldBlock) {\n  let {\n    router,\n    basename\n  } = useDataRouterContext(DataRouterHook.UseBlocker);\n  let state = useDataRouterState(DataRouterStateHook.UseBlocker);\n  let [blockerKey, setBlockerKey] = React.useState(\"\");\n  let blockerFunction = React.useCallback(arg => {\n    if (typeof shouldBlock !== \"function\") {\n      return !!shouldBlock;\n    }\n    if (basename === \"/\") {\n      return shouldBlock(arg);\n    }\n\n    // If they provided us a function and we've got an active basename, strip\n    // it from the locations we expose to the user to match the behavior of\n    // useLocation\n    let {\n      currentLocation,\n      nextLocation,\n      historyAction\n    } = arg;\n    return shouldBlock({\n      currentLocation: _extends({}, currentLocation, {\n        pathname: stripBasename(currentLocation.pathname, basename) || currentLocation.pathname\n      }),\n      nextLocation: _extends({}, nextLocation, {\n        pathname: stripBasename(nextLocation.pathname, basename) || nextLocation.pathname\n      }),\n      historyAction\n    });\n  }, [basename, shouldBlock]);\n\n  // This effect is in charge of blocker key assignment and deletion (which is\n  // tightly coupled to the key)\n  React.useEffect(() => {\n    let key = String(++blockerId);\n    setBlockerKey(key);\n    return () => router.deleteBlocker(key);\n  }, [router]);\n\n  // This effect handles assigning the blockerFunction.  This is to handle\n  // unstable blocker function identities, and happens only after the prior\n  // effect so we don't get an orphaned blockerFunction in the router with a\n  // key of \"\".  Until then we just have the IDLE_BLOCKER.\n  React.useEffect(() => {\n    if (blockerKey !== \"\") {\n      router.getBlocker(blockerKey, blockerFunction);\n    }\n  }, [router, blockerKey, blockerFunction]);\n\n  // Prefer the blocker from `state` not `router.state` since DataRouterContext\n  // is memoized so this ensures we update on blocker state updates\n  return blockerKey && state.blockers.has(blockerKey) ? state.blockers.get(blockerKey) : IDLE_BLOCKER;\n}\n\n/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */\nfunction useNavigateStable() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseNavigateStable);\n  let id = useCurrentRouteId(DataRouterStateHook.UseNavigateStable);\n  let activeRef = React.useRef(false);\n  useIsomorphicLayoutEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = React.useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(activeRef.current, navigateEffectWarning) : void 0;\n\n    // Short circuit here since if this happens on first render the navigate\n    // is useless because we haven't wired up our router subscriber yet\n    if (!activeRef.current) return;\n    if (typeof to === \"number\") {\n      router.navigate(to);\n    } else {\n      router.navigate(to, _extends({\n        fromRouteId: id\n      }, options));\n    }\n  }, [router, id]);\n  return navigate;\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, message) : void 0;\n  }\n}\n\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\n\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    if (v7_startTransition && startTransitionImpl) {\n      startTransitionImpl(() => setStateImpl(newState));\n    } else {\n      setStateImpl(newState);\n    }\n  }, [setStateImpl, v7_startTransition]);\n\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))), null);\n}\nfunction DataRoutes(_ref2) {\n  let {\n    routes,\n    state\n  } = _ref2;\n  return useRoutesImpl(routes, undefined, state);\n}\n/**\n * A `<Router>` that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */\nfunction MemoryRouter(_ref3) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex,\n    future\n  } = _ref3;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */\nfunction Navigate(_ref4) {\n  let {\n    to,\n    replace,\n    state,\n    relative\n  } = _ref4;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : UNSAFE_invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(!React.useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let {\n    matches\n  } = React.useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let navigate = useNavigate();\n\n  // Resolve the path outside of the effect so that when effects run twice in\n  // StrictMode they navigate to the same place\n  let path = resolveTo(to, UNSAFE_getResolveToMatches(matches), locationPathname, relative === \"path\");\n  let jsonPath = JSON.stringify(path);\n  React.useEffect(() => navigate(JSON.parse(jsonPath), {\n    replace,\n    state,\n    relative\n  }), [navigate, jsonPath, relative, replace, state]);\n  return null;\n}\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */\nfunction Route(_props) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : UNSAFE_invariant(false) ;\n}\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a `<Router>` directly. Instead, you'll render a\n * router that is more specific to your environment such as a `<BrowserRouter>`\n * in web browsers or a `<StaticRouter>` for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */\nfunction Router(_ref5) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref5;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : UNSAFE_invariant(false) : void 0;\n\n  // Preserve trailing slashes on basename, so we can let the user control\n  // the enforcement of trailing slashes throughout the app\n  let basename = basenameProp.replace(/^\\/*/, \"/\");\n  let navigationContext = React.useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let locationContext = React.useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n    if (trailingPathname == null) {\n      return null;\n    }\n    return {\n      location: {\n        pathname: trailingPathname,\n        search,\n        hash,\n        state,\n        key\n      },\n      navigationType\n    };\n  }, [basename, pathname, search, hash, state, key, navigationType]);\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(locationContext != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n  if (locationContext == null) {\n    return null;\n  }\n  return /*#__PURE__*/React.createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/React.createElement(LocationContext.Provider, {\n    children: children,\n    value: locationContext\n  }));\n}\n/**\n * A container for a nested tree of `<Route>` elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */\nfunction Routes(_ref6) {\n  let {\n    children,\n    location\n  } = _ref6;\n  return useRoutes(createRoutesFromChildren(children), location);\n}\n/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */\nfunction Await(_ref7) {\n  let {\n    children,\n    errorElement,\n    resolve\n  } = _ref7;\n  return /*#__PURE__*/React.createElement(AwaitErrorBoundary, {\n    resolve: resolve,\n    errorElement: errorElement\n  }, /*#__PURE__*/React.createElement(ResolveAwait, null, children));\n}\nvar AwaitRenderStatus = /*#__PURE__*/function (AwaitRenderStatus) {\n  AwaitRenderStatus[AwaitRenderStatus[\"pending\"] = 0] = \"pending\";\n  AwaitRenderStatus[AwaitRenderStatus[\"success\"] = 1] = \"success\";\n  AwaitRenderStatus[AwaitRenderStatus[\"error\"] = 2] = \"error\";\n  return AwaitRenderStatus;\n}(AwaitRenderStatus || {});\nconst neverSettledPromise = new Promise(() => {});\nclass AwaitErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      error: null\n    };\n  }\n  static getDerivedStateFromError(error) {\n    return {\n      error\n    };\n  }\n  componentDidCatch(error, errorInfo) {\n    console.error(\"<Await> caught the following error during render\", error, errorInfo);\n  }\n  render() {\n    let {\n      children,\n      errorElement,\n      resolve\n    } = this.props;\n    let promise = null;\n    let status = AwaitRenderStatus.pending;\n    if (!(resolve instanceof Promise)) {\n      // Didn't get a promise - provide as a resolved promise\n      status = AwaitRenderStatus.success;\n      promise = Promise.resolve();\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_data\", {\n        get: () => resolve\n      });\n    } else if (this.state.error) {\n      // Caught a render error, provide it as a rejected promise\n      status = AwaitRenderStatus.error;\n      let renderError = this.state.error;\n      promise = Promise.reject().catch(() => {}); // Avoid unhandled rejection warnings\n      Object.defineProperty(promise, \"_tracked\", {\n        get: () => true\n      });\n      Object.defineProperty(promise, \"_error\", {\n        get: () => renderError\n      });\n    } else if (resolve._tracked) {\n      // Already tracked promise - check contents\n      promise = resolve;\n      status = promise._error !== undefined ? AwaitRenderStatus.error : promise._data !== undefined ? AwaitRenderStatus.success : AwaitRenderStatus.pending;\n    } else {\n      // Raw (untracked) promise - track it\n      status = AwaitRenderStatus.pending;\n      Object.defineProperty(resolve, \"_tracked\", {\n        get: () => true\n      });\n      promise = resolve.then(data => Object.defineProperty(resolve, \"_data\", {\n        get: () => data\n      }), error => Object.defineProperty(resolve, \"_error\", {\n        get: () => error\n      }));\n    }\n    if (status === AwaitRenderStatus.error && promise._error instanceof AbortedDeferredError) {\n      // Freeze the UI by throwing a never resolved promise\n      throw neverSettledPromise;\n    }\n    if (status === AwaitRenderStatus.error && !errorElement) {\n      // No errorElement, throw to the nearest route-level error boundary\n      throw promise._error;\n    }\n    if (status === AwaitRenderStatus.error) {\n      // Render via our errorElement\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: errorElement\n      });\n    }\n    if (status === AwaitRenderStatus.success) {\n      // Render children with resolved value\n      return /*#__PURE__*/React.createElement(AwaitContext.Provider, {\n        value: promise,\n        children: children\n      });\n    }\n\n    // Throw to the suspense boundary\n    throw promise;\n  }\n}\n\n/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on `<Await>`\n */\nfunction ResolveAwait(_ref8) {\n  let {\n    children\n  } = _ref8;\n  let data = useAsyncValue();\n  let toRender = typeof children === \"function\" ? children(data) : children;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, toRender);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */\nfunction createRoutesFromChildren(children, parentPath) {\n  if (parentPath === void 0) {\n    parentPath = [];\n  }\n  let routes = [];\n  React.Children.forEach(children, (element, index) => {\n    if (! /*#__PURE__*/React.isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n    let treePath = [...parentPath, index];\n    if (element.type === React.Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));\n      return;\n    }\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : UNSAFE_invariant(false) : void 0;\n    !(!element.props.index || !element.props.children) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"An index route cannot have child routes.\") : UNSAFE_invariant(false) : void 0;\n    let route = {\n      id: element.props.id || treePath.join(\"-\"),\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      Component: element.props.Component,\n      index: element.props.index,\n      path: element.props.path,\n      loader: element.props.loader,\n      action: element.props.action,\n      errorElement: element.props.errorElement,\n      ErrorBoundary: element.props.ErrorBoundary,\n      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,\n      shouldRevalidate: element.props.shouldRevalidate,\n      handle: element.props.handle,\n      lazy: element.props.lazy\n    };\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children, treePath);\n    }\n    routes.push(route);\n  });\n  return routes;\n}\n\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\nfunction mapRouteProperties(route) {\n  let updates = {\n    // Note: this check also occurs in createRoutesFromChildren so update\n    // there if you change this -- please and thank you!\n    hasErrorBoundary: route.ErrorBoundary != null || route.errorElement != null\n  };\n  if (route.Component) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.element) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `Component` and `element` on your route - \" + \"`Component` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      element: /*#__PURE__*/React.createElement(route.Component),\n      Component: undefined\n    });\n  }\n  if (route.ErrorBoundary) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (route.errorElement) {\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"You should not include both `ErrorBoundary` and `errorElement` on your route - \" + \"`ErrorBoundary` will be used.\") : void 0;\n      }\n    }\n    Object.assign(updates, {\n      errorElement: /*#__PURE__*/React.createElement(route.ErrorBoundary),\n      ErrorBoundary: undefined\n    });\n  }\n  return updates;\n}\nfunction createMemoryRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createMemoryHistory({\n      initialEntries: opts == null ? void 0 : opts.initialEntries,\n      initialIndex: opts == null ? void 0 : opts.initialIndex\n    }),\n    hydrationData: opts == null ? void 0 : opts.hydrationData,\n    routes,\n    mapRouteProperties\n  }).initialize();\n}\n\nexport { Await, MemoryRouter, Navigate, Outlet, Route, Router, RouterProvider, Routes, DataRouterContext as UNSAFE_DataRouterContext, DataRouterStateContext as UNSAFE_DataRouterStateContext, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, mapRouteProperties as UNSAFE_mapRouteProperties, useRouteId as UNSAFE_useRouteId, useRoutesImpl as UNSAFE_useRoutesImpl, createMemoryRouter, createRoutesFromChildren, createRoutesFromChildren as createRoutesFromElements, renderMatches, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes };\n//# sourceMappingURL=index.js.map\n","/**\n * React Router DOM v6.20.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport { UNSAFE_mapRouteProperties, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, Router, UNSAFE_useRoutesImpl, UNSAFE_NavigationContext, useHref, useResolvedPath, useLocation, useNavigate, createPath, UNSAFE_useRouteId, UNSAFE_RouteContext, useMatches, useNavigation, useBlocker } from 'react-router';\nexport { AbortedDeferredError, Await, MemoryRouter, Navigate, NavigationType, Outlet, Route, Router, Routes, UNSAFE_DataRouterContext, UNSAFE_DataRouterStateContext, UNSAFE_LocationContext, UNSAFE_NavigationContext, UNSAFE_RouteContext, UNSAFE_useRouteId, createMemoryRouter, createPath, createRoutesFromChildren, createRoutesFromElements, defer, generatePath, isRouteErrorResponse, json, matchPath, matchRoutes, parsePath, redirect, redirectDocument, renderMatches, resolvePath, useActionData, useAsyncError, useAsyncValue, useBlocker, useHref, useInRouterContext, useLoaderData, useLocation, useMatch, useMatches, useNavigate, useNavigation, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRevalidator, useRouteError, useRouteLoaderData, useRoutes } from 'react-router';\nimport { stripBasename, UNSAFE_warning, createRouter, createBrowserHistory, createHashHistory, UNSAFE_ErrorResponseImpl, UNSAFE_invariant, joinPaths, IDLE_FETCHER, matchPath } from '@remix-run/router';\n\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n  return target;\n}\n\nconst defaultMethod = \"get\";\nconst defaultEncType = \"application/x-www-form-urlencoded\";\nfunction isHtmlElement(object) {\n  return object != null && typeof object.tagName === \"string\";\n}\nfunction isButtonElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"button\";\n}\nfunction isFormElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"form\";\n}\nfunction isInputElement(object) {\n  return isHtmlElement(object) && object.tagName.toLowerCase() === \"input\";\n}\nfunction isModifiedEvent(event) {\n  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);\n}\nfunction shouldProcessLinkClick(event, target) {\n  return event.button === 0 && (\n  // Ignore everything but left clicks\n  !target || target === \"_self\") &&\n  // Let browser handle \"target=_blank\" etc.\n  !isModifiedEvent(event) // Ignore clicks with modifier keys\n  ;\n}\n/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */\nfunction createSearchParams(init) {\n  if (init === void 0) {\n    init = \"\";\n  }\n  return new URLSearchParams(typeof init === \"string\" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo, key) => {\n    let value = init[key];\n    return memo.concat(Array.isArray(value) ? value.map(v => [key, v]) : [[key, value]]);\n  }, []));\n}\nfunction getSearchParamsForLocation(locationSearch, defaultSearchParams) {\n  let searchParams = createSearchParams(locationSearch);\n  if (defaultSearchParams) {\n    // Use `defaultSearchParams.forEach(...)` here instead of iterating of\n    // `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n    // web extensions. Relevant Bugzilla tickets:\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\n    defaultSearchParams.forEach((_, key) => {\n      if (!searchParams.has(key)) {\n        defaultSearchParams.getAll(key).forEach(value => {\n          searchParams.append(key, value);\n        });\n      }\n    });\n  }\n  return searchParams;\n}\n// One-time check for submitter support\nlet _formDataSupportsSubmitter = null;\nfunction isFormDataSubmitterSupported() {\n  if (_formDataSupportsSubmitter === null) {\n    try {\n      new FormData(document.createElement(\"form\"),\n      // @ts-expect-error if FormData supports the submitter parameter, this will throw\n      0);\n      _formDataSupportsSubmitter = false;\n    } catch (e) {\n      _formDataSupportsSubmitter = true;\n    }\n  }\n  return _formDataSupportsSubmitter;\n}\nconst supportedFormEncTypes = new Set([\"application/x-www-form-urlencoded\", \"multipart/form-data\", \"text/plain\"]);\nfunction getFormEncType(encType) {\n  if (encType != null && !supportedFormEncTypes.has(encType)) {\n    process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"\\\"\" + encType + \"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \" + (\"and will default to \\\"\" + defaultEncType + \"\\\"\")) : void 0;\n    return null;\n  }\n  return encType;\n}\nfunction getFormSubmissionInfo(target, basename) {\n  let method;\n  let action;\n  let encType;\n  let formData;\n  let body;\n  if (isFormElement(target)) {\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"enctype\")) || defaultEncType;\n    formData = new FormData(target);\n  } else if (isButtonElement(target) || isInputElement(target) && (target.type === \"submit\" || target.type === \"image\")) {\n    let form = target.form;\n    if (form == null) {\n      throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");\n    }\n    // <button>/<input type=\"submit\"> may override attributes of <form>\n    // When grabbing the action from the element, it will have had the basename\n    // prefixed to ensure non-JS scenarios work, so strip it since we'll\n    // re-prefix in the router\n    let attr = target.getAttribute(\"formaction\") || form.getAttribute(\"action\");\n    action = attr ? stripBasename(attr, basename) : null;\n    method = target.getAttribute(\"formmethod\") || form.getAttribute(\"method\") || defaultMethod;\n    encType = getFormEncType(target.getAttribute(\"formenctype\")) || getFormEncType(form.getAttribute(\"enctype\")) || defaultEncType;\n    // Build a FormData object populated from a form and submitter\n    formData = new FormData(form, target);\n    // If this browser doesn't support the `FormData(el, submitter)` format,\n    // then tack on the submitter value at the end.  This is a lightweight\n    // solution that is not 100% spec compliant.  For complete support in older\n    // browsers, consider using the `formdata-submitter-polyfill` package\n    if (!isFormDataSubmitterSupported()) {\n      let {\n        name,\n        type,\n        value\n      } = target;\n      if (type === \"image\") {\n        let prefix = name ? name + \".\" : \"\";\n        formData.append(prefix + \"x\", \"0\");\n        formData.append(prefix + \"y\", \"0\");\n      } else if (name) {\n        formData.append(name, value);\n      }\n    }\n  } else if (isHtmlElement(target)) {\n    throw new Error(\"Cannot submit element that is not <form>, <button>, or \" + \"<input type=\\\"submit|image\\\">\");\n  } else {\n    method = defaultMethod;\n    action = null;\n    encType = defaultEncType;\n    body = target;\n  }\n  // Send body for <Form encType=\"text/plain\" so we encode it into text\n  if (formData && encType === \"text/plain\") {\n    body = formData;\n    formData = undefined;\n  }\n  return {\n    action,\n    method: method.toLowerCase(),\n    encType,\n    formData,\n    body\n  };\n}\n\nconst _excluded = [\"onClick\", \"relative\", \"reloadDocument\", \"replace\", \"state\", \"target\", \"to\", \"preventScrollReset\", \"unstable_viewTransition\"],\n  _excluded2 = [\"aria-current\", \"caseSensitive\", \"className\", \"end\", \"style\", \"to\", \"unstable_viewTransition\", \"children\"],\n  _excluded3 = [\"fetcherKey\", \"navigate\", \"reloadDocument\", \"replace\", \"state\", \"method\", \"action\", \"onSubmit\", \"relative\", \"preventScrollReset\", \"unstable_viewTransition\"];\nfunction createBrowserRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createBrowserHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction createHashRouter(routes, opts) {\n  return createRouter({\n    basename: opts == null ? void 0 : opts.basename,\n    future: _extends({}, opts == null ? void 0 : opts.future, {\n      v7_prependBasename: true\n    }),\n    history: createHashHistory({\n      window: opts == null ? void 0 : opts.window\n    }),\n    hydrationData: (opts == null ? void 0 : opts.hydrationData) || parseHydrationData(),\n    routes,\n    mapRouteProperties: UNSAFE_mapRouteProperties,\n    window: opts == null ? void 0 : opts.window\n  }).initialize();\n}\nfunction parseHydrationData() {\n  var _window;\n  let state = (_window = window) == null ? void 0 : _window.__staticRouterHydrationData;\n  if (state && state.errors) {\n    state = _extends({}, state, {\n      errors: deserializeErrors(state.errors)\n    });\n  }\n  return state;\n}\nfunction deserializeErrors(errors) {\n  if (!errors) return null;\n  let entries = Object.entries(errors);\n  let serialized = {};\n  for (let [key, val] of entries) {\n    // Hey you!  If you change this, please change the corresponding logic in\n    // serializeErrors in react-router-dom/server.tsx :)\n    if (val && val.__type === \"RouteErrorResponse\") {\n      serialized[key] = new UNSAFE_ErrorResponseImpl(val.status, val.statusText, val.data, val.internal === true);\n    } else if (val && val.__type === \"Error\") {\n      // Attempt to reconstruct the right type of Error (i.e., ReferenceError)\n      if (val.__subType) {\n        let ErrorConstructor = window[val.__subType];\n        if (typeof ErrorConstructor === \"function\") {\n          try {\n            // @ts-expect-error\n            let error = new ErrorConstructor(val.message);\n            // Wipe away the client-side stack trace.  Nothing to fill it in with\n            // because we don't serialize SSR stack traces for security reasons\n            error.stack = \"\";\n            serialized[key] = error;\n          } catch (e) {\n            // no-op - fall through and create a normal Error\n          }\n        }\n      }\n      if (serialized[key] == null) {\n        let error = new Error(val.message);\n        // Wipe away the client-side stack trace.  Nothing to fill it in with\n        // because we don't serialize SSR stack traces for security reasons\n        error.stack = \"\";\n        serialized[key] = error;\n      }\n    } else {\n      serialized[key] = val;\n    }\n  }\n  return serialized;\n}\nconst ViewTransitionContext = /*#__PURE__*/React.createContext({\n  isTransitioning: false\n});\nif (process.env.NODE_ENV !== \"production\") {\n  ViewTransitionContext.displayName = \"ViewTransition\";\n}\nconst FetchersContext = /*#__PURE__*/React.createContext(new Map());\nif (process.env.NODE_ENV !== \"production\") {\n  FetchersContext.displayName = \"Fetchers\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/\nconst START_TRANSITION = \"startTransition\";\nconst startTransitionImpl = React[START_TRANSITION];\nconst FLUSH_SYNC = \"flushSync\";\nconst flushSyncImpl = ReactDOM[FLUSH_SYNC];\nfunction startTransitionSafe(cb) {\n  if (startTransitionImpl) {\n    startTransitionImpl(cb);\n  } else {\n    cb();\n  }\n}\nfunction flushSyncSafe(cb) {\n  if (flushSyncImpl) {\n    flushSyncImpl(cb);\n  } else {\n    cb();\n  }\n}\nclass Deferred {\n  constructor() {\n    this.status = \"pending\";\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = value => {\n        if (this.status === \"pending\") {\n          this.status = \"resolved\";\n          resolve(value);\n        }\n      };\n      this.reject = reason => {\n        if (this.status === \"pending\") {\n          this.status = \"rejected\";\n          reject(reason);\n        }\n      };\n    });\n  }\n}\n/**\n * Given a Remix Router instance, render the appropriate UI\n */\nfunction RouterProvider(_ref) {\n  let {\n    fallbackElement,\n    router,\n    future\n  } = _ref;\n  let [state, setStateImpl] = React.useState(router.state);\n  let [pendingState, setPendingState] = React.useState();\n  let [vtContext, setVtContext] = React.useState({\n    isTransitioning: false\n  });\n  let [renderDfd, setRenderDfd] = React.useState();\n  let [transition, setTransition] = React.useState();\n  let [interruption, setInterruption] = React.useState();\n  let fetcherData = React.useRef(new Map());\n  let {\n    v7_startTransition\n  } = future || {};\n  let optInStartTransition = React.useCallback(cb => {\n    if (v7_startTransition) {\n      startTransitionSafe(cb);\n    } else {\n      cb();\n    }\n  }, [v7_startTransition]);\n  let setState = React.useCallback((newState, _ref2) => {\n    let {\n      deletedFetchers,\n      unstable_flushSync: flushSync,\n      unstable_viewTransitionOpts: viewTransitionOpts\n    } = _ref2;\n    deletedFetchers.forEach(key => fetcherData.current.delete(key));\n    newState.fetchers.forEach((fetcher, key) => {\n      if (fetcher.data !== undefined) {\n        fetcherData.current.set(key, fetcher.data);\n      }\n    });\n    let isViewTransitionUnavailable = router.window == null || typeof router.window.document.startViewTransition !== \"function\";\n    // If this isn't a view transition or it's not available in this browser,\n    // just update and be done with it\n    if (!viewTransitionOpts || isViewTransitionUnavailable) {\n      if (flushSync) {\n        flushSyncSafe(() => setStateImpl(newState));\n      } else {\n        optInStartTransition(() => setStateImpl(newState));\n      }\n      return;\n    }\n    // flushSync + startViewTransition\n    if (flushSync) {\n      // Flush through the context to mark DOM elements as transition=ing\n      flushSyncSafe(() => {\n        // Cancel any pending transitions\n        if (transition) {\n          renderDfd && renderDfd.resolve();\n          transition.skipTransition();\n        }\n        setVtContext({\n          isTransitioning: true,\n          flushSync: true,\n          currentLocation: viewTransitionOpts.currentLocation,\n          nextLocation: viewTransitionOpts.nextLocation\n        });\n      });\n      // Update the DOM\n      let t = router.window.document.startViewTransition(() => {\n        flushSyncSafe(() => setStateImpl(newState));\n      });\n      // Clean up after the animation completes\n      t.finished.finally(() => {\n        flushSyncSafe(() => {\n          setRenderDfd(undefined);\n          setTransition(undefined);\n          setPendingState(undefined);\n          setVtContext({\n            isTransitioning: false\n          });\n        });\n      });\n      flushSyncSafe(() => setTransition(t));\n      return;\n    }\n    // startTransition + startViewTransition\n    if (transition) {\n      // Interrupting an in-progress transition, cancel and let everything flush\n      // out, and then kick off a new transition from the interruption state\n      renderDfd && renderDfd.resolve();\n      transition.skipTransition();\n      setInterruption({\n        state: newState,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    } else {\n      // Completed navigation update with opted-in view transitions, let 'er rip\n      setPendingState(newState);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: viewTransitionOpts.currentLocation,\n        nextLocation: viewTransitionOpts.nextLocation\n      });\n    }\n  }, [router.window, transition, renderDfd, fetcherData, optInStartTransition]);\n  // Need to use a layout effect here so we are subscribed early enough to\n  // pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\n  React.useLayoutEffect(() => router.subscribe(setState), [router, setState]);\n  // When we start a view transition, create a Deferred we can use for the\n  // eventual \"completed\" render\n  React.useEffect(() => {\n    if (vtContext.isTransitioning && !vtContext.flushSync) {\n      setRenderDfd(new Deferred());\n    }\n  }, [vtContext]);\n  // Once the deferred is created, kick off startViewTransition() to update the\n  // DOM and then wait on the Deferred to resolve (indicating the DOM update has\n  // happened)\n  React.useEffect(() => {\n    if (renderDfd && pendingState && router.window) {\n      let newState = pendingState;\n      let renderPromise = renderDfd.promise;\n      let transition = router.window.document.startViewTransition(async () => {\n        optInStartTransition(() => setStateImpl(newState));\n        await renderPromise;\n      });\n      transition.finished.finally(() => {\n        setRenderDfd(undefined);\n        setTransition(undefined);\n        setPendingState(undefined);\n        setVtContext({\n          isTransitioning: false\n        });\n      });\n      setTransition(transition);\n    }\n  }, [optInStartTransition, pendingState, renderDfd, router.window]);\n  // When the new location finally renders and is committed to the DOM, this\n  // effect will run to resolve the transition\n  React.useEffect(() => {\n    if (renderDfd && pendingState && state.location.key === pendingState.location.key) {\n      renderDfd.resolve();\n    }\n  }, [renderDfd, transition, state.location, pendingState]);\n  // If we get interrupted with a new navigation during a transition, we skip\n  // the active transition, let it cleanup, then kick it off again here\n  React.useEffect(() => {\n    if (!vtContext.isTransitioning && interruption) {\n      setPendingState(interruption.state);\n      setVtContext({\n        isTransitioning: true,\n        flushSync: false,\n        currentLocation: interruption.currentLocation,\n        nextLocation: interruption.nextLocation\n      });\n      setInterruption(undefined);\n    }\n  }, [vtContext.isTransitioning, interruption]);\n  let navigator = React.useMemo(() => {\n    return {\n      createHref: router.createHref,\n      encodeLocation: router.encodeLocation,\n      go: n => router.navigate(n),\n      push: (to, state, opts) => router.navigate(to, {\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      }),\n      replace: (to, state, opts) => router.navigate(to, {\n        replace: true,\n        state,\n        preventScrollReset: opts == null ? void 0 : opts.preventScrollReset\n      })\n    };\n  }, [router]);\n  let basename = router.basename || \"/\";\n  let dataRouterContext = React.useMemo(() => ({\n    router,\n    navigator,\n    static: false,\n    basename\n  }), [router, navigator, basename]);\n  // The fragment and {null} here are important!  We need them to keep React 18's\n  // useId happy when we are server-rendering since we may have a <script> here\n  // containing the hydrated server-side staticContext (from StaticRouterProvider).\n  // useId relies on the component tree structure to generate deterministic id's\n  // so we need to ensure it remains the same on the client even though\n  // we don't need the <script> tag\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(UNSAFE_DataRouterContext.Provider, {\n    value: dataRouterContext\n  }, /*#__PURE__*/React.createElement(UNSAFE_DataRouterStateContext.Provider, {\n    value: state\n  }, /*#__PURE__*/React.createElement(FetchersContext.Provider, {\n    value: fetcherData.current\n  }, /*#__PURE__*/React.createElement(ViewTransitionContext.Provider, {\n    value: vtContext\n  }, /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    location: state.location,\n    navigationType: state.historyAction,\n    navigator: navigator\n  }, state.initialized ? /*#__PURE__*/React.createElement(DataRoutes, {\n    routes: router.routes,\n    state: state\n  }) : fallbackElement))))), null);\n}\nfunction DataRoutes(_ref3) {\n  let {\n    routes,\n    state\n  } = _ref3;\n  return UNSAFE_useRoutesImpl(routes, undefined, state);\n}\n/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */\nfunction BrowserRouter(_ref4) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref4;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createBrowserHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */\nfunction HashRouter(_ref5) {\n  let {\n    basename,\n    children,\n    future,\n    window\n  } = _ref5;\n  let historyRef = React.useRef();\n  if (historyRef.current == null) {\n    historyRef.current = createHashHistory({\n      window,\n      v5Compat: true\n    });\n  }\n  let history = historyRef.current;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */\nfunction HistoryRouter(_ref6) {\n  let {\n    basename,\n    children,\n    future,\n    history\n  } = _ref6;\n  let [state, setStateImpl] = React.useState({\n    action: history.action,\n    location: history.location\n  });\n  let {\n    v7_startTransition\n  } = future || {};\n  let setState = React.useCallback(newState => {\n    v7_startTransition && startTransitionImpl ? startTransitionImpl(() => setStateImpl(newState)) : setStateImpl(newState);\n  }, [setStateImpl, v7_startTransition]);\n  React.useLayoutEffect(() => history.listen(setState), [history, setState]);\n  return /*#__PURE__*/React.createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\nif (process.env.NODE_ENV !== \"production\") {\n  HistoryRouter.displayName = \"unstable_HistoryRouter\";\n}\nconst isBrowser = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" && typeof window.document.createElement !== \"undefined\";\nconst ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;\n/**\n * The public API for rendering a history-aware `<a>`.\n */\nconst Link = /*#__PURE__*/React.forwardRef(function LinkWithRef(_ref7, ref) {\n  let {\n      onClick,\n      relative,\n      reloadDocument,\n      replace,\n      state,\n      target,\n      to,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref7,\n    rest = _objectWithoutPropertiesLoose(_ref7, _excluded);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  // Rendered into <a href> for absolute URLs\n  let absoluteHref;\n  let isExternal = false;\n  if (typeof to === \"string\" && ABSOLUTE_URL_REGEX.test(to)) {\n    // Render the absolute href server- and client-side\n    absoluteHref = to;\n    // Only check for external origins client-side\n    if (isBrowser) {\n      try {\n        let currentUrl = new URL(window.location.href);\n        let targetUrl = to.startsWith(\"//\") ? new URL(currentUrl.protocol + to) : new URL(to);\n        let path = stripBasename(targetUrl.pathname, basename);\n        if (targetUrl.origin === currentUrl.origin && path != null) {\n          // Strip the protocol/origin/basename for same-origin absolute URLs\n          to = path + targetUrl.search + targetUrl.hash;\n        } else {\n          isExternal = true;\n        }\n      } catch (e) {\n        // We can't do external URL detection without a valid URL\n        process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"<Link to=\\\"\" + to + \"\\\"> contains an invalid URL which will probably break \" + \"when clicked - please update to a valid URL path.\") : void 0;\n      }\n    }\n  }\n  // Rendered into <a href> for relative URLs\n  let href = useHref(to, {\n    relative\n  });\n  let internalOnClick = useLinkClickHandler(to, {\n    replace,\n    state,\n    target,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  });\n  function handleClick(event) {\n    if (onClick) onClick(event);\n    if (!event.defaultPrevented) {\n      internalOnClick(event);\n    }\n  }\n  return (\n    /*#__PURE__*/\n    // eslint-disable-next-line jsx-a11y/anchor-has-content\n    React.createElement(\"a\", _extends({}, rest, {\n      href: absoluteHref || href,\n      onClick: isExternal || reloadDocument ? onClick : handleClick,\n      ref: ref,\n      target: target\n    }))\n  );\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Link.displayName = \"Link\";\n}\n/**\n * A `<Link>` wrapper that knows if it's \"active\" or not.\n */\nconst NavLink = /*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref8, ref) {\n  let {\n      \"aria-current\": ariaCurrentProp = \"page\",\n      caseSensitive = false,\n      className: classNameProp = \"\",\n      end = false,\n      style: styleProp,\n      to,\n      unstable_viewTransition,\n      children\n    } = _ref8,\n    rest = _objectWithoutPropertiesLoose(_ref8, _excluded2);\n  let path = useResolvedPath(to, {\n    relative: rest.relative\n  });\n  let location = useLocation();\n  let routerState = React.useContext(UNSAFE_DataRouterStateContext);\n  let {\n    navigator\n  } = React.useContext(UNSAFE_NavigationContext);\n  let isTransitioning = routerState != null &&\n  // Conditional usage is OK here because the usage of a data router is static\n  // eslint-disable-next-line react-hooks/rules-of-hooks\n  useViewTransitionState(path) && unstable_viewTransition === true;\n  let toPathname = navigator.encodeLocation ? navigator.encodeLocation(path).pathname : path.pathname;\n  let locationPathname = location.pathname;\n  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;\n  if (!caseSensitive) {\n    locationPathname = locationPathname.toLowerCase();\n    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;\n    toPathname = toPathname.toLowerCase();\n  }\n  // If the `to` has a trailing slash, look at that exact spot.  Otherwise,\n  // we're looking for a slash _after_ what's in `to`.  For example:\n  //\n  // <NavLink to=\"/users\"> and <NavLink to=\"/users/\">\n  // both want to look for a / at index 6 to match URL `/users/matt`\n  const endSlashPosition = toPathname !== \"/\" && toPathname.endsWith(\"/\") ? toPathname.length - 1 : toPathname.length;\n  let isActive = locationPathname === toPathname || !end && locationPathname.startsWith(toPathname) && locationPathname.charAt(endSlashPosition) === \"/\";\n  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === \"/\");\n  let renderProps = {\n    isActive,\n    isPending,\n    isTransitioning\n  };\n  let ariaCurrent = isActive ? ariaCurrentProp : undefined;\n  let className;\n  if (typeof classNameProp === \"function\") {\n    className = classNameProp(renderProps);\n  } else {\n    // If the className prop is not a function, we use a default `active`\n    // class for <NavLink />s that are active. In v5 `active` was the default\n    // value for `activeClassName`, but we are removing that API and can still\n    // use the old default behavior for a cleaner upgrade path and keep the\n    // simple styling rules working as they currently do.\n    className = [classNameProp, isActive ? \"active\" : null, isPending ? \"pending\" : null, isTransitioning ? \"transitioning\" : null].filter(Boolean).join(\" \");\n  }\n  let style = typeof styleProp === \"function\" ? styleProp(renderProps) : styleProp;\n  return /*#__PURE__*/React.createElement(Link, _extends({}, rest, {\n    \"aria-current\": ariaCurrent,\n    className: className,\n    ref: ref,\n    style: style,\n    to: to,\n    unstable_viewTransition: unstable_viewTransition\n  }), typeof children === \"function\" ? children(renderProps) : children);\n});\nif (process.env.NODE_ENV !== \"production\") {\n  NavLink.displayName = \"NavLink\";\n}\n/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */\nconst Form = /*#__PURE__*/React.forwardRef((_ref9, forwardedRef) => {\n  let {\n      fetcherKey,\n      navigate,\n      reloadDocument,\n      replace,\n      state,\n      method = defaultMethod,\n      action,\n      onSubmit,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    } = _ref9,\n    props = _objectWithoutPropertiesLoose(_ref9, _excluded3);\n  let submit = useSubmit();\n  let formAction = useFormAction(action, {\n    relative\n  });\n  let formMethod = method.toLowerCase() === \"get\" ? \"get\" : \"post\";\n  let submitHandler = event => {\n    onSubmit && onSubmit(event);\n    if (event.defaultPrevented) return;\n    event.preventDefault();\n    let submitter = event.nativeEvent.submitter;\n    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute(\"formmethod\")) || method;\n    submit(submitter || event.currentTarget, {\n      fetcherKey,\n      method: submitMethod,\n      navigate,\n      replace,\n      state,\n      relative,\n      preventScrollReset,\n      unstable_viewTransition\n    });\n  };\n  return /*#__PURE__*/React.createElement(\"form\", _extends({\n    ref: forwardedRef,\n    method: formMethod,\n    action: formAction,\n    onSubmit: reloadDocument ? onSubmit : submitHandler\n  }, props));\n});\nif (process.env.NODE_ENV !== \"production\") {\n  Form.displayName = \"Form\";\n}\n/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */\nfunction ScrollRestoration(_ref10) {\n  let {\n    getKey,\n    storageKey\n  } = _ref10;\n  useScrollRestoration({\n    getKey,\n    storageKey\n  });\n  return null;\n}\nif (process.env.NODE_ENV !== \"production\") {\n  ScrollRestoration.displayName = \"ScrollRestoration\";\n}\n//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;\n(function (DataRouterHook) {\n  DataRouterHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n  DataRouterHook[\"UseSubmit\"] = \"useSubmit\";\n  DataRouterHook[\"UseSubmitFetcher\"] = \"useSubmitFetcher\";\n  DataRouterHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterHook[\"useViewTransitionState\"] = \"useViewTransitionState\";\n})(DataRouterHook || (DataRouterHook = {}));\nvar DataRouterStateHook;\n(function (DataRouterStateHook) {\n  DataRouterStateHook[\"UseFetcher\"] = \"useFetcher\";\n  DataRouterStateHook[\"UseFetchers\"] = \"useFetchers\";\n  DataRouterStateHook[\"UseScrollRestoration\"] = \"useScrollRestoration\";\n})(DataRouterStateHook || (DataRouterStateHook = {}));\n// Internal hooks\nfunction getDataRouterConsoleError(hookName) {\n  return hookName + \" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";\n}\nfunction useDataRouterContext(hookName) {\n  let ctx = React.useContext(UNSAFE_DataRouterContext);\n  !ctx ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return ctx;\n}\nfunction useDataRouterState(hookName) {\n  let state = React.useContext(UNSAFE_DataRouterStateContext);\n  !state ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, getDataRouterConsoleError(hookName)) : UNSAFE_invariant(false) : void 0;\n  return state;\n}\n// External hooks\n/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */\nfunction useLinkClickHandler(to, _temp) {\n  let {\n    target,\n    replace: replaceProp,\n    state,\n    preventScrollReset,\n    relative,\n    unstable_viewTransition\n  } = _temp === void 0 ? {} : _temp;\n  let navigate = useNavigate();\n  let location = useLocation();\n  let path = useResolvedPath(to, {\n    relative\n  });\n  return React.useCallback(event => {\n    if (shouldProcessLinkClick(event, target)) {\n      event.preventDefault();\n      // If the URL hasn't changed, a regular <a> will do a replace instead of\n      // a push, so do the same here unless the replace prop is explicitly set\n      let replace = replaceProp !== undefined ? replaceProp : createPath(location) === createPath(path);\n      navigate(to, {\n        replace,\n        state,\n        preventScrollReset,\n        relative,\n        unstable_viewTransition\n      });\n    }\n  }, [location, navigate, path, replaceProp, state, target, to, preventScrollReset, relative, unstable_viewTransition]);\n}\n/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */\nfunction useSearchParams(defaultInit) {\n  process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(typeof URLSearchParams !== \"undefined\", \"You cannot use the `useSearchParams` hook in a browser that does not \" + \"support the URLSearchParams API. If you need to support Internet \" + \"Explorer 11, we recommend you load a polyfill such as \" + \"https://github.com/ungap/url-search-params\\n\\n\" + \"If you're unsure how to load polyfills, we recommend you check out \" + \"https://polyfill.io/v3/ which provides some recommendations about how \" + \"to load polyfills only for users that need them, instead of for every \" + \"user.\") : void 0;\n  let defaultSearchParamsRef = React.useRef(createSearchParams(defaultInit));\n  let hasSetSearchParamsRef = React.useRef(false);\n  let location = useLocation();\n  let searchParams = React.useMemo(() =>\n  // Only merge in the defaults if we haven't yet called setSearchParams.\n  // Once we call that we want those to take precedence, otherwise you can't\n  // remove a param with setSearchParams({}) if it has an initial value\n  getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current), [location.search]);\n  let navigate = useNavigate();\n  let setSearchParams = React.useCallback((nextInit, navigateOptions) => {\n    const newSearchParams = createSearchParams(typeof nextInit === \"function\" ? nextInit(searchParams) : nextInit);\n    hasSetSearchParamsRef.current = true;\n    navigate(\"?\" + newSearchParams, navigateOptions);\n  }, [navigate, searchParams]);\n  return [searchParams, setSearchParams];\n}\nfunction validateClientSideSubmission() {\n  if (typeof document === \"undefined\") {\n    throw new Error(\"You are calling submit during the server render. \" + \"Try calling submit within a `useEffect` or callback instead.\");\n  }\n}\nlet fetcherId = 0;\nlet getUniqueFetcherId = () => \"__\" + String(++fetcherId) + \"__\";\n/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */\nfunction useSubmit() {\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseSubmit);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let currentRouteId = UNSAFE_useRouteId();\n  return React.useCallback(function (target, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    validateClientSideSubmission();\n    let {\n      action,\n      method,\n      encType,\n      formData,\n      body\n    } = getFormSubmissionInfo(target, basename);\n    if (options.navigate === false) {\n      let key = options.fetcherKey || getUniqueFetcherId();\n      router.fetch(key, currentRouteId, options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        unstable_flushSync: options.unstable_flushSync\n      });\n    } else {\n      router.navigate(options.action || action, {\n        preventScrollReset: options.preventScrollReset,\n        formData,\n        body,\n        formMethod: options.method || method,\n        formEncType: options.encType || encType,\n        replace: options.replace,\n        state: options.state,\n        fromRouteId: currentRouteId,\n        unstable_flushSync: options.unstable_flushSync,\n        unstable_viewTransition: options.unstable_viewTransition\n      });\n    }\n  }, [router, basename, currentRouteId]);\n}\n// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action, _temp2) {\n  let {\n    relative\n  } = _temp2 === void 0 ? {} : _temp2;\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let routeContext = React.useContext(UNSAFE_RouteContext);\n  !routeContext ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFormAction must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  let [match] = routeContext.matches.slice(-1);\n  // Shallow clone path so we can modify it below, otherwise we modify the\n  // object referenced by useMemo inside useResolvedPath\n  let path = _extends({}, useResolvedPath(action ? action : \".\", {\n    relative\n  }));\n  // If no action was specified, browsers will persist current search params\n  // when determining the path, so match that behavior\n  // https://github.com/remix-run/remix/issues/927\n  let location = useLocation();\n  if (action == null) {\n    // Safe to write to this directly here since if action was undefined, we\n    // would have called useResolvedPath(\".\") which will never include a search\n    path.search = location.search;\n    // When grabbing search params from the URL, remove any included ?index param\n    // since it might not apply to our contextual route.  We add it back based\n    // on match.route.index below\n    let params = new URLSearchParams(path.search);\n    if (params.has(\"index\") && params.get(\"index\") === \"\") {\n      params.delete(\"index\");\n      path.search = params.toString() ? \"?\" + params.toString() : \"\";\n    }\n  }\n  if ((!action || action === \".\") && match.route.index) {\n    path.search = path.search ? path.search.replace(/^\\?/, \"?index&\") : \"?index\";\n  }\n  // If we're operating within a basename, prepend it to the pathname prior\n  // to creating the form action.  If this is a root navigation, then just use\n  // the raw basename which allows the basename to have full control over the\n  // presence of a trailing slash on root actions\n  if (basename !== \"/\") {\n    path.pathname = path.pathname === \"/\" ? basename : joinPaths([basename, path.pathname]);\n  }\n  return createPath(path);\n}\n// TODO: (v7) Change the useFetcher generic default from `any` to `unknown`\n/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */\nfunction useFetcher(_temp3) {\n  var _route$matches;\n  let {\n    key\n  } = _temp3 === void 0 ? {} : _temp3;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseFetcher);\n  let state = useDataRouterState(DataRouterStateHook.UseFetcher);\n  let fetcherData = React.useContext(FetchersContext);\n  let route = React.useContext(UNSAFE_RouteContext);\n  let routeId = (_route$matches = route.matches[route.matches.length - 1]) == null ? void 0 : _route$matches.route.id;\n  !fetcherData ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a FetchersContext\") : UNSAFE_invariant(false) : void 0;\n  !route ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher must be used inside a RouteContext\") : UNSAFE_invariant(false) : void 0;\n  !(routeId != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"useFetcher can only be used on routes that contain a unique \\\"id\\\"\") : UNSAFE_invariant(false) : void 0;\n  // Fetcher key handling\n  let [fetcherKey, setFetcherKey] = React.useState(key || \"\");\n  if (key && key !== fetcherKey) {\n    setFetcherKey(key);\n  } else if (!fetcherKey) {\n    setFetcherKey(getUniqueFetcherId());\n  }\n  // Registration/cleanup\n  React.useEffect(() => {\n    router.getFetcher(fetcherKey);\n    return () => {\n      // Tell the router we've unmounted - if v7_fetcherPersist is enabled this\n      // will not delete immediately but instead queue up a delete after the\n      // fetcher returns to an `idle` state\n      router.deleteFetcher(fetcherKey);\n    };\n  }, [router, fetcherKey]);\n  // Fetcher additions\n  let load = React.useCallback((href, opts) => {\n    !routeId ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"No routeId available for fetcher.load()\") : UNSAFE_invariant(false) : void 0;\n    router.fetch(fetcherKey, routeId, href, opts);\n  }, [fetcherKey, routeId, router]);\n  let submitImpl = useSubmit();\n  let submit = React.useCallback((target, opts) => {\n    submitImpl(target, _extends({}, opts, {\n      navigate: false,\n      fetcherKey\n    }));\n  }, [fetcherKey, submitImpl]);\n  let FetcherForm = React.useMemo(() => {\n    let FetcherForm = /*#__PURE__*/React.forwardRef((props, ref) => {\n      return /*#__PURE__*/React.createElement(Form, _extends({}, props, {\n        navigate: false,\n        fetcherKey: fetcherKey,\n        ref: ref\n      }));\n    });\n    if (process.env.NODE_ENV !== \"production\") {\n      FetcherForm.displayName = \"fetcher.Form\";\n    }\n    return FetcherForm;\n  }, [fetcherKey]);\n  // Exposed FetcherWithComponents\n  let fetcher = state.fetchers.get(fetcherKey) || IDLE_FETCHER;\n  let data = fetcherData.get(fetcherKey);\n  let fetcherWithComponents = React.useMemo(() => _extends({\n    Form: FetcherForm,\n    submit,\n    load\n  }, fetcher, {\n    data\n  }), [FetcherForm, submit, load, fetcher, data]);\n  return fetcherWithComponents;\n}\n/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */\nfunction useFetchers() {\n  let state = useDataRouterState(DataRouterStateHook.UseFetchers);\n  return Array.from(state.fetchers.entries()).map(_ref11 => {\n    let [key, fetcher] = _ref11;\n    return _extends({}, fetcher, {\n      key\n    });\n  });\n}\nconst SCROLL_RESTORATION_STORAGE_KEY = \"react-router-scroll-positions\";\nlet savedScrollPositions = {};\n/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */\nfunction useScrollRestoration(_temp4) {\n  let {\n    getKey,\n    storageKey\n  } = _temp4 === void 0 ? {} : _temp4;\n  let {\n    router\n  } = useDataRouterContext(DataRouterHook.UseScrollRestoration);\n  let {\n    restoreScrollPosition,\n    preventScrollReset\n  } = useDataRouterState(DataRouterStateHook.UseScrollRestoration);\n  let {\n    basename\n  } = React.useContext(UNSAFE_NavigationContext);\n  let location = useLocation();\n  let matches = useMatches();\n  let navigation = useNavigation();\n  // Trigger manual scroll restoration while we're active\n  React.useEffect(() => {\n    window.history.scrollRestoration = \"manual\";\n    return () => {\n      window.history.scrollRestoration = \"auto\";\n    };\n  }, []);\n  // Save positions on pagehide\n  usePageHide(React.useCallback(() => {\n    if (navigation.state === \"idle\") {\n      let key = (getKey ? getKey(location, matches) : null) || location.key;\n      savedScrollPositions[key] = window.scrollY;\n    }\n    try {\n      sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));\n    } catch (error) {\n      process.env.NODE_ENV !== \"production\" ? UNSAFE_warning(false, \"Failed to save scroll positions in sessionStorage, <ScrollRestoration /> will not work properly (\" + error + \").\") : void 0;\n    }\n    window.history.scrollRestoration = \"auto\";\n  }, [storageKey, getKey, navigation.state, location, matches]));\n  // Read in any saved scroll locations\n  if (typeof document !== \"undefined\") {\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      try {\n        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);\n        if (sessionPositions) {\n          savedScrollPositions = JSON.parse(sessionPositions);\n        }\n      } catch (e) {\n        // no-op, use default empty object\n      }\n    }, [storageKey]);\n    // Enable scroll restoration in the router\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      let getKeyWithoutBasename = getKey && basename !== \"/\" ? (location, matches) => getKey( // Strip the basename to match useLocation()\n      _extends({}, location, {\n        pathname: stripBasename(location.pathname, basename) || location.pathname\n      }), matches) : getKey;\n      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKeyWithoutBasename);\n      return () => disableScrollRestoration && disableScrollRestoration();\n    }, [router, basename, getKey]);\n    // Restore scrolling when state.restoreScrollPosition changes\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    React.useLayoutEffect(() => {\n      // Explicit false means don't do anything (used for submissions)\n      if (restoreScrollPosition === false) {\n        return;\n      }\n      // been here before, scroll to it\n      if (typeof restoreScrollPosition === \"number\") {\n        window.scrollTo(0, restoreScrollPosition);\n        return;\n      }\n      // try to scroll to the hash\n      if (location.hash) {\n        let el = document.getElementById(decodeURIComponent(location.hash.slice(1)));\n        if (el) {\n          el.scrollIntoView();\n          return;\n        }\n      }\n      // Don't reset if this navigation opted out\n      if (preventScrollReset === true) {\n        return;\n      }\n      // otherwise go to the top on new locations\n      window.scrollTo(0, 0);\n    }, [location, restoreScrollPosition, preventScrollReset]);\n  }\n}\n/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction useBeforeUnload(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"beforeunload\", callback, opts);\n    return () => {\n      window.removeEventListener(\"beforeunload\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */\nfunction usePageHide(callback, options) {\n  let {\n    capture\n  } = options || {};\n  React.useEffect(() => {\n    let opts = capture != null ? {\n      capture\n    } : undefined;\n    window.addEventListener(\"pagehide\", callback, opts);\n    return () => {\n      window.removeEventListener(\"pagehide\", callback, opts);\n    };\n  }, [callback, capture]);\n}\n/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */\nfunction usePrompt(_ref12) {\n  let {\n    when,\n    message\n  } = _ref12;\n  let blocker = useBlocker(when);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\") {\n      let proceed = window.confirm(message);\n      if (proceed) {\n        // This timeout is needed to avoid a weird \"race\" on POP navigations\n        // between the `window.history` revert navigation and the result of\n        // `window.confirm`\n        setTimeout(blocker.proceed, 0);\n      } else {\n        blocker.reset();\n      }\n    }\n  }, [blocker, message]);\n  React.useEffect(() => {\n    if (blocker.state === \"blocked\" && !when) {\n      blocker.reset();\n    }\n  }, [blocker, when]);\n}\n/**\n * Return a boolean indicating if there is an active view transition to the\n * given href.  You can use this value to render CSS classes or viewTransitionName\n * styles onto your elements\n *\n * @param href The destination href\n * @param [opts.relative] Relative routing type (\"route\" | \"path\")\n */\nfunction useViewTransitionState(to, opts) {\n  if (opts === void 0) {\n    opts = {};\n  }\n  let vtContext = React.useContext(ViewTransitionContext);\n  !(vtContext != null) ? process.env.NODE_ENV !== \"production\" ? UNSAFE_invariant(false, \"`unstable_useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  \" + \"Did you accidentally import `RouterProvider` from `react-router`?\") : UNSAFE_invariant(false) : void 0;\n  let {\n    basename\n  } = useDataRouterContext(DataRouterHook.useViewTransitionState);\n  let path = useResolvedPath(to, {\n    relative: opts.relative\n  });\n  if (!vtContext.isTransitioning) {\n    return false;\n  }\n  let currentPath = stripBasename(vtContext.currentLocation.pathname, basename) || vtContext.currentLocation.pathname;\n  let nextPath = stripBasename(vtContext.nextLocation.pathname, basename) || vtContext.nextLocation.pathname;\n  // Transition is active if we're going to or coming from the indicated\n  // destination.  This ensures that other PUSH navigations that reverse\n  // an indicated transition apply.  I.e., on the list view you have:\n  //\n  //   <NavLink to=\"/details/1\" unstable_viewTransition>\n  //\n  // If you click the breadcrumb back to the list view:\n  //\n  //   <NavLink to=\"/list\" unstable_viewTransition>\n  //\n  // We should apply the transition because it's indicated as active going\n  // from /list -> /details/1 and therefore should be active on the reverse\n  // (even though this isn't strictly a POP reverse)\n  return matchPath(path.pathname, nextPath) != null || matchPath(path.pathname, currentPath) != null;\n}\n//#endregion\n\nexport { BrowserRouter, Form, HashRouter, Link, NavLink, RouterProvider, ScrollRestoration, FetchersContext as UNSAFE_FetchersContext, ViewTransitionContext as UNSAFE_ViewTransitionContext, useScrollRestoration as UNSAFE_useScrollRestoration, createBrowserRouter, createHashRouter, createSearchParams, HistoryRouter as unstable_HistoryRouter, usePrompt as unstable_usePrompt, useViewTransitionState as unstable_useViewTransitionState, useBeforeUnload, useFetcher, useFetchers, useFormAction, useLinkClickHandler, useSearchParams, useSubmit };\n//# sourceMappingURL=index.js.map\n","/*!\n* tabbable 6.2.0\n* @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE\n*/\n// NOTE: separate `:not()` selectors has broader browser support than the newer\n//  `:not([inert], [inert] *)` (Feb 2023)\n// CAREFUL: JSDom does not support `:not([inert] *)` as a selector; using it causes\n//  the entire query to fail, resulting in no nodes found, which will break a lot\n//  of things... so we have to rely on JS to identify nodes inside an inert container\nvar candidateSelectors = ['input:not([inert])', 'select:not([inert])', 'textarea:not([inert])', 'a[href]:not([inert])', 'button:not([inert])', '[tabindex]:not(slot):not([inert])', 'audio[controls]:not([inert])', 'video[controls]:not([inert])', '[contenteditable]:not([contenteditable=\"false\"]):not([inert])', 'details>summary:first-of-type:not([inert])', 'details:not([inert])'];\nvar candidateSelector = /* #__PURE__ */candidateSelectors.join(',');\nvar NoElement = typeof Element === 'undefined';\nvar matches = NoElement ? function () {} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;\nvar getRootNode = !NoElement && Element.prototype.getRootNode ? function (element) {\n  var _element$getRootNode;\n  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);\n} : function (element) {\n  return element === null || element === void 0 ? void 0 : element.ownerDocument;\n};\n\n/**\n * Determines if a node is inert or in an inert ancestor.\n * @param {Element} [node]\n * @param {boolean} [lookUp] If true and `node` is not inert, looks up at ancestors to\n *  see if any of them are inert. If false, only `node` itself is considered.\n * @returns {boolean} True if inert itself or by way of being in an inert ancestor.\n *  False if `node` is falsy.\n */\nvar isInert = function isInert(node, lookUp) {\n  var _node$getAttribute;\n  if (lookUp === void 0) {\n    lookUp = true;\n  }\n  // CAREFUL: JSDom does not support inert at all, so we can't use the `HTMLElement.inert`\n  //  JS API property; we have to check the attribute, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's an active element\n  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, 'inert');\n  var inert = inertAtt === '' || inertAtt === 'true';\n\n  // NOTE: this could also be handled with `node.matches('[inert], :is([inert] *)')`\n  //  if it weren't for `matches()` not being a function on shadow roots; the following\n  //  code works for any kind of node\n  // CAREFUL: JSDom does not appear to support certain selectors like `:not([inert] *)`\n  //  so it likely would not support `:is([inert] *)` either...\n  var result = inert || lookUp && node && isInert(node.parentNode); // recursive\n\n  return result;\n};\n\n/**\n * Determines if a node's content is editable.\n * @param {Element} [node]\n * @returns True if it's content-editable; false if it's not or `node` is falsy.\n */\nvar isContentEditable = function isContentEditable(node) {\n  var _node$getAttribute2;\n  // CAREFUL: JSDom does not support the `HTMLElement.isContentEditable` API so we have\n  //  to use the attribute directly to check for this, which can either be empty or 'true';\n  //  if it's `null` (not specified) or 'false', it's a non-editable element\n  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, 'contenteditable');\n  return attValue === '' || attValue === 'true';\n};\n\n/**\n * @param {Element} el container to check in\n * @param {boolean} includeContainer add container to check\n * @param {(node: Element) => boolean} filter filter candidates\n * @returns {Element[]}\n */\nvar getCandidates = function getCandidates(el, includeContainer, filter) {\n  // even if `includeContainer=false`, we still have to check it for inertness because\n  //  if it's inert, all its children are inert\n  if (isInert(el)) {\n    return [];\n  }\n  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));\n  if (includeContainer && matches.call(el, candidateSelector)) {\n    candidates.unshift(el);\n  }\n  candidates = candidates.filter(filter);\n  return candidates;\n};\n\n/**\n * @callback GetShadowRoot\n * @param {Element} element to check for shadow root\n * @returns {ShadowRoot|boolean} ShadowRoot if available or boolean indicating if a shadowRoot is attached but not available.\n */\n\n/**\n * @callback ShadowRootFilter\n * @param {Element} shadowHostNode the element which contains shadow content\n * @returns {boolean} true if a shadow root could potentially contain valid candidates.\n */\n\n/**\n * @typedef {Object} CandidateScope\n * @property {Element} scopeParent contains inner candidates\n * @property {Element[]} candidates list of candidates found in the scope parent\n */\n\n/**\n * @typedef {Object} IterativeOptions\n * @property {GetShadowRoot|boolean} getShadowRoot true if shadow support is enabled; falsy if not;\n *  if a function, implies shadow support is enabled and either returns the shadow root of an element\n *  or a boolean stating if it has an undisclosed shadow root\n * @property {(node: Element) => boolean} filter filter candidates\n * @property {boolean} flatten if true then result will flatten any CandidateScope into the returned list\n * @property {ShadowRootFilter} shadowRootFilter filter shadow roots;\n */\n\n/**\n * @param {Element[]} elements list of element containers to match candidates from\n * @param {boolean} includeContainer add container list to check\n * @param {IterativeOptions} options\n * @returns {Array.<Element|CandidateScope>}\n */\nvar getCandidatesIteratively = function getCandidatesIteratively(elements, includeContainer, options) {\n  var candidates = [];\n  var elementsToCheck = Array.from(elements);\n  while (elementsToCheck.length) {\n    var element = elementsToCheck.shift();\n    if (isInert(element, false)) {\n      // no need to look up since we're drilling down\n      // anything inside this container will also be inert\n      continue;\n    }\n    if (element.tagName === 'SLOT') {\n      // add shadow dom slot scope (slot itself cannot be focusable)\n      var assigned = element.assignedElements();\n      var content = assigned.length ? assigned : element.children;\n      var nestedCandidates = getCandidatesIteratively(content, true, options);\n      if (options.flatten) {\n        candidates.push.apply(candidates, nestedCandidates);\n      } else {\n        candidates.push({\n          scopeParent: element,\n          candidates: nestedCandidates\n        });\n      }\n    } else {\n      // check candidate element\n      var validCandidate = matches.call(element, candidateSelector);\n      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {\n        candidates.push(element);\n      }\n\n      // iterate over shadow content if possible\n      var shadowRoot = element.shadowRoot ||\n      // check for an undisclosed shadow\n      typeof options.getShadowRoot === 'function' && options.getShadowRoot(element);\n\n      // no inert look up because we're already drilling down and checking for inertness\n      //  on the way down, so all containers to this root node should have already been\n      //  vetted as non-inert\n      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));\n      if (shadowRoot && validShadowRoot) {\n        // add shadow dom scope IIF a shadow root node was given; otherwise, an undisclosed\n        //  shadow exists, so look at light dom children as fallback BUT create a scope for any\n        //  child candidates found because they're likely slotted elements (elements that are\n        //  children of the web component element (which has the shadow), in the light dom, but\n        //  slotted somewhere _inside_ the undisclosed shadow) -- the scope is created below,\n        //  _after_ we return from this recursive call\n        var _nestedCandidates = getCandidatesIteratively(shadowRoot === true ? element.children : shadowRoot.children, true, options);\n        if (options.flatten) {\n          candidates.push.apply(candidates, _nestedCandidates);\n        } else {\n          candidates.push({\n            scopeParent: element,\n            candidates: _nestedCandidates\n          });\n        }\n      } else {\n        // there's not shadow so just dig into the element's (light dom) children\n        //  __without__ giving the element special scope treatment\n        elementsToCheck.unshift.apply(elementsToCheck, element.children);\n      }\n    }\n  }\n  return candidates;\n};\n\n/**\n * @private\n * Determines if the node has an explicitly specified `tabindex` attribute.\n * @param {HTMLElement} node\n * @returns {boolean} True if so; false if not.\n */\nvar hasTabIndex = function hasTabIndex(node) {\n  return !isNaN(parseInt(node.getAttribute('tabindex'), 10));\n};\n\n/**\n * Determine the tab index of a given node.\n * @param {HTMLElement} node\n * @returns {number} Tab order (negative, 0, or positive number).\n * @throws {Error} If `node` is falsy.\n */\nvar getTabIndex = function getTabIndex(node) {\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (node.tabIndex < 0) {\n    // in Chrome, <details/>, <audio controls/> and <video controls/> elements get a default\n    // `tabIndex` of -1 when the 'tabindex' attribute isn't specified in the DOM,\n    // yet they are still part of the regular tab order; in FF, they get a default\n    // `tabIndex` of 0; since Chrome still puts those elements in the regular tab\n    // order, consider their tab index to be 0.\n    // Also browsers do not return `tabIndex` correctly for contentEditable nodes;\n    // so if they don't have a tabindex attribute specifically set, assume it's 0.\n    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {\n      return 0;\n    }\n  }\n  return node.tabIndex;\n};\n\n/**\n * Determine the tab index of a given node __for sort order purposes__.\n * @param {HTMLElement} node\n * @param {boolean} [isScope] True for a custom element with shadow root or slot that, by default,\n *  has tabIndex -1, but needs to be sorted by document order in order for its content to be\n *  inserted into the correct sort position.\n * @returns {number} Tab order (negative, 0, or positive number).\n */\nvar getSortOrderTabIndex = function getSortOrderTabIndex(node, isScope) {\n  var tabIndex = getTabIndex(node);\n  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {\n    return 0;\n  }\n  return tabIndex;\n};\nvar sortOrderedTabbables = function sortOrderedTabbables(a, b) {\n  return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;\n};\nvar isInput = function isInput(node) {\n  return node.tagName === 'INPUT';\n};\nvar isHiddenInput = function isHiddenInput(node) {\n  return isInput(node) && node.type === 'hidden';\n};\nvar isDetailsWithSummary = function isDetailsWithSummary(node) {\n  var r = node.tagName === 'DETAILS' && Array.prototype.slice.apply(node.children).some(function (child) {\n    return child.tagName === 'SUMMARY';\n  });\n  return r;\n};\nvar getCheckedRadio = function getCheckedRadio(nodes, form) {\n  for (var i = 0; i < nodes.length; i++) {\n    if (nodes[i].checked && nodes[i].form === form) {\n      return nodes[i];\n    }\n  }\n};\nvar isTabbableRadio = function isTabbableRadio(node) {\n  if (!node.name) {\n    return true;\n  }\n  var radioScope = node.form || getRootNode(node);\n  var queryRadios = function queryRadios(name) {\n    return radioScope.querySelectorAll('input[type=\"radio\"][name=\"' + name + '\"]');\n  };\n  var radioSet;\n  if (typeof window !== 'undefined' && typeof window.CSS !== 'undefined' && typeof window.CSS.escape === 'function') {\n    radioSet = queryRadios(window.CSS.escape(node.name));\n  } else {\n    try {\n      radioSet = queryRadios(node.name);\n    } catch (err) {\n      // eslint-disable-next-line no-console\n      console.error('Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s', err.message);\n      return false;\n    }\n  }\n  var checked = getCheckedRadio(radioSet, node.form);\n  return !checked || checked === node;\n};\nvar isRadio = function isRadio(node) {\n  return isInput(node) && node.type === 'radio';\n};\nvar isNonTabbableRadio = function isNonTabbableRadio(node) {\n  return isRadio(node) && !isTabbableRadio(node);\n};\n\n// determines if a node is ultimately attached to the window's document\nvar isNodeAttached = function isNodeAttached(node) {\n  var _nodeRoot;\n  // The root node is the shadow root if the node is in a shadow DOM; some document otherwise\n  //  (but NOT _the_ document; see second 'If' comment below for more).\n  // If rootNode is shadow root, it'll have a host, which is the element to which the shadow\n  //  is attached, and the one we need to check if it's in the document or not (because the\n  //  shadow, and all nodes it contains, is never considered in the document since shadows\n  //  behave like self-contained DOMs; but if the shadow's HOST, which is part of the document,\n  //  is hidden, or is not in the document itself but is detached, it will affect the shadow's\n  //  visibility, including all the nodes it contains). The host could be any normal node,\n  //  or a custom element (i.e. web component). Either way, that's the one that is considered\n  //  part of the document, not the shadow root, nor any of its children (i.e. the node being\n  //  tested).\n  // To further complicate things, we have to look all the way up until we find a shadow HOST\n  //  that is attached (or find none) because the node might be in nested shadows...\n  // If rootNode is not a shadow root, it won't have a host, and so rootNode should be the\n  //  document (per the docs) and while it's a Document-type object, that document does not\n  //  appear to be the same as the node's `ownerDocument` for some reason, so it's safer\n  //  to ignore the rootNode at this point, and use `node.ownerDocument`. Otherwise,\n  //  using `rootNode.contains(node)` will _always_ be true we'll get false-positives when\n  //  node is actually detached.\n  // NOTE: If `nodeRootHost` or `node` happens to be the `document` itself (which is possible\n  //  if a tabbable/focusable node was quickly added to the DOM, focused, and then removed\n  //  from the DOM as in https://github.com/focus-trap/focus-trap-react/issues/905), then\n  //  `ownerDocument` will be `null`, hence the optional chaining on it.\n  var nodeRoot = node && getRootNode(node);\n  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;\n\n  // in some cases, a detached node will return itself as the root instead of a document or\n  //  shadow root object, in which case, we shouldn't try to look further up the host chain\n  var attached = false;\n  if (nodeRoot && nodeRoot !== node) {\n    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;\n    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));\n    while (!attached && nodeRootHost) {\n      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;\n      // since it's not attached and we have a root host, the node MUST be in a nested shadow DOM,\n      //  which means we need to get the host's host and check if that parent host is contained\n      //  in (i.e. attached to) the document\n      nodeRoot = getRootNode(nodeRootHost);\n      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;\n      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));\n    }\n  }\n  return attached;\n};\nvar isZeroArea = function isZeroArea(node) {\n  var _node$getBoundingClie = node.getBoundingClientRect(),\n    width = _node$getBoundingClie.width,\n    height = _node$getBoundingClie.height;\n  return width === 0 && height === 0;\n};\nvar isHidden = function isHidden(node, _ref) {\n  var displayCheck = _ref.displayCheck,\n    getShadowRoot = _ref.getShadowRoot;\n  // NOTE: visibility will be `undefined` if node is detached from the document\n  //  (see notes about this further down), which means we will consider it visible\n  //  (this is legacy behavior from a very long way back)\n  // NOTE: we check this regardless of `displayCheck=\"none\"` because this is a\n  //  _visibility_ check, not a _display_ check\n  if (getComputedStyle(node).visibility === 'hidden') {\n    return true;\n  }\n  var isDirectSummary = matches.call(node, 'details>summary:first-of-type');\n  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;\n  if (matches.call(nodeUnderDetails, 'details:not([open]) *')) {\n    return true;\n  }\n  if (!displayCheck || displayCheck === 'full' || displayCheck === 'legacy-full') {\n    if (typeof getShadowRoot === 'function') {\n      // figure out if we should consider the node to be in an undisclosed shadow and use the\n      //  'non-zero-area' fallback\n      var originalNode = node;\n      while (node) {\n        var parentElement = node.parentElement;\n        var rootNode = getRootNode(node);\n        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true // check if there's an undisclosed shadow\n        ) {\n          // node has an undisclosed shadow which means we can only treat it as a black box, so we\n          //  fall back to a non-zero-area test\n          return isZeroArea(node);\n        } else if (node.assignedSlot) {\n          // iterate up slot\n          node = node.assignedSlot;\n        } else if (!parentElement && rootNode !== node.ownerDocument) {\n          // cross shadow boundary\n          node = rootNode.host;\n        } else {\n          // iterate up normal dom\n          node = parentElement;\n        }\n      }\n      node = originalNode;\n    }\n    // else, `getShadowRoot` might be true, but all that does is enable shadow DOM support\n    //  (i.e. it does not also presume that all nodes might have undisclosed shadows); or\n    //  it might be a falsy value, which means shadow DOM support is disabled\n\n    // Since we didn't find it sitting in an undisclosed shadow (or shadows are disabled)\n    //  now we can just test to see if it would normally be visible or not, provided it's\n    //  attached to the main document.\n    // NOTE: We must consider case where node is inside a shadow DOM and given directly to\n    //  `isTabbable()` or `isFocusable()` -- regardless of `getShadowRoot` option setting.\n\n    if (isNodeAttached(node)) {\n      // this works wherever the node is: if there's at least one client rect, it's\n      //  somehow displayed; it also covers the CSS 'display: contents' case where the\n      //  node itself is hidden in place of its contents; and there's no need to search\n      //  up the hierarchy either\n      return !node.getClientRects().length;\n    }\n\n    // Else, the node isn't attached to the document, which means the `getClientRects()`\n    //  API will __always__ return zero rects (this can happen, for example, if React\n    //  is used to render nodes onto a detached tree, as confirmed in this thread:\n    //  https://github.com/facebook/react/issues/9117#issuecomment-284228870)\n    //\n    // It also means that even window.getComputedStyle(node).display will return `undefined`\n    //  because styles are only computed for nodes that are in the document.\n    //\n    // NOTE: THIS HAS BEEN THE CASE FOR YEARS. It is not new, nor is it caused by tabbable\n    //  somehow. Though it was never stated officially, anyone who has ever used tabbable\n    //  APIs on nodes in detached containers has actually implicitly used tabbable in what\n    //  was later (as of v5.2.0 on Apr 9, 2021) called `displayCheck=\"none\"` mode -- essentially\n    //  considering __everything__ to be visible because of the innability to determine styles.\n    //\n    // v6.0.0: As of this major release, the default 'full' option __no longer treats detached\n    //  nodes as visible with the 'none' fallback.__\n    if (displayCheck !== 'legacy-full') {\n      return true; // hidden\n    }\n    // else, fallback to 'none' mode and consider the node visible\n  } else if (displayCheck === 'non-zero-area') {\n    // NOTE: Even though this tests that the node's client rect is non-zero to determine\n    //  whether it's displayed, and that a detached node will __always__ have a zero-area\n    //  client rect, we don't special-case for whether the node is attached or not. In\n    //  this mode, we do want to consider nodes that have a zero area to be hidden at all\n    //  times, and that includes attached or not.\n    return isZeroArea(node);\n  }\n\n  // visible, as far as we can tell, or per current `displayCheck=none` mode, we assume\n  //  it's visible\n  return false;\n};\n\n// form fields (nested) inside a disabled fieldset are not focusable/tabbable\n//  unless they are in the _first_ <legend> element of the top-most disabled\n//  fieldset\nvar isDisabledFromFieldset = function isDisabledFromFieldset(node) {\n  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {\n    var parentNode = node.parentElement;\n    // check if `node` is contained in a disabled <fieldset>\n    while (parentNode) {\n      if (parentNode.tagName === 'FIELDSET' && parentNode.disabled) {\n        // look for the first <legend> among the children of the disabled <fieldset>\n        for (var i = 0; i < parentNode.children.length; i++) {\n          var child = parentNode.children.item(i);\n          // when the first <legend> (in document order) is found\n          if (child.tagName === 'LEGEND') {\n            // if its parent <fieldset> is not nested in another disabled <fieldset>,\n            // return whether `node` is a descendant of its first <legend>\n            return matches.call(parentNode, 'fieldset[disabled] *') ? true : !child.contains(node);\n          }\n        }\n        // the disabled <fieldset> containing `node` has no <legend>\n        return true;\n      }\n      parentNode = parentNode.parentElement;\n    }\n  }\n\n  // else, node's tabbable/focusable state should not be affected by a fieldset's\n  //  enabled/disabled state\n  return false;\n};\nvar isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable(options, node) {\n  if (node.disabled ||\n  // we must do an inert look up to filter out any elements inside an inert ancestor\n  //  because we're limited in the type of selectors we can use in JSDom (see related\n  //  note related to `candidateSelectors`)\n  isInert(node) || isHiddenInput(node) || isHidden(node, options) ||\n  // For a details element with a summary, the summary element gets the focus\n  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {\n    return false;\n  }\n  return true;\n};\nvar isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable(options, node) {\n  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {\n    return false;\n  }\n  return true;\n};\nvar isValidShadowRootTabbable = function isValidShadowRootTabbable(shadowHostNode) {\n  var tabIndex = parseInt(shadowHostNode.getAttribute('tabindex'), 10);\n  if (isNaN(tabIndex) || tabIndex >= 0) {\n    return true;\n  }\n  // If a custom element has an explicit negative tabindex,\n  // browsers will not allow tab targeting said element's children.\n  return false;\n};\n\n/**\n * @param {Array.<Element|CandidateScope>} candidates\n * @returns Element[]\n */\nvar sortByOrder = function sortByOrder(candidates) {\n  var regularTabbables = [];\n  var orderedTabbables = [];\n  candidates.forEach(function (item, i) {\n    var isScope = !!item.scopeParent;\n    var element = isScope ? item.scopeParent : item;\n    var candidateTabindex = getSortOrderTabIndex(element, isScope);\n    var elements = isScope ? sortByOrder(item.candidates) : element;\n    if (candidateTabindex === 0) {\n      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);\n    } else {\n      orderedTabbables.push({\n        documentOrder: i,\n        tabIndex: candidateTabindex,\n        item: item,\n        isScope: isScope,\n        content: elements\n      });\n    }\n  });\n  return orderedTabbables.sort(sortOrderedTabbables).reduce(function (acc, sortable) {\n    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);\n    return acc;\n  }, []).concat(regularTabbables);\n};\nvar tabbable = function tabbable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorTabbable.bind(null, options),\n      flatten: false,\n      getShadowRoot: options.getShadowRoot,\n      shadowRootFilter: isValidShadowRootTabbable\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));\n  }\n  return sortByOrder(candidates);\n};\nvar focusable = function focusable(container, options) {\n  options = options || {};\n  var candidates;\n  if (options.getShadowRoot) {\n    candidates = getCandidatesIteratively([container], options.includeContainer, {\n      filter: isNodeMatchingSelectorFocusable.bind(null, options),\n      flatten: true,\n      getShadowRoot: options.getShadowRoot\n    });\n  } else {\n    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));\n  }\n  return candidates;\n};\nvar isTabbable = function isTabbable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, candidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorTabbable(options, node);\n};\nvar focusableCandidateSelector = /* #__PURE__ */candidateSelectors.concat('iframe').join(',');\nvar isFocusable = function isFocusable(node, options) {\n  options = options || {};\n  if (!node) {\n    throw new Error('No node provided');\n  }\n  if (matches.call(node, focusableCandidateSelector) === false) {\n    return false;\n  }\n  return isNodeMatchingSelectorFocusable(options, node);\n};\n\nexport { focusable, getTabIndex, isFocusable, isTabbable, tabbable };\n//# sourceMappingURL=index.esm.js.map\n","/*!\n* focus-trap 7.6.4\n* @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE\n*/\nimport { tabbable, focusable, isTabbable, getTabIndex, isFocusable } from 'tabbable';\n\nfunction _arrayLikeToArray(r, a) {\n  (null == a || a > r.length) && (a = r.length);\n  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];\n  return n;\n}\nfunction _arrayWithoutHoles(r) {\n  if (Array.isArray(r)) return _arrayLikeToArray(r);\n}\nfunction _defineProperty(e, r, t) {\n  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, {\n    value: t,\n    enumerable: true,\n    configurable: true,\n    writable: true\n  }) : e[r] = t, e;\n}\nfunction _iterableToArray(r) {\n  if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r);\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), true).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toConsumableArray(r) {\n  return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (undefined !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : i + \"\";\n}\nfunction _unsupportedIterableToArray(r, a) {\n  if (r) {\n    if (\"string\" == typeof r) return _arrayLikeToArray(r, a);\n    var t = {}.toString.call(r).slice(8, -1);\n    return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : undefined;\n  }\n}\n\nvar activeFocusTraps = {\n  activateTrap: function activateTrap(trapStack, trap) {\n    if (trapStack.length > 0) {\n      var activeTrap = trapStack[trapStack.length - 1];\n      if (activeTrap !== trap) {\n        activeTrap._setPausedState(true);\n      }\n    }\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex === -1) {\n      trapStack.push(trap);\n    } else {\n      // move this existing trap to the front of the queue\n      trapStack.splice(trapIndex, 1);\n      trapStack.push(trap);\n    }\n  },\n  deactivateTrap: function deactivateTrap(trapStack, trap) {\n    var trapIndex = trapStack.indexOf(trap);\n    if (trapIndex !== -1) {\n      trapStack.splice(trapIndex, 1);\n    }\n    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {\n      trapStack[trapStack.length - 1]._setPausedState(false);\n    }\n  }\n};\nvar isSelectableInput = function isSelectableInput(node) {\n  return node.tagName && node.tagName.toLowerCase() === 'input' && typeof node.select === 'function';\n};\nvar isEscapeEvent = function isEscapeEvent(e) {\n  return (e === null || e === undefined ? undefined : e.key) === 'Escape' || (e === null || e === undefined ? undefined : e.key) === 'Esc' || (e === null || e === undefined ? undefined : e.keyCode) === 27;\n};\nvar isTabEvent = function isTabEvent(e) {\n  return (e === null || e === undefined ? undefined : e.key) === 'Tab' || (e === null || e === undefined ? undefined : e.keyCode) === 9;\n};\n\n// checks for TAB by default\nvar isKeyForward = function isKeyForward(e) {\n  return isTabEvent(e) && !e.shiftKey;\n};\n\n// checks for SHIFT+TAB by default\nvar isKeyBackward = function isKeyBackward(e) {\n  return isTabEvent(e) && e.shiftKey;\n};\nvar delay = function delay(fn) {\n  return setTimeout(fn, 0);\n};\n\n/**\n * Get an option's value when it could be a plain value, or a handler that provides\n *  the value.\n * @param {*} value Option's value to check.\n * @param {...*} [params] Any parameters to pass to the handler, if `value` is a function.\n * @returns {*} The `value`, or the handler's returned value.\n */\nvar valueOrHandler = function valueOrHandler(value) {\n  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    params[_key - 1] = arguments[_key];\n  }\n  return typeof value === 'function' ? value.apply(undefined, params) : value;\n};\nvar getActualTarget = function getActualTarget(event) {\n  // NOTE: If the trap is _inside_ a shadow DOM, event.target will always be the\n  //  shadow host. However, event.target.composedPath() will be an array of\n  //  nodes \"clicked\" from inner-most (the actual element inside the shadow) to\n  //  outer-most (the host HTML document). If we have access to composedPath(),\n  //  then use its first element; otherwise, fall back to event.target (and\n  //  this only works for an _open_ shadow DOM; otherwise,\n  //  composedPath()[0] === event.target always).\n  return event.target.shadowRoot && typeof event.composedPath === 'function' ? event.composedPath()[0] : event.target;\n};\n\n// NOTE: this must be _outside_ `createFocusTrap()` to make sure all traps in this\n//  current instance use the same stack if `userOptions.trapStack` isn't specified\nvar internalTrapStack = [];\nvar createFocusTrap = function createFocusTrap(elements, userOptions) {\n  // SSR: a live trap shouldn't be created in this type of environment so this\n  //  should be safe code to execute if the `document` option isn't specified\n  var doc = (userOptions === null || userOptions === undefined ? undefined : userOptions.document) || document;\n  var trapStack = (userOptions === null || userOptions === undefined ? undefined : userOptions.trapStack) || internalTrapStack;\n  var config = _objectSpread2({\n    returnFocusOnDeactivate: true,\n    escapeDeactivates: true,\n    delayInitialFocus: true,\n    isKeyForward: isKeyForward,\n    isKeyBackward: isKeyBackward\n  }, userOptions);\n  var state = {\n    // containers given to createFocusTrap()\n    // @type {Array<HTMLElement>}\n    containers: [],\n    // list of objects identifying tabbable nodes in `containers` in the trap\n    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap\n    //  is active, but the trap should never get to a state where there isn't at least one group\n    //  with at least one tabbable node in it (that would lead to an error condition that would\n    //  result in an error being thrown)\n    // @type {Array<{\n    //   container: HTMLElement,\n    //   tabbableNodes: Array<HTMLElement>, // empty if none\n    //   focusableNodes: Array<HTMLElement>, // empty if none\n    //   posTabIndexesFound: boolean,\n    //   firstTabbableNode: HTMLElement|undefined,\n    //   lastTabbableNode: HTMLElement|undefined,\n    //   firstDomTabbableNode: HTMLElement|undefined,\n    //   lastDomTabbableNode: HTMLElement|undefined,\n    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined\n    // }>}\n    containerGroups: [],\n    // same order/length as `containers` list\n\n    // references to objects in `containerGroups`, but only those that actually have\n    //  tabbable nodes in them\n    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__\n    //  the same length\n    tabbableGroups: [],\n    nodeFocusedBeforeActivation: null,\n    mostRecentlyFocusedNode: null,\n    active: false,\n    paused: false,\n    manuallyPaused: false,\n    // timer ID for when delayInitialFocus is true and initial focus in this trap\n    //  has been delayed during activation\n    delayInitialFocusTimer: undefined,\n    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any\n    recentNavEvent: undefined\n  };\n  var trap; // eslint-disable-line prefer-const -- some private functions reference it, and its methods reference private functions, so we must declare here and define later\n\n  /**\n   * Gets a configuration option value.\n   * @param {Object|undefined} configOverrideOptions If true, and option is defined in this set,\n   *  value will be taken from this object. Otherwise, value will be taken from base configuration.\n   * @param {string} optionName Name of the option whose value is sought.\n   * @param {string|undefined} [configOptionName] Name of option to use __instead of__ `optionName`\n   *  IIF `configOverrideOptions` is not defined. Otherwise, `optionName` is used.\n   */\n  var getOption = function getOption(configOverrideOptions, optionName, configOptionName) {\n    return configOverrideOptions && configOverrideOptions[optionName] !== undefined ? configOverrideOptions[optionName] : config[configOptionName || optionName];\n  };\n\n  /**\n   * Finds the index of the container that contains the element.\n   * @param {HTMLElement} element\n   * @param {Event} [event] If available, and `element` isn't directly found in any container,\n   *  the event's composed path is used to see if includes any known trap containers in the\n   *  case where the element is inside a Shadow DOM.\n   * @returns {number} Index of the container in either `state.containers` or\n   *  `state.containerGroups` (the order/length of these lists are the same); -1\n   *  if the element isn't found.\n   */\n  var findContainerIndex = function findContainerIndex(element, event) {\n    var composedPath = typeof (event === null || event === undefined ? undefined : event.composedPath) === 'function' ? event.composedPath() : undefined;\n    // NOTE: search `containerGroups` because it's possible a group contains no tabbable\n    //  nodes, but still contains focusable nodes (e.g. if they all have `tabindex=-1`)\n    //  and we still need to find the element in there\n    return state.containerGroups.findIndex(function (_ref) {\n      var container = _ref.container,\n        tabbableNodes = _ref.tabbableNodes;\n      return container.contains(element) || (// fall back to explicit tabbable search which will take into consideration any\n      //  web components if the `tabbableOptions.getShadowRoot` option was used for\n      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't\n      //  look inside web components even if open)\n      composedPath === null || composedPath === undefined ? undefined : composedPath.includes(container)) || tabbableNodes.find(function (node) {\n        return node === element;\n      });\n    });\n  };\n\n  /**\n   * Gets the node for the given option, which is expected to be an option that\n   *  can be either a DOM node, a string that is a selector to get a node, `false`\n   *  (if a node is explicitly NOT given), or a function that returns any of these\n   *  values.\n   * @param {string} optionName\n   * @param {Object} options\n   * @param {boolean} [options.hasFallback] True if the option could be a selector string\n   *  and the option allows for a fallback scenario in the case where the selector is\n   *  valid but does not match a node (i.e. the queried node doesn't exist in the DOM).\n   * @param {Array} [options.params] Params to pass to the option if it's a function.\n   * @returns {undefined | null | false | HTMLElement | SVGElement} Returns\n   *  `undefined` if the option is not specified; `null` if the option didn't resolve\n   *  to a node but `options.hasFallback=true`, `false` if the option resolved to `false`\n   *  (node explicitly not given); otherwise, the resolved DOM node.\n   * @throws {Error} If the option is set, not `false`, and is not, or does not\n   *  resolve to a node, unless the option is a selector string and `options.hasFallback=true`.\n   */\n  var getNodeForOption = function getNodeForOption(optionName) {\n    var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref2$hasFallback = _ref2.hasFallback,\n      hasFallback = _ref2$hasFallback === undefined ? false : _ref2$hasFallback,\n      _ref2$params = _ref2.params,\n      params = _ref2$params === undefined ? [] : _ref2$params;\n    var optionValue = config[optionName];\n    if (typeof optionValue === 'function') {\n      optionValue = optionValue.apply(undefined, _toConsumableArray(params));\n    }\n    if (optionValue === true) {\n      optionValue = undefined; // use default value\n    }\n    if (!optionValue) {\n      if (optionValue === undefined || optionValue === false) {\n        return optionValue;\n      }\n      // else, empty string (invalid), null (invalid), 0 (invalid)\n\n      throw new Error(\"`\".concat(optionName, \"` was specified but was not a node, or did not return a node\"));\n    }\n    var node = optionValue; // could be HTMLElement, SVGElement, or non-empty string at this point\n\n    if (typeof optionValue === 'string') {\n      try {\n        node = doc.querySelector(optionValue); // resolve to node, or null if fails\n      } catch (err) {\n        throw new Error(\"`\".concat(optionName, \"` appears to be an invalid selector; error=\\\"\").concat(err.message, \"\\\"\"));\n      }\n      if (!node) {\n        if (!hasFallback) {\n          throw new Error(\"`\".concat(optionName, \"` as selector refers to no known node\"));\n        }\n        // else, `node` MUST be `null` because that's what `Document.querySelector()` returns\n        //  if the selector is valid but doesn't match anything\n      }\n    }\n    return node;\n  };\n  var getInitialFocusNode = function getInitialFocusNode() {\n    var node = getNodeForOption('initialFocus', {\n      hasFallback: true\n    });\n\n    // false explicitly indicates we want no initialFocus at all\n    if (node === false) {\n      return false;\n    }\n    if (node === undefined || node && !isFocusable(node, config.tabbableOptions)) {\n      // option not specified nor focusable: use fallback options\n      if (findContainerIndex(doc.activeElement) >= 0) {\n        node = doc.activeElement;\n      } else {\n        var firstTabbableGroup = state.tabbableGroups[0];\n        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;\n\n        // NOTE: `fallbackFocus` option function cannot return `false` (not supported)\n        node = firstTabbableNode || getNodeForOption('fallbackFocus');\n      }\n    } else if (node === null) {\n      // option is a VALID selector string that doesn't yield a node: use the `fallbackFocus`\n      //  option instead of the default behavior when the option isn't specified at all\n      node = getNodeForOption('fallbackFocus');\n    }\n    if (!node) {\n      throw new Error('Your focus-trap needs to have at least one focusable element');\n    }\n    return node;\n  };\n  var updateTabbableNodes = function updateTabbableNodes() {\n    state.containerGroups = state.containers.map(function (container) {\n      var tabbableNodes = tabbable(container, config.tabbableOptions);\n\n      // NOTE: if we have tabbable nodes, we must have focusable nodes; focusable nodes\n      //  are a superset of tabbable nodes since nodes with negative `tabindex` attributes\n      //  are focusable but not tabbable\n      var focusableNodes = focusable(container, config.tabbableOptions);\n      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : undefined;\n      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : undefined;\n      var firstDomTabbableNode = focusableNodes.find(function (node) {\n        return isTabbable(node);\n      });\n      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function (node) {\n        return isTabbable(node);\n      });\n      var posTabIndexesFound = !!tabbableNodes.find(function (node) {\n        return getTabIndex(node) > 0;\n      });\n      return {\n        container: container,\n        tabbableNodes: tabbableNodes,\n        focusableNodes: focusableNodes,\n        /** True if at least one node with positive `tabindex` was found in this container. */\n        posTabIndexesFound: posTabIndexesFound,\n        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */\n        firstTabbableNode: firstTabbableNode,\n        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */\n        lastTabbableNode: lastTabbableNode,\n        // NOTE: DOM order is NOT NECESSARILY \"document position\" order, but figuring that out\n        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition\n        //  because that API doesn't work with Shadow DOM as well as it should (@see\n        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,\n        //  to address an edge case related to positive tabindex support, this seems like a much easier,\n        //  \"close enough most of the time\" alternative for positive tabindexes which should generally\n        //  be avoided anyway...\n        /** First tabbable node in container, __DOM__ order; `undefined` if none. */\n        firstDomTabbableNode: firstDomTabbableNode,\n        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */\n        lastDomTabbableNode: lastDomTabbableNode,\n        /**\n         * Finds the __tabbable__ node that follows the given node in the specified direction,\n         *  in this container, if any.\n         * @param {HTMLElement} node\n         * @param {boolean} [forward] True if going in forward tab order; false if going\n         *  in reverse.\n         * @returns {HTMLElement|undefined} The next tabbable node, if any.\n         */\n        nextTabbableNode: function nextTabbableNode(node) {\n          var forward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n          var nodeIdx = tabbableNodes.indexOf(node);\n          if (nodeIdx < 0) {\n            // either not tabbable nor focusable, or was focused but not tabbable (negative tabindex):\n            //  since `node` should at least have been focusable, we assume that's the case and mimic\n            //  what browsers do, which is set focus to the next node in __document position order__,\n            //  regardless of positive tabindexes, if any -- and for reasons explained in the NOTE\n            //  above related to `firstDomTabbable` and `lastDomTabbable` properties, we fall back to\n            //  basic DOM order\n            if (forward) {\n              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function (el) {\n                return isTabbable(el);\n              });\n            }\n            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function (el) {\n              return isTabbable(el);\n            });\n          }\n          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];\n        }\n      };\n    });\n    state.tabbableGroups = state.containerGroups.filter(function (group) {\n      return group.tabbableNodes.length > 0;\n    });\n\n    // throw if no groups have tabbable nodes and we don't have a fallback focus node either\n    if (state.tabbableGroups.length <= 0 && !getNodeForOption('fallbackFocus') // returning false not supported for this option\n    ) {\n      throw new Error('Your focus-trap must have at least one container with at least one tabbable node in it at all times');\n    }\n\n    // NOTE: Positive tabindexes are only properly supported in single-container traps because\n    //  doing it across multiple containers where tabindexes could be all over the place\n    //  would require Tabbable to support multiple containers, would require additional\n    //  specialized Shadow DOM support, and would require Tabbable's multi-container support\n    //  to look at those containers in document position order rather than user-provided\n    //  order (as they are treated in Focus-trap, for legacy reasons). See discussion on\n    //  https://github.com/focus-trap/focus-trap/issues/375 for more details.\n    if (state.containerGroups.find(function (g) {\n      return g.posTabIndexesFound;\n    }) && state.containerGroups.length > 1) {\n      throw new Error(\"At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.\");\n    }\n  };\n\n  /**\n   * Gets the current activeElement. If it's a web-component and has open shadow-root\n   * it will recursively search inside shadow roots for the \"true\" activeElement.\n   *\n   * @param {Document | ShadowRoot} el\n   *\n   * @returns {HTMLElement} The element that currently has the focus\n   **/\n  var _getActiveElement = function getActiveElement(el) {\n    var activeElement = el.activeElement;\n    if (!activeElement) {\n      return;\n    }\n    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {\n      return _getActiveElement(activeElement.shadowRoot);\n    }\n    return activeElement;\n  };\n  var _tryFocus = function tryFocus(node) {\n    if (node === false) {\n      return;\n    }\n    if (node === _getActiveElement(document)) {\n      return;\n    }\n    if (!node || !node.focus) {\n      _tryFocus(getInitialFocusNode());\n      return;\n    }\n    node.focus({\n      preventScroll: !!config.preventScroll\n    });\n    // NOTE: focus() API does not trigger focusIn event so set MRU node manually\n    state.mostRecentlyFocusedNode = node;\n    if (isSelectableInput(node)) {\n      node.select();\n    }\n  };\n  var getReturnFocusNode = function getReturnFocusNode(previousActiveElement) {\n    var node = getNodeForOption('setReturnFocus', {\n      params: [previousActiveElement]\n    });\n    return node ? node : node === false ? false : previousActiveElement;\n  };\n\n  /**\n   * Finds the next node (in either direction) where focus should move according to a\n   *  keyboard focus-in event.\n   * @param {Object} params\n   * @param {Node} [params.target] Known target __from which__ to navigate, if any.\n   * @param {KeyboardEvent|FocusEvent} [params.event] Event to use if `target` isn't known (event\n   *  will be used to determine the `target`). Ignored if `target` is specified.\n   * @param {boolean} [params.isBackward] True if focus should move backward.\n   * @returns {Node|undefined} The next node, or `undefined` if a next node couldn't be\n   *  determined given the current state of the trap.\n   */\n  var findNextNavNode = function findNextNavNode(_ref3) {\n    var target = _ref3.target,\n      event = _ref3.event,\n      _ref3$isBackward = _ref3.isBackward,\n      isBackward = _ref3$isBackward === undefined ? false : _ref3$isBackward;\n    target = target || getActualTarget(event);\n    updateTabbableNodes();\n    var destinationNode = null;\n    if (state.tabbableGroups.length > 0) {\n      // make sure the target is actually contained in a group\n      // NOTE: the target may also be the container itself if it's focusable\n      //  with tabIndex='-1' and was given initial focus\n      var containerIndex = findContainerIndex(target, event);\n      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : undefined;\n      if (containerIndex < 0) {\n        // target not found in any group: quite possible focus has escaped the trap,\n        //  so bring it back into...\n        if (isBackward) {\n          // ...the last node in the last group\n          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;\n        } else {\n          // ...the first node in the first group\n          destinationNode = state.tabbableGroups[0].firstTabbableNode;\n        }\n      } else if (isBackward) {\n        // REVERSE\n\n        // is the target the first tabbable node in a group?\n        var startOfGroupIndex = state.tabbableGroups.findIndex(function (_ref4) {\n          var firstTabbableNode = _ref4.firstTabbableNode;\n          return target === firstTabbableNode;\n        });\n        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {\n          // an exception case where the target is either the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle shift+tab as if focus were on the container's\n          //  first tabbable node, and go to the last tabbable node of the LAST group\n          startOfGroupIndex = containerIndex;\n        }\n        if (startOfGroupIndex >= 0) {\n          // YES: then shift+tab should go to the last tabbable node in the\n          //  previous group (and wrap around to the last tabbable node of\n          //  the LAST group if it's the first tabbable node of the FIRST group)\n          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;\n          var destinationGroup = state.tabbableGroups[destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target, false);\n        }\n      } else {\n        // FORWARD\n\n        // is the target the last tabbable node in a group?\n        var lastOfGroupIndex = state.tabbableGroups.findIndex(function (_ref5) {\n          var lastTabbableNode = _ref5.lastTabbableNode;\n          return target === lastTabbableNode;\n        });\n        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {\n          // an exception case where the target is the container itself, or\n          //  a non-tabbable node that was given focus (i.e. tabindex is negative\n          //  and user clicked on it or node was programmatically given focus)\n          //  and is not followed by any other tabbable node, in which\n          //  case, we should handle tab as if focus were on the container's\n          //  last tabbable node, and go to the first tabbable node of the FIRST group\n          lastOfGroupIndex = containerIndex;\n        }\n        if (lastOfGroupIndex >= 0) {\n          // YES: then tab should go to the first tabbable node in the next\n          //  group (and wrap around to the first tabbable node of the FIRST\n          //  group if it's the last tabbable node of the LAST group)\n          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;\n          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];\n          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;\n        } else if (!isTabEvent(event)) {\n          // user must have customized the nav keys so we have to move focus manually _within_\n          //  the active group: do this based on the order determined by tabbable()\n          destinationNode = containerGroup.nextTabbableNode(target);\n        }\n      }\n    } else {\n      // no groups available\n      // NOTE: the fallbackFocus option does not support returning false to opt-out\n      destinationNode = getNodeForOption('fallbackFocus');\n    }\n    return destinationNode;\n  };\n\n  // This needs to be done on mousedown and touchstart instead of click\n  // so that it precedes the focus event.\n  var checkPointerDown = function checkPointerDown(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      // allow the click since it ocurred inside the trap\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      // immediately deactivate the trap\n      trap.deactivate({\n        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,\n        //  which will result in the outside click setting focus to the node\n        //  that was clicked (and if not focusable, to \"nothing\"); by setting\n        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused\n        //  on activation (or the configured `setReturnFocus` node), whether the\n        //  outside click was on a focusable node or not\n        returnFocus: config.returnFocusOnDeactivate\n      });\n      return;\n    }\n\n    // This is needed for mobile devices.\n    // (If we'll only let `click` events through,\n    // then on mobile they will be blocked anyways if `touchstart` is blocked.)\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      // allow the click outside the trap to take place\n      return;\n    }\n\n    // otherwise, prevent the click\n    e.preventDefault();\n  };\n\n  // In case focus escapes the trap for some strange reason, pull it back in.\n  // NOTE: the focusIn event is NOT cancelable, so if focus escapes, it may cause unexpected\n  //  scrolling if the node that got focused was out of view; there's nothing we can do to\n  //  prevent that from happening by the time we discover that focus escaped\n  var checkFocusIn = function checkFocusIn(event) {\n    var target = getActualTarget(event);\n    var targetContained = findContainerIndex(target, event) >= 0;\n\n    // In Firefox when you Tab out of an iframe the Document is briefly focused.\n    if (targetContained || target instanceof Document) {\n      if (targetContained) {\n        state.mostRecentlyFocusedNode = target;\n      }\n    } else {\n      // escaped! pull it back in to where it just left\n      event.stopImmediatePropagation();\n\n      // focus will escape if the MRU node had a positive tab index and user tried to nav forward;\n      //  it will also escape if the MRU node had a 0 tab index and user tried to nav backward\n      //  toward a node with a positive tab index\n      var nextNode; // next node to focus, if we find one\n      var navAcrossContainers = true;\n      if (state.mostRecentlyFocusedNode) {\n        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {\n          // MRU container index must be >=0 otherwise we wouldn't have it as an MRU node...\n          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);\n          // there MAY not be any tabbable nodes in the container if there are at least 2 containers\n          //  and the MRU node is focusable but not tabbable (focus-trap requires at least 1 container\n          //  with at least one tabbable node in order to function, so this could be the other container\n          //  with nothing tabbable in it)\n          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;\n          if (tabbableNodes.length > 0) {\n            // MRU tab index MAY not be found if the MRU node is focusable but not tabbable\n            var mruTabIdx = tabbableNodes.findIndex(function (node) {\n              return node === state.mostRecentlyFocusedNode;\n            });\n            if (mruTabIdx >= 0) {\n              if (config.isKeyForward(state.recentNavEvent)) {\n                if (mruTabIdx + 1 < tabbableNodes.length) {\n                  nextNode = tabbableNodes[mruTabIdx + 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              } else {\n                if (mruTabIdx - 1 >= 0) {\n                  nextNode = tabbableNodes[mruTabIdx - 1];\n                  navAcrossContainers = false;\n                }\n                // else, don't wrap within the container as focus should move to next/previous\n                //  container\n              }\n              // else, don't find in container order without considering direction too\n            }\n          }\n          // else, no tabbable nodes in that container (which means we must have at least one other\n          //  container with at least one tabbable node in it, otherwise focus-trap would've thrown\n          //  an error the last time updateTabbableNodes() was run): find next node among all known\n          //  containers\n        } else {\n          // check to see if there's at least one tabbable node with a positive tab index inside\n          //  the trap because focus seems to escape when navigating backward from a tabbable node\n          //  with tabindex=0 when this is the case (instead of wrapping to the tabbable node with\n          //  the greatest positive tab index like it should)\n          if (!state.containerGroups.some(function (g) {\n            return g.tabbableNodes.some(function (n) {\n              return getTabIndex(n) > 0;\n            });\n          })) {\n            // no containers with tabbable nodes with positive tab indexes which means the focus\n            //  escaped for some other reason and we should just execute the fallback to the\n            //  MRU node or initial focus node, if any\n            navAcrossContainers = false;\n          }\n        }\n      } else {\n        // no MRU node means we're likely in some initial condition when the trap has just\n        //  been activated and initial focus hasn't been given yet, in which case we should\n        //  fall through to trying to focus the initial focus node, which is what should\n        //  happen below at this point in the logic\n        navAcrossContainers = false;\n      }\n      if (navAcrossContainers) {\n        nextNode = findNextNavNode({\n          // move FROM the MRU node, not event-related node (which will be the node that is\n          //  outside the trap causing the focus escape we're trying to fix)\n          target: state.mostRecentlyFocusedNode,\n          isBackward: config.isKeyBackward(state.recentNavEvent)\n        });\n      }\n      if (nextNode) {\n        _tryFocus(nextNode);\n      } else {\n        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());\n      }\n    }\n    state.recentNavEvent = undefined; // clear\n  };\n\n  // Hijack key nav events on the first and last focusable nodes of the trap,\n  // in order to prevent focus from escaping. If it escapes for even a\n  // moment it can end up scrolling the page and causing confusion so we\n  // kind of need to capture the action at the keydown phase.\n  var checkKeyNav = function checkKeyNav(event) {\n    var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    state.recentNavEvent = event;\n    var destinationNode = findNextNavNode({\n      event: event,\n      isBackward: isBackward\n    });\n    if (destinationNode) {\n      if (isTabEvent(event)) {\n        // since tab natively moves focus, we wouldn't have a destination node unless we\n        //  were on the edge of a container and had to move to the next/previous edge, in\n        //  which case we want to prevent default to keep the browser from moving focus\n        //  to where it normally would\n        event.preventDefault();\n      }\n      _tryFocus(destinationNode);\n    }\n    // else, let the browser take care of [shift+]tab and move the focus\n  };\n  var checkTabKey = function checkTabKey(event) {\n    if (config.isKeyForward(event) || config.isKeyBackward(event)) {\n      checkKeyNav(event, config.isKeyBackward(event));\n    }\n  };\n\n  // we use a different event phase for the Escape key to allow canceling the event and checking for this in escapeDeactivates\n  var checkEscapeKey = function checkEscapeKey(event) {\n    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {\n      event.preventDefault();\n      trap.deactivate();\n    }\n  };\n  var checkClick = function checkClick(e) {\n    var target = getActualTarget(e);\n    if (findContainerIndex(target, e) >= 0) {\n      return;\n    }\n    if (valueOrHandler(config.clickOutsideDeactivates, e)) {\n      return;\n    }\n    if (valueOrHandler(config.allowOutsideClick, e)) {\n      return;\n    }\n    e.preventDefault();\n    e.stopImmediatePropagation();\n  };\n\n  //\n  // EVENT LISTENERS\n  //\n\n  var addListeners = function addListeners() {\n    if (!state.active) {\n      return;\n    }\n\n    // There can be only one listening focus trap at a time\n    activeFocusTraps.activateTrap(trapStack, trap);\n\n    // Delay ensures that the focused element doesn't capture the event\n    // that caused the focus trap activation.\n    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function () {\n      _tryFocus(getInitialFocusNode());\n    }) : _tryFocus(getInitialFocusNode());\n    doc.addEventListener('focusin', checkFocusIn, true);\n    doc.addEventListener('mousedown', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('touchstart', checkPointerDown, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('click', checkClick, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkTabKey, {\n      capture: true,\n      passive: false\n    });\n    doc.addEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n  var removeListeners = function removeListeners() {\n    if (!state.active) {\n      return;\n    }\n    doc.removeEventListener('focusin', checkFocusIn, true);\n    doc.removeEventListener('mousedown', checkPointerDown, true);\n    doc.removeEventListener('touchstart', checkPointerDown, true);\n    doc.removeEventListener('click', checkClick, true);\n    doc.removeEventListener('keydown', checkTabKey, true);\n    doc.removeEventListener('keydown', checkEscapeKey);\n    return trap;\n  };\n\n  //\n  // MUTATION OBSERVER\n  //\n\n  var checkDomRemoval = function checkDomRemoval(mutations) {\n    var isFocusedNodeRemoved = mutations.some(function (mutation) {\n      var removedNodes = Array.from(mutation.removedNodes);\n      return removedNodes.some(function (node) {\n        return node === state.mostRecentlyFocusedNode;\n      });\n    });\n\n    // If the currently focused is removed then browsers will move focus to the\n    // <body> element. If this happens, try to move focus back into the trap.\n    if (isFocusedNodeRemoved) {\n      _tryFocus(getInitialFocusNode());\n    }\n  };\n\n  // Use MutationObserver - if supported - to detect if focused node is removed\n  // from the DOM.\n  var mutationObserver = typeof window !== 'undefined' && 'MutationObserver' in window ? new MutationObserver(checkDomRemoval) : undefined;\n  var updateObservedNodes = function updateObservedNodes() {\n    if (!mutationObserver) {\n      return;\n    }\n    mutationObserver.disconnect();\n    if (state.active && !state.paused) {\n      state.containers.map(function (container) {\n        mutationObserver.observe(container, {\n          subtree: true,\n          childList: true\n        });\n      });\n    }\n  };\n\n  //\n  // TRAP DEFINITION\n  //\n\n  trap = {\n    get active() {\n      return state.active;\n    },\n    get paused() {\n      return state.paused;\n    },\n    activate: function activate(activateOptions) {\n      if (state.active) {\n        return this;\n      }\n      var onActivate = getOption(activateOptions, 'onActivate');\n      var onPostActivate = getOption(activateOptions, 'onPostActivate');\n      var checkCanFocusTrap = getOption(activateOptions, 'checkCanFocusTrap');\n      if (!checkCanFocusTrap) {\n        updateTabbableNodes();\n      }\n      state.active = true;\n      state.paused = false;\n      state.nodeFocusedBeforeActivation = doc.activeElement;\n      onActivate === null || onActivate === undefined || onActivate();\n      var finishActivation = function finishActivation() {\n        if (checkCanFocusTrap) {\n          updateTabbableNodes();\n        }\n        addListeners();\n        updateObservedNodes();\n        onPostActivate === null || onPostActivate === undefined || onPostActivate();\n      };\n      if (checkCanFocusTrap) {\n        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);\n        return this;\n      }\n      finishActivation();\n      return this;\n    },\n    deactivate: function deactivate(deactivateOptions) {\n      if (!state.active) {\n        return this;\n      }\n      var options = _objectSpread2({\n        onDeactivate: config.onDeactivate,\n        onPostDeactivate: config.onPostDeactivate,\n        checkCanReturnFocus: config.checkCanReturnFocus\n      }, deactivateOptions);\n      clearTimeout(state.delayInitialFocusTimer); // noop if undefined\n      state.delayInitialFocusTimer = undefined;\n      removeListeners();\n      state.active = false;\n      state.paused = false;\n      updateObservedNodes();\n      activeFocusTraps.deactivateTrap(trapStack, trap);\n      var onDeactivate = getOption(options, 'onDeactivate');\n      var onPostDeactivate = getOption(options, 'onPostDeactivate');\n      var checkCanReturnFocus = getOption(options, 'checkCanReturnFocus');\n      var returnFocus = getOption(options, 'returnFocus', 'returnFocusOnDeactivate');\n      onDeactivate === null || onDeactivate === undefined || onDeactivate();\n      var finishDeactivation = function finishDeactivation() {\n        delay(function () {\n          if (returnFocus) {\n            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));\n          }\n          onPostDeactivate === null || onPostDeactivate === undefined || onPostDeactivate();\n        });\n      };\n      if (returnFocus && checkCanReturnFocus) {\n        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);\n        return this;\n      }\n      finishDeactivation();\n      return this;\n    },\n    pause: function pause(pauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = true;\n      return this._setPausedState(true, pauseOptions);\n    },\n    unpause: function unpause(unpauseOptions) {\n      if (!state.active) {\n        return this;\n      }\n      state.manuallyPaused = false;\n      if (trapStack[trapStack.length - 1] !== this) {\n        return this;\n      }\n      return this._setPausedState(false, unpauseOptions);\n    },\n    updateContainerElements: function updateContainerElements(containerElements) {\n      var elementsAsArray = [].concat(containerElements).filter(Boolean);\n      state.containers = elementsAsArray.map(function (element) {\n        return typeof element === 'string' ? doc.querySelector(element) : element;\n      });\n      if (state.active) {\n        updateTabbableNodes();\n      }\n      updateObservedNodes();\n      return this;\n    }\n  };\n  Object.defineProperties(trap, {\n    _isManuallyPaused: {\n      value: function value() {\n        return state.manuallyPaused;\n      }\n    },\n    _setPausedState: {\n      value: function value(paused, options) {\n        if (state.paused === paused) {\n          return this;\n        }\n        state.paused = paused;\n        if (paused) {\n          var onPause = getOption(options, 'onPause');\n          var onPostPause = getOption(options, 'onPostPause');\n          onPause === null || onPause === undefined || onPause();\n          removeListeners();\n          updateObservedNodes();\n          onPostPause === null || onPostPause === undefined || onPostPause();\n        } else {\n          var onUnpause = getOption(options, 'onUnpause');\n          var onPostUnpause = getOption(options, 'onPostUnpause');\n          onUnpause === null || onUnpause === undefined || onUnpause();\n          updateTabbableNodes();\n          addListeners();\n          updateObservedNodes();\n          onPostUnpause === null || onPostUnpause === undefined || onPostUnpause();\n        }\n        return this;\n      }\n    }\n  });\n\n  // initialize container elements\n  trap.updateContainerElements(elements);\n  return trap;\n};\n\nexport { createFocusTrap };\n//# sourceMappingURL=focus-trap.esm.js.map\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NamespacedMap = void 0;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * A `Map` implementation which accepts a NamespacedValue as a key, and arbitrary value. The\n * namespaced value must be a string type.\n */\nvar NamespacedMap = /*#__PURE__*/function () {\n  // protected to make tests happy for access\n\n  /**\n   * Creates a new map with optional seed data.\n   * @param {Array<[NS, V]>} initial The seed data.\n   */\n  function NamespacedMap(initial) {\n    _classCallCheck(this, NamespacedMap);\n\n    _defineProperty(this, \"internalMap\", new Map());\n\n    if (initial) {\n      var _iterator = _createForOfIteratorHelper(initial),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var val = _step.value;\n          this.set(val[0], val[1]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }\n  /**\n   * Gets a value from the map. If the value does not exist under\n   * either namespace option, falsy is returned.\n   * @param {NS} key The key.\n   * @returns {Optional<V>} The value, or falsy.\n   */\n\n\n  _createClass(NamespacedMap, [{\n    key: \"get\",\n    value: function get(key) {\n      if (key.name && this.internalMap.has(key.name)) {\n        return this.internalMap.get(key.name);\n      }\n\n      if (key.altName && this.internalMap.has(key.altName)) {\n        return this.internalMap.get(key.altName);\n      }\n\n      return null;\n    }\n    /**\n     * Sets a value in the map.\n     * @param {NS} key The key.\n     * @param {V} val The value.\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(key, val) {\n      if (key.name) {\n        this.internalMap.set(key.name, val);\n      }\n\n      if (key.altName) {\n        this.internalMap.set(key.altName, val);\n      }\n    }\n    /**\n     * Determines if any of the valid namespaced values are present\n     * in the map.\n     * @param {NS} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"has\",\n    value: function has(key) {\n      return !!this.get(key);\n    }\n    /**\n     * Removes all the namespaced values from the map.\n     * @param {NS} key The key.\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      if (key.name) {\n        this.internalMap[\"delete\"](key.name);\n      }\n\n      if (key.altName) {\n        this.internalMap[\"delete\"](key.altName);\n      }\n    }\n    /**\n     * Determines if the map contains a specific namespaced value\n     * instead of the parent NS type.\n     * @param {string} key The key.\n     * @returns {boolean} True if present.\n     */\n\n  }, {\n    key: \"hasNamespaced\",\n    value: function hasNamespaced(key) {\n      return this.internalMap.has(key);\n    }\n    /**\n     * Gets a specific namespaced value from the map instead of the\n     * parent NS type. Returns falsy if not found.\n     * @param {string} key The key.\n     * @returns {Optional<V>} The value, or falsy.\n     */\n\n  }, {\n    key: \"getNamespaced\",\n    value: function getNamespaced(key) {\n      return this.internalMap.get(key);\n    }\n  }]);\n\n  return NamespacedMap;\n}();\n\nexports.NamespacedMap = NamespacedMap;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollStartEvent = exports.PollAnswerSubevent = void 0;\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _MessageEvent2 = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\nvar _events = require(\"../utility/events\");\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll answer. Note that this is represented as a subtype and is\n * not registered as a parsable event - it is implied for usage exclusively\n * within the PollStartEvent parsing.\n */\nvar PollAnswerSubevent = /*#__PURE__*/function (_MessageEvent) {\n  _inherits(PollAnswerSubevent, _MessageEvent);\n\n  var _super = _createSuper(PollAnswerSubevent);\n\n  /**\n   * The answer ID.\n   */\n  function PollAnswerSubevent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollAnswerSubevent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"id\", void 0);\n\n    var id = wireFormat.content.id;\n\n    if (!id || typeof id !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Answer ID must be a non-empty string\");\n    }\n\n    _this.id = id;\n    return _this;\n  }\n\n  _createClass(PollAnswerSubevent, [{\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _objectSpread({\n          id: this.id\n        }, this.serializeMMessageOnly())\n      };\n    }\n    /**\n     * Creates a new PollAnswerSubevent from ID and text.\n     * @param {string} id The answer ID (unique within the poll).\n     * @param {string} text The text.\n     * @returns {PollAnswerSubevent} The representative answer.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(id, text) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: _defineProperty({\n          id: id\n        }, _message_types.M_TEXT.name, text)\n      });\n    }\n  }]);\n\n  return PollAnswerSubevent;\n}(_MessageEvent2.MessageEvent);\n/**\n * Represents a poll start event.\n */\n\n\nexports.PollAnswerSubevent = PollAnswerSubevent;\n\nvar PollStartEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollStartEvent, _ExtensibleEvent);\n\n  var _super2 = _createSuper(PollStartEvent);\n\n  /**\n   * The question being asked, as a MessageEvent node.\n   */\n\n  /**\n   * The interpreted kind of poll. Note that this will infer a value that is known to the\n   * SDK rather than verbatim - this means unknown types will be represented as undisclosed\n   * polls.\n   *\n   * To get the raw kind, use rawKind.\n   */\n\n  /**\n   * The true kind as provided by the event sender. Might not be valid.\n   */\n\n  /**\n   * The maximum number of selections a user is allowed to make.\n   */\n\n  /**\n   * The possible answers for the poll.\n   */\n\n  /**\n   * Creates a new PollStartEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.start primary typed event.\n   * @param {IPartialEvent<M_POLL_START_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollStartEvent(wireFormat) {\n    var _this2;\n\n    _classCallCheck(this, PollStartEvent);\n\n    _this2 = _super2.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this2), \"question\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"kind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"rawKind\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"maxSelections\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this2), \"answers\", void 0);\n\n    var poll = _poll_types.M_POLL_START.findIn(_this2.wireContent);\n\n    if (!poll.question) {\n      throw new _InvalidEventError.InvalidEventError(\"A question is required\");\n    }\n\n    _this2.question = new _MessageEvent2.MessageEvent({\n      type: \"org.matrix.sdk.poll.question\",\n      content: poll.question\n    });\n    _this2.rawKind = poll.kind;\n\n    if (_poll_types.M_POLL_KIND_DISCLOSED.matches(_this2.rawKind)) {\n      _this2.kind = _poll_types.M_POLL_KIND_DISCLOSED;\n    } else {\n      _this2.kind = _poll_types.M_POLL_KIND_UNDISCLOSED; // default & assumed value\n    }\n\n    _this2.maxSelections = Number.isFinite(poll.max_selections) && poll.max_selections > 0 ? poll.max_selections : 1;\n\n    if (!Array.isArray(poll.answers)) {\n      throw new _InvalidEventError.InvalidEventError(\"Poll answers must be an array\");\n    }\n\n    var answers = poll.answers.slice(0, 20).map(function (a) {\n      return new PollAnswerSubevent({\n        type: \"org.matrix.sdk.poll.answer\",\n        content: a\n      });\n    });\n\n    if (answers.length <= 0) {\n      throw new _InvalidEventError.InvalidEventError(\"No answers available\");\n    }\n\n    _this2.answers = answers;\n    return _this2;\n  }\n\n  _createClass(PollStartEvent, [{\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_START);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var _content2;\n\n      return {\n        type: _poll_types.M_POLL_START.name,\n        content: (_content2 = {}, _defineProperty(_content2, _poll_types.M_POLL_START.name, {\n          question: this.question.serialize().content,\n          kind: this.rawKind,\n          max_selections: this.maxSelections,\n          answers: this.answers.map(function (a) {\n            return a.serialize().content;\n          })\n        }), _defineProperty(_content2, _message_types.M_TEXT.name, \"\".concat(this.question.text, \"\\n\").concat(this.answers.map(function (a, i) {\n          return \"\".concat(i + 1, \". \").concat(a.text);\n        }).join(\"\\n\"))), _content2)\n      };\n    }\n    /**\n     * Creates a new PollStartEvent from question, answers, and metadata.\n     * @param {string} question The question to ask.\n     * @param {string} answers The answers. Should be unique within each other.\n     * @param {KNOWN_POLL_KIND|string} kind The kind of poll.\n     * @param {number} maxSelections The maximum number of selections. Must be 1 or higher.\n     * @returns {PollStartEvent} The representative poll start event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(question, answers, kind) {\n      var _content3;\n\n      var maxSelections = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      return new PollStartEvent({\n        type: _poll_types.M_POLL_START.name,\n        content: (_content3 = {}, _defineProperty(_content3, _message_types.M_TEXT.name, question), _defineProperty(_content3, _poll_types.M_POLL_START.name, {\n          question: _defineProperty({}, _message_types.M_TEXT.name, question),\n          kind: kind instanceof _NamespacedValue.NamespacedValue ? kind.name : kind,\n          max_selections: maxSelections,\n          answers: answers.map(function (a) {\n            return _defineProperty({\n              id: makeId()\n            }, _message_types.M_TEXT.name, a);\n          })\n        }), _content3)\n      });\n    }\n  }]);\n\n  return PollStartEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollStartEvent = PollStartEvent;\nvar LETTERS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n\nfunction makeId() {\n  return _toConsumableArray(Array(16)).map(function () {\n    return LETTERS.charAt(Math.floor(Math.random() * LETTERS.length));\n  }).join('');\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.REFERENCE_RELATION = void 0;\n\nvar _NamespacedValue = require(\"../NamespacedValue\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * The namespaced value for an m.reference relation\n */\nvar REFERENCE_RELATION = new _NamespacedValue.NamespacedValue(\"m.reference\");\n/**\n * Represents any relation type\n */\n\nexports.REFERENCE_RELATION = REFERENCE_RELATION;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollResponseEvent = void 0;\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _relationship_types = require(\"./relationship_types\");\n\nvar _events = require(\"../utility/events\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll response event.\n */\nvar PollResponseEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollResponseEvent, _ExtensibleEvent);\n\n  var _super = _createSuper(PollResponseEvent);\n\n  /**\n   * Creates a new PollResponseEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.response primary typed event.\n   *\n   * To validate the response against a poll, call `validateAgainst` after creation.\n   * @param {IPartialEvent<M_POLL_RESPONSE_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollResponseEvent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollResponseEvent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"internalAnswerIds\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"internalSpoiled\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"pollEventId\", void 0);\n\n    var rel = _this.wireContent[\"m.relates_to\"];\n\n    if (!_relationship_types.REFERENCE_RELATION.matches(rel === null || rel === void 0 ? void 0 : rel.rel_type) || typeof (rel === null || rel === void 0 ? void 0 : rel.event_id) !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Relationship must be a reference to an event\");\n    }\n\n    _this.pollEventId = rel.event_id;\n\n    _this.validateAgainst(null);\n\n    return _this;\n  }\n  /**\n   * Validates the poll response using the poll start event as a frame of reference. This\n   * is used to determine if the vote is spoiled, whether the answers are valid, etc.\n   * @param {PollStartEvent} poll The poll start event.\n   */\n\n\n  _createClass(PollResponseEvent, [{\n    key: \"answerIds\",\n    get:\n    /**\n     * The provided answers for the poll. Note that this may be falsy/unpredictable if\n     * the `spoiled` property is true.\n     */\n    function get() {\n      return this.internalAnswerIds;\n    }\n    /**\n     * The poll start event ID referenced by the response.\n     */\n\n  }, {\n    key: \"spoiled\",\n    get:\n    /**\n     * Whether the vote is spoiled.\n     */\n    function get() {\n      return this.internalSpoiled;\n    }\n  }, {\n    key: \"validateAgainst\",\n    value: function validateAgainst(poll) {\n      var response = _poll_types.M_POLL_RESPONSE.findIn(this.wireContent);\n\n      if (!Array.isArray(response === null || response === void 0 ? void 0 : response.answers)) {\n        this.internalSpoiled = true;\n        this.internalAnswerIds = [];\n        return;\n      }\n\n      var answers = response.answers;\n\n      if (answers.some(function (a) {\n        return typeof a !== \"string\";\n      }) || answers.length === 0) {\n        this.internalSpoiled = true;\n        this.internalAnswerIds = [];\n        return;\n      }\n\n      if (poll) {\n        if (answers.some(function (a) {\n          return !poll.answers.some(function (pa) {\n            return pa.id === a;\n          });\n        })) {\n          this.internalSpoiled = true;\n          this.internalAnswerIds = [];\n          return;\n        }\n\n        answers = answers.slice(0, poll.maxSelections);\n      }\n\n      this.internalAnswerIds = answers;\n      this.internalSpoiled = false;\n    }\n  }, {\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_RESPONSE);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: _poll_types.M_POLL_RESPONSE.name,\n        content: _defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: this.pollEventId\n          }\n        }, _poll_types.M_POLL_RESPONSE.name, {\n          answers: this.spoiled ? undefined : this.answerIds\n        })\n      };\n    }\n    /**\n     * Creates a new PollResponseEvent from a set of answers. To spoil the vote, pass an empty\n     * answers array.\n     * @param {string} answers The user's answers. Should be valid from a poll's answer IDs.\n     * @param {string} pollEventId The poll start event ID.\n     * @returns {PollStartEvent} The representative poll response event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(answers, pollEventId) {\n      return new PollResponseEvent({\n        type: _poll_types.M_POLL_RESPONSE.name,\n        content: _defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: pollEventId\n          }\n        }, _poll_types.M_POLL_RESPONSE.name, {\n          answers: answers\n        })\n      });\n    }\n  }]);\n\n  return PollResponseEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollResponseEvent = PollResponseEvent;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PollEndEvent = void 0;\n\nvar _poll_types = require(\"./poll_types\");\n\nvar _InvalidEventError = require(\"../InvalidEventError\");\n\nvar _relationship_types = require(\"./relationship_types\");\n\nvar _MessageEvent = require(\"./MessageEvent\");\n\nvar _message_types = require(\"./message_types\");\n\nvar _events = require(\"../utility/events\");\n\nvar _ExtensibleEvent2 = require(\"./ExtensibleEvent\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Represents a poll end/closure event.\n */\nvar PollEndEvent = /*#__PURE__*/function (_ExtensibleEvent) {\n  _inherits(PollEndEvent, _ExtensibleEvent);\n\n  var _super = _createSuper(PollEndEvent);\n\n  /**\n   * The poll start event ID referenced by the response.\n   */\n\n  /**\n   * The closing message for the event.\n   */\n\n  /**\n   * Creates a new PollEndEvent from a pure format. Note that the event is *not*\n   * parsed here: it will be treated as a literal m.poll.response primary typed event.\n   * @param {IPartialEvent<M_POLL_END_EVENT_CONTENT>} wireFormat The event.\n   */\n  function PollEndEvent(wireFormat) {\n    var _this;\n\n    _classCallCheck(this, PollEndEvent);\n\n    _this = _super.call(this, wireFormat);\n\n    _defineProperty(_assertThisInitialized(_this), \"pollEventId\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"closingMessage\", void 0);\n\n    var rel = _this.wireContent[\"m.relates_to\"];\n\n    if (!_relationship_types.REFERENCE_RELATION.matches(rel === null || rel === void 0 ? void 0 : rel.rel_type) || typeof (rel === null || rel === void 0 ? void 0 : rel.event_id) !== \"string\") {\n      throw new _InvalidEventError.InvalidEventError(\"Relationship must be a reference to an event\");\n    }\n\n    _this.pollEventId = rel.event_id;\n    _this.closingMessage = new _MessageEvent.MessageEvent(_this.wireFormat);\n    return _this;\n  }\n\n  _createClass(PollEndEvent, [{\n    key: \"isEquivalentTo\",\n    value: function isEquivalentTo(primaryEventType) {\n      return (0, _events.isEventTypeSame)(primaryEventType, _poll_types.M_POLL_END);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return {\n        type: _poll_types.M_POLL_END.name,\n        content: _objectSpread(_defineProperty({\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: this.pollEventId\n          }\n        }, _poll_types.M_POLL_END.name, {}), this.closingMessage.serialize().content)\n      };\n    }\n    /**\n     * Creates a new PollEndEvent from a poll event ID.\n     * @param {string} pollEventId The poll start event ID.\n     * @param {string} message A closing message, typically revealing the top answer.\n     * @returns {PollStartEvent} The representative poll closure event.\n     */\n\n  }], [{\n    key: \"from\",\n    value: function from(pollEventId, message) {\n      var _content;\n\n      return new PollEndEvent({\n        type: _poll_types.M_POLL_END.name,\n        content: (_content = {\n          \"m.relates_to\": {\n            rel_type: _relationship_types.REFERENCE_RELATION.name,\n            event_id: pollEventId\n          }\n        }, _defineProperty(_content, _poll_types.M_POLL_END.name, {}), _defineProperty(_content, _message_types.M_TEXT.name, message), _content)\n      });\n    }\n  }]);\n\n  return PollEndEvent;\n}(_ExtensibleEvent2.ExtensibleEvent);\n\nexports.PollEndEvent = PollEndEvent;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseMPoll = parseMPoll;\n\nvar _poll_types = require(\"../../events/poll_types\");\n\nvar _PollStartEvent = require(\"../../events/PollStartEvent\");\n\nvar _PollResponseEvent = require(\"../../events/PollResponseEvent\");\n\nvar _PollEndEvent = require(\"../../events/PollEndEvent\");\n\n/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\nfunction parseMPoll(wireEvent) {\n  if (_poll_types.M_POLL_START.matches(wireEvent.type)) {\n    return new _PollStartEvent.PollStartEvent(wireEvent);\n  } else if (_poll_types.M_POLL_RESPONSE.matches(wireEvent.type)) {\n    return new _PollResponseEvent.PollResponseEvent(wireEvent);\n  } else if (_poll_types.M_POLL_END.matches(wireEvent.type)) {\n    return new _PollEndEvent.PollEndEvent(wireEvent);\n  }\n\n  return null; // not a poll event\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExtensibleEvents = void 0;\n\nvar _NamespacedMap = require(\"./NamespacedMap\");\n\nvar _InvalidEventError = require(\"./InvalidEventError\");\n\nvar _MRoomMessage = require(\"./interpreters/legacy/MRoomMessage\");\n\nvar _MMessage = require(\"./interpreters/modern/MMessage\");\n\nvar _message_types = require(\"./events/message_types\");\n\nvar _poll_types = require(\"./events/poll_types\");\n\nvar _MPoll = require(\"./interpreters/modern/MPoll\");\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Utility class for parsing and identifying event types in a renderable form. An\n * instance of this class can be created to change rendering preference depending\n * on use-case.\n */\nvar ExtensibleEvents = /*#__PURE__*/function () {\n  function ExtensibleEvents() {\n    _classCallCheck(this, ExtensibleEvents);\n\n    _defineProperty(this, \"interpreters\", new _NamespacedMap.NamespacedMap([// Remember to add your unit test when adding to this! (\"known events\" test description)\n    [_MRoomMessage.LEGACY_M_ROOM_MESSAGE, _MRoomMessage.parseMRoomMessage], [_message_types.M_MESSAGE, _MMessage.parseMMessage], [_message_types.M_EMOTE, _MMessage.parseMMessage], [_message_types.M_NOTICE, _MMessage.parseMMessage], [_poll_types.M_POLL_START, _MPoll.parseMPoll], [_poll_types.M_POLL_RESPONSE, _MPoll.parseMPoll], [_poll_types.M_POLL_END, _MPoll.parseMPoll]]));\n\n    _defineProperty(this, \"_unknownInterpretOrder\", [_message_types.M_MESSAGE]);\n  }\n  /**\n   * Gets the default instance for all extensible event parsing.\n   */\n\n\n  _createClass(ExtensibleEvents, [{\n    key: \"unknownInterpretOrder\",\n    get:\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n    function get() {\n      var _this$_unknownInterpr;\n\n      return (_this$_unknownInterpr = this._unknownInterpretOrder) !== null && _this$_unknownInterpr !== void 0 ? _this$_unknownInterpr : [];\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      this._unknownInterpretOrder = val;\n    }\n    /**\n     * Gets the order the internal processor will use for unknown primary\n     * event types.\n     */\n\n  }, {\n    key: \"registerInterpreter\",\n    value:\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n    function registerInterpreter(wireEventType, interpreter) {\n      this.interpreters.set(wireEventType, interpreter);\n    }\n    /**\n     * Registers a primary event type interpreter. Note that the interpreter might be\n     * called with non-primary events if the event is being parsed as a fallback.\n     * @param {NamespacedValue<string, string>} wireEventType The event type.\n     * @param {EventInterpreter} interpreter The interpreter.\n     */\n\n  }, {\n    key: \"parse\",\n    value:\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n    function parse(wireFormat) {\n      try {\n        if (this.interpreters.hasNamespaced(wireFormat.type)) {\n          return this.interpreters.getNamespaced(wireFormat.type)(wireFormat);\n        }\n\n        var _iterator = _createForOfIteratorHelper(this.unknownInterpretOrder),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var tryType = _step.value;\n\n            if (this.interpreters.has(tryType)) {\n              var val = this.interpreters.get(tryType)(wireFormat);\n              if (val) return val;\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n\n        return null; // cannot be parsed\n      } catch (e) {\n        if (e instanceof _InvalidEventError.InvalidEventError) {\n          return null; // fail parsing and move on\n        }\n\n        throw e; // re-throw everything else\n      }\n    }\n    /**\n     * Parses an event, trying the primary event type first. If the primary type is not known\n     * then the content will be inspected to find the most suitable fallback.\n     *\n     * If the parsing failed or was a completely unknown type, this will return falsy.\n     * @param {IPartialEvent<object>} wireFormat The event to parse.\n     * @returns {Optional<ExtensibleEvent>} The parsed extensible event.\n     */\n\n  }], [{\n    key: \"defaultInstance\",\n    get: function get() {\n      return ExtensibleEvents._defaultInstance;\n    }\n  }, {\n    key: \"unknownInterpretOrder\",\n    get: function get() {\n      return ExtensibleEvents.defaultInstance.unknownInterpretOrder;\n    }\n    /**\n     * Sets the order the internal processor will use for unknown primary\n     * event types.\n     * @param {NamespacedValue<string, string>[]} val The parsing order.\n     */\n    ,\n    set: function set(val) {\n      ExtensibleEvents.defaultInstance.unknownInterpretOrder = val;\n    }\n  }, {\n    key: \"registerInterpreter\",\n    value: function registerInterpreter(wireEventType, interpreter) {\n      ExtensibleEvents.defaultInstance.registerInterpreter(wireEventType, interpreter);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(wireFormat) {\n      return ExtensibleEvents.defaultInstance.parse(wireFormat);\n    }\n  }]);\n\n  return ExtensibleEvents;\n}();\n\nexports.ExtensibleEvents = ExtensibleEvents;\n\n_defineProperty(ExtensibleEvents, \"_defaultInstance\", new ExtensibleEvents());","import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2016 - 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { EventTimeline } from \"./event-timeline.js\";\nimport { logger } from \"../logger.js\";\nimport { RoomEvent } from \"./room.js\";\nimport { TypedEventEmitter } from \"./typed-event-emitter.js\";\nimport { RelationsContainer } from \"./relations-container.js\";\nvar DEBUG = true;\n\n/* istanbul ignore next */\nvar debuglog;\nif (DEBUG) {\n  // using bind means that we get to keep useful line numbers in the console\n  debuglog = logger.log.bind(logger);\n} else {\n  /* istanbul ignore next */\n  debuglog = function debuglog() {};\n}\nexport var DuplicateStrategy = /*#__PURE__*/function (DuplicateStrategy) {\n  DuplicateStrategy[\"Ignore\"] = \"ignore\";\n  DuplicateStrategy[\"Replace\"] = \"replace\";\n  return DuplicateStrategy;\n}({});\nexport class EventTimelineSet extends TypedEventEmitter {\n  /**\n   * Construct a set of EventTimeline objects, typically on behalf of a given\n   * room.  A room may have multiple EventTimelineSets for different levels\n   * of filtering.  The global notification list is also an EventTimelineSet, but\n   * lacks a room.\n   *\n   * <p>This is an ordered sequence of timelines, which may or may not\n   * be continuous. Each timeline lists a series of events, as well as tracking\n   * the room state at the start and the end of the timeline (if appropriate).\n   * It also tracks forward and backward pagination tokens, as well as containing\n   * links to the next timeline in the sequence.\n   *\n   * <p>There is one special timeline - the 'live' timeline, which represents the\n   * timeline to which events are being added in real-time as they are received\n   * from the /sync API. Note that you should not retain references to this\n   * timeline - even if it is the current timeline right now, it may not remain\n   * so if the server gives us a timeline gap in /sync.\n   *\n   * <p>In order that we can find events from their ids later, we also maintain a\n   * map from event_id to timeline and index.\n   *\n   * @param room - Room for this timelineSet. May be null for non-room cases, such as the\n   * notification timeline.\n   * @param opts - Options inherited from Room.\n   * @param client - the Matrix client which owns this EventTimelineSet,\n   * can be omitted if room is specified.\n   * @param thread - the thread to which this timeline set relates.\n   * @param threadListType - the type of thread list represented, if any\n   * (e.g., All threads or My threads)\n   */\n  constructor(room) {\n    var _this$room$relations, _this$room, _room$client;\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var client = arguments.length > 2 ? arguments[2] : undefined;\n    var thread = arguments.length > 3 ? arguments[3] : undefined;\n    var threadListType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;\n    super();\n    this.room = room;\n    this.thread = thread;\n    this.threadListType = threadListType;\n    _defineProperty(this, \"relations\", void 0);\n    _defineProperty(this, \"timelineSupport\", void 0);\n    _defineProperty(this, \"displayPendingEvents\", void 0);\n    _defineProperty(this, \"liveTimeline\", void 0);\n    _defineProperty(this, \"timelines\", void 0);\n    _defineProperty(this, \"_eventIdToTimeline\", new Map());\n    _defineProperty(this, \"filter\", void 0);\n    this.timelineSupport = Boolean(opts.timelineSupport);\n    this.liveTimeline = new EventTimeline(this);\n    this.displayPendingEvents = opts.pendingEvents !== false;\n\n    // just a list - *not* ordered.\n    this.timelines = [this.liveTimeline];\n    this._eventIdToTimeline = new Map();\n    this.filter = opts.filter;\n    this.relations = (_this$room$relations = (_this$room = this.room) === null || _this$room === void 0 ? void 0 : _this$room.relations) !== null && _this$room$relations !== void 0 ? _this$room$relations : new RelationsContainer((_room$client = room === null || room === void 0 ? void 0 : room.client) !== null && _room$client !== void 0 ? _room$client : client);\n  }\n\n  /**\n   * Get all the timelines in this set\n   * @returns the timelines in this set\n   */\n  getTimelines() {\n    return this.timelines;\n  }\n\n  /**\n   * Get the filter object this timeline set is filtered on, if any\n   * @returns the optional filter for this timelineSet\n   */\n  getFilter() {\n    return this.filter;\n  }\n\n  /**\n   * Set the filter object this timeline set is filtered on\n   * (passed to the server when paginating via /messages).\n   * @param filter - the filter for this timelineSet\n   */\n  setFilter(filter) {\n    this.filter = filter;\n  }\n\n  /**\n   * Get the list of pending sent events for this timelineSet's room, filtered\n   * by the timelineSet's filter if appropriate.\n   *\n   * @returns A list of the sent events\n   * waiting for remote echo.\n   *\n   * @throws If `opts.pendingEventOrdering` was not 'detached'\n   */\n  getPendingEvents() {\n    if (!this.room || !this.displayPendingEvents) {\n      return [];\n    }\n    return this.room.getPendingEvents();\n  }\n  /**\n   * Get the live timeline for this room.\n   *\n   * @returns live timeline\n   */\n  getLiveTimeline() {\n    return this.liveTimeline;\n  }\n\n  /**\n   * Set the live timeline for this room.\n   *\n   * @returns live timeline\n   */\n  setLiveTimeline(timeline) {\n    this.liveTimeline = timeline;\n  }\n\n  /**\n   * Return the timeline (if any) this event is in.\n   * @param eventId - the eventId being sought\n   * @returns timeline\n   */\n  eventIdToTimeline(eventId) {\n    return this._eventIdToTimeline.get(eventId);\n  }\n\n  /**\n   * Track a new event as if it were in the same timeline as an old event,\n   * replacing it.\n   * @param oldEventId -  event ID of the original event\n   * @param newEventId -  event ID of the replacement event\n   */\n  replaceEventId(oldEventId, newEventId) {\n    var existingTimeline = this._eventIdToTimeline.get(oldEventId);\n    if (existingTimeline) {\n      this._eventIdToTimeline.delete(oldEventId);\n      this._eventIdToTimeline.set(newEventId, existingTimeline);\n    }\n  }\n\n  /**\n   * Reset the live timeline, and start a new one.\n   *\n   * <p>This is used when /sync returns a 'limited' timeline.\n   *\n   * @param backPaginationToken -   token for back-paginating the new timeline\n   * @param forwardPaginationToken - token for forward-paginating the old live timeline,\n   * if absent or null, all timelines are reset.\n   *\n   * @remarks\n   * Fires {@link RoomEvent.TimelineReset}\n   */\n  resetLiveTimeline(backPaginationToken, forwardPaginationToken) {\n    // Each EventTimeline has RoomState objects tracking the state at the start\n    // and end of that timeline. The copies at the end of the live timeline are\n    // special because they will have listeners attached to monitor changes to\n    // the current room state, so we move this RoomState from the end of the\n    // current live timeline to the end of the new one and, if necessary,\n    // replace it with a newly created one. We also make a copy for the start\n    // of the new timeline.\n\n    // if timeline support is disabled, forget about the old timelines\n    var resetAllTimelines = !this.timelineSupport || !forwardPaginationToken;\n    var oldTimeline = this.liveTimeline;\n    var newTimeline = resetAllTimelines ? oldTimeline.forkLive(EventTimeline.FORWARDS) : oldTimeline.fork(EventTimeline.FORWARDS);\n    if (resetAllTimelines) {\n      this.timelines = [newTimeline];\n      this._eventIdToTimeline = new Map();\n    } else {\n      this.timelines.push(newTimeline);\n    }\n    if (forwardPaginationToken) {\n      // Now set the forward pagination token on the old live timeline\n      // so it can be forward-paginated.\n      oldTimeline.setPaginationToken(forwardPaginationToken, EventTimeline.FORWARDS);\n    }\n\n    // make sure we set the pagination token before firing timelineReset,\n    // otherwise clients which start back-paginating will fail, and then get\n    // stuck without realising that they *can* back-paginate.\n    newTimeline.setPaginationToken(backPaginationToken !== null && backPaginationToken !== void 0 ? backPaginationToken : null, EventTimeline.BACKWARDS);\n\n    // Now we can swap the live timeline to the new one.\n    this.liveTimeline = newTimeline;\n    this.emit(RoomEvent.TimelineReset, this.room, this, resetAllTimelines);\n  }\n\n  /**\n   * Get the timeline which contains the given event, if any\n   *\n   * @param eventId -  event ID to look for\n   * @returns timeline containing\n   * the given event, or null if unknown\n   */\n  getTimelineForEvent(eventId) {\n    if (eventId === null || eventId === undefined) {\n      return null;\n    }\n    var res = this._eventIdToTimeline.get(eventId);\n    return res === undefined ? null : res;\n  }\n\n  /**\n   * Get an event which is stored in our timelines\n   *\n   * @param eventId -  event ID to look for\n   * @returns the given event, or undefined if unknown\n   */\n  findEventById(eventId) {\n    var tl = this.getTimelineForEvent(eventId);\n    if (!tl) {\n      return undefined;\n    }\n    return tl.getEvents().find(function (ev) {\n      return ev.getId() == eventId;\n    });\n  }\n\n  /**\n   * Add a new timeline to this timeline list\n   *\n   * @returns newly-created timeline\n   */\n  addTimeline() {\n    if (!this.timelineSupport) {\n      throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable\" + \" it.\");\n    }\n    var timeline = new EventTimeline(this);\n    this.timelines.push(timeline);\n    return timeline;\n  }\n\n  /**\n   * Add events to a timeline\n   *\n   * <p>Will fire \"Room.timeline\" for each event added.\n   *\n   * @param events - A list of events to add.\n   *\n   * @param toStartOfTimeline -   True to add these events to the start\n   * (oldest) instead of the end (newest) of the timeline. If true, the oldest\n   * event will be the <b>last</b> element of 'events'.\n   *\n   * @param timeline -   timeline to\n   *    add events to.\n   *\n   * @param paginationToken -   token for the next batch of events\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   *\n   */\n  addEventsToTimeline(events, toStartOfTimeline, addToState, timeline, paginationToken) {\n    if (!timeline) {\n      throw new Error(\"'timeline' not specified for EventTimelineSet.addEventsToTimeline\");\n    }\n    if (!toStartOfTimeline && timeline == this.liveTimeline) {\n      throw new Error(\"EventTimelineSet.addEventsToTimeline cannot be used for adding events to \" + \"the live timeline - use Room.addLiveEvents instead\");\n    }\n    if (this.filter) {\n      events = this.filter.filterRoomTimeline(events);\n      if (!events.length) {\n        return;\n      }\n    }\n    var direction = toStartOfTimeline ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n    var inverseDirection = toStartOfTimeline ? EventTimeline.FORWARDS : EventTimeline.BACKWARDS;\n\n    // Adding events to timelines can be quite complicated. The following\n    // illustrates some of the corner-cases.\n    //\n    // Let's say we start by knowing about four timelines. timeline3 and\n    // timeline4 are neighbours:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M]          [P]          [S] <------> [T]\n    //\n    // Now we paginate timeline1, and get the following events from the server:\n    // [M, N, P, R, S, T, U].\n    //\n    // 1. First, we ignore event M, since we already know about it.\n    //\n    // 2. Next, we append N to timeline 1.\n    //\n    // 3. Next, we don't add event P, since we already know about it,\n    //    but we do link together the timelines. We now have:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P]          [S] <------> [T]\n    //\n    // 4. Now we add event R to timeline2:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R]       [S] <------> [T]\n    //\n    //    Note that we have switched the timeline we are working on from\n    //    timeline1 to timeline2.\n    //\n    // 5. We ignore event S, but again join the timelines:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R] <---> [S] <------> [T]\n    //\n    // 6. We ignore event T, and the timelines are already joined, so there\n    //    is nothing to do.\n    //\n    // 7. Finally, we add event U to timeline4:\n    //\n    //    timeline1    timeline2    timeline3    timeline4\n    //      [M, N] <---> [P, R] <---> [S] <------> [T, U]\n    //\n    // The important thing to note in the above is what happened when we\n    // already knew about a given event:\n    //\n    //   - if it was appropriate, we joined up the timelines (steps 3, 5).\n    //   - in any case, we started adding further events to the timeline which\n    //       contained the event we knew about (steps 3, 5, 6).\n    //\n    //\n    // So much for adding events to the timeline. But what do we want to do\n    // with the pagination token?\n    //\n    // In the case above, we will be given a pagination token which tells us how to\n    // get events beyond 'U' - in this case, it makes sense to store this\n    // against timeline4. But what if timeline4 already had 'U' and beyond? in\n    // that case, our best bet is to throw away the pagination token we were\n    // given and stick with whatever token timeline4 had previously. In short,\n    // we want to only store the pagination token if the last event we receive\n    // is one we didn't previously know about.\n    //\n    // We make an exception for this if it turns out that we already knew about\n    // *all* of the events, and we weren't able to join up any timelines. When\n    // that happens, it means our existing pagination token is faulty, since it\n    // is only telling us what we already know. Rather than repeatedly\n    // paginating with the same token, we might as well use the new pagination\n    // token in the hope that we eventually work our way out of the mess.\n\n    var didUpdate = false;\n    var lastEventWasNew = false;\n    for (var event of events) {\n      var eventId = event.getId();\n      var existingTimeline = this._eventIdToTimeline.get(eventId);\n      if (!existingTimeline) {\n        // we don't know about this event yet. Just add it to the timeline.\n        this.addEventToTimeline(event, timeline, {\n          toStartOfTimeline,\n          addToState\n        });\n        lastEventWasNew = true;\n        didUpdate = true;\n        continue;\n      }\n      lastEventWasNew = false;\n      if (existingTimeline == timeline) {\n        debuglog(\"Event \" + eventId + \" already in timeline \" + timeline);\n        continue;\n      }\n      var neighbour = timeline.getNeighbouringTimeline(direction);\n      if (neighbour) {\n        // this timeline already has a neighbour in the relevant direction;\n        // let's assume the timelines are already correctly linked up, and\n        // skip over to it.\n        //\n        // there's probably some edge-case here where we end up with an\n        // event which is in a timeline a way down the chain, and there is\n        // a break in the chain somewhere. But I can't really imagine how\n        // that would happen, so I'm going to ignore it for now.\n        //\n        if (existingTimeline == neighbour) {\n          debuglog(\"Event \" + eventId + \" in neighbouring timeline - \" + \"switching to \" + existingTimeline);\n        } else {\n          debuglog(\"Event \" + eventId + \" already in a different \" + \"timeline \" + existingTimeline);\n        }\n        timeline = existingTimeline;\n        continue;\n      }\n\n      // time to join the timelines.\n      logger.info(\"Already have timeline for \" + eventId + \" - joining timeline \" + timeline + \" to \" + existingTimeline);\n\n      // Variables to keep the line length limited below.\n      var existingIsLive = existingTimeline === this.liveTimeline;\n      var timelineIsLive = timeline === this.liveTimeline;\n      var backwardsIsLive = direction === EventTimeline.BACKWARDS && existingIsLive;\n      var forwardsIsLive = direction === EventTimeline.FORWARDS && timelineIsLive;\n      if (backwardsIsLive || forwardsIsLive) {\n        // The live timeline should never be spliced into a non-live position.\n        // We use independent logging to better discover the problem at a glance.\n        if (backwardsIsLive) {\n          logger.warn(\"Refusing to set a preceding existingTimeLine on our \" + \"timeline as the existingTimeLine is live (\" + existingTimeline + \")\");\n        }\n        if (forwardsIsLive) {\n          logger.warn(\"Refusing to set our preceding timeline on a existingTimeLine \" + \"as our timeline is live (\" + timeline + \")\");\n        }\n        continue; // abort splicing - try next event\n      }\n      timeline.setNeighbouringTimeline(existingTimeline, direction);\n      existingTimeline.setNeighbouringTimeline(timeline, inverseDirection);\n      timeline = existingTimeline;\n      didUpdate = true;\n    }\n\n    // see above - if the last event was new to us, or if we didn't find any\n    // new information, we update the pagination token for whatever\n    // timeline we ended up on.\n    if (lastEventWasNew || !didUpdate) {\n      if (direction === EventTimeline.FORWARDS && timeline === this.liveTimeline) {\n        logger.warn({\n          lastEventWasNew,\n          didUpdate\n        }); // for debugging\n        logger.warn(\"Refusing to set forwards pagination token of live timeline \" + \"\".concat(timeline, \" to \").concat(paginationToken));\n        return;\n      }\n      timeline.setPaginationToken(paginationToken !== null && paginationToken !== void 0 ? paginationToken : null, direction);\n    }\n  }\n\n  /**\n   * Add an event to the end of this live timeline.\n   *\n   * @param event - Event to be added\n   * @param options - addLiveEvent options\n   */\n  addLiveEvent(event, _ref) {\n    var {\n      duplicateStrategy,\n      fromCache,\n      roomState,\n      timelineWasEmpty,\n      addToState\n    } = _ref;\n    if (this.filter) {\n      var events = this.filter.filterRoomTimeline([event]);\n      if (!events.length) {\n        return;\n      }\n    }\n    var timeline = this._eventIdToTimeline.get(event.getId());\n    if (timeline) {\n      if (duplicateStrategy === DuplicateStrategy.Replace) {\n        debuglog(\"EventTimelineSet.addLiveEvent: replacing duplicate event \" + event.getId());\n        var tlEvents = timeline.getEvents();\n        for (var j = 0; j < tlEvents.length; j++) {\n          if (tlEvents[j].getId() === event.getId()) {\n            // still need to set the right metadata on this event\n            if (!roomState) {\n              roomState = timeline.getState(EventTimeline.FORWARDS);\n            }\n            EventTimeline.setEventMetadata(event, roomState, false);\n            tlEvents[j] = event;\n\n            // XXX: we need to fire an event when this happens.\n            break;\n          }\n        }\n      } else {\n        debuglog(\"EventTimelineSet.addLiveEvent: ignoring duplicate event \" + event.getId());\n      }\n      return;\n    }\n    this.addEventToTimeline(event, this.liveTimeline, {\n      toStartOfTimeline: false,\n      fromCache,\n      roomState,\n      timelineWasEmpty,\n      addToState\n    });\n  }\n\n  /**\n   * Add event to the given timeline, and emit Room.timeline. Assumes\n   * we have already checked we don't know about this event.\n   *\n   * Will fire \"Room.timeline\" for each event added.\n   *\n   * @param event - the event to add\n   * @param timeline - the timeline onto which to add it\n   * @param options - addEventToTimeline options\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n  addEventToTimeline(event, timeline, _ref2) {\n    var {\n      toStartOfTimeline,\n      fromCache = false,\n      roomState,\n      timelineWasEmpty,\n      addToState\n    } = _ref2;\n    if (timeline.getTimelineSet() !== this) {\n      var _this$thread;\n      throw new Error(\"EventTimelineSet.addEventToTimeline: Timeline=\".concat(timeline.toString(), \" does not belong \\\" +\\n                \\\"in timelineSet(threadId=\").concat((_this$thread = this.thread) === null || _this$thread === void 0 ? void 0 : _this$thread.id, \")\"));\n    }\n    var eventId = event.getId();\n    this.relations.aggregateParentEvent(event);\n    this.relations.aggregateChildEvent(event, this);\n\n    // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n    // threaded message should not be in the main timeline).\n    //\n    // We can only run this check for timelines with a `room` because `canContain`\n    // requires it\n    if (this.room && !this.canContain(event)) {\n      var _this$thread2;\n      var eventDebugString = \"event=\".concat(eventId);\n      if (event.threadRootId) {\n        eventDebugString += \"(belongs to thread=\".concat(event.threadRootId, \")\");\n      }\n      logger.warn(\"EventTimelineSet.addEventToTimeline: Ignoring \".concat(eventDebugString, \" that does not belong \") + \"in timeline=\".concat(timeline.toString(), \" timelineSet(threadId=\").concat((_this$thread2 = this.thread) === null || _this$thread2 === void 0 ? void 0 : _this$thread2.id, \")\"));\n      return;\n    }\n    timeline.addEvent(event, {\n      toStartOfTimeline,\n      roomState,\n      timelineWasEmpty,\n      addToState\n    });\n    this._eventIdToTimeline.set(eventId, timeline);\n    var data = {\n      timeline: timeline,\n      liveEvent: !toStartOfTimeline && timeline == this.liveTimeline && !fromCache\n    };\n    this.emit(RoomEvent.Timeline, event, this.room, Boolean(toStartOfTimeline), false, data);\n  }\n\n  /**\n   * Insert event to the given timeline, and emit Room.timeline. Assumes\n   * we have already checked we don't know about this event.\n   *\n   * TEMPORARY: until we have recursive relations, we need this function\n   * to exist to allow us to insert events in timeline order, which is our\n   * best guess for Sync Order.\n   * This is a copy of addEventToTimeline above, modified to insert the event\n   * after the event it relates to, and before any event with a later\n   * timestamp. This is our best guess at Sync Order.\n   *\n   * Will fire \"Room.timeline\" for each event added.\n   *\n   * @internal\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n  insertEventIntoTimeline(event, timeline, roomState, addToState) {\n    if (timeline.getTimelineSet() !== this) {\n      var _this$thread3;\n      throw new Error(\"EventTimelineSet.insertEventIntoTimeline: Timeline=\".concat(timeline.toString(), \" does not belong \\\" +\\n                \\\"in timelineSet(threadId=\").concat((_this$thread3 = this.thread) === null || _this$thread3 === void 0 ? void 0 : _this$thread3.id, \")\"));\n    }\n    var eventId = event.getId();\n    this.relations.aggregateParentEvent(event);\n    this.relations.aggregateChildEvent(event, this);\n\n    // Make sure events don't get mixed in timelines they shouldn't be in (e.g. a\n    // threaded message should not be in the main timeline).\n    //\n    // We can only run this check for timelines with a `room` because `canContain`\n    // requires it\n    if (this.room && !this.canContain(event)) {\n      var _this$thread4;\n      var eventDebugString = \"event=\".concat(eventId);\n      if (event.threadRootId) {\n        eventDebugString += \"(belongs to thread=\".concat(event.threadRootId, \")\");\n      }\n      logger.warn(\"EventTimelineSet.insertEventIntoTimeline: Ignoring \".concat(eventDebugString, \" that does not belong \") + \"in timeline=\".concat(timeline.toString(), \" timelineSet(threadId=\").concat((_this$thread4 = this.thread) === null || _this$thread4 === void 0 ? void 0 : _this$thread4.id, \")\"));\n      return;\n    }\n\n    // Find the event that this event is related to - the \"parent\"\n    var parentEventId = event.relationEventId;\n    if (!parentEventId) {\n      // Not related to anything - we just append\n      this.addEventToTimeline(event, timeline, {\n        toStartOfTimeline: false,\n        fromCache: false,\n        timelineWasEmpty: false,\n        roomState,\n        addToState\n      });\n      return;\n    }\n    var parentEvent = this.findEventById(parentEventId);\n    var timelineEvents = timeline.getEvents();\n\n    // Start searching from the parent event, or if it's not loaded, start\n    // at the beginning and insert purely using timestamp order.\n    var parentIndex = parentEvent !== undefined ? timelineEvents.indexOf(parentEvent) : 0;\n    var insertIndex = parentIndex;\n    for (; insertIndex < timelineEvents.length; insertIndex++) {\n      var nextEvent = timelineEvents[insertIndex];\n      if (nextEvent.getTs() > event.getTs()) {\n        // We found an event later than ours, so insert before that.\n        break;\n      }\n    }\n    // If we got to the end of the loop, insertIndex points at the end of\n    // the list.\n\n    timeline.insertEvent(event, insertIndex, roomState, addToState);\n    this._eventIdToTimeline.set(eventId, timeline);\n    var data = {\n      timeline: timeline,\n      // The purpose of this method is inserting events in the middle of the\n      // timeline, so the events are, by definition, not live (whether or not\n      // we're adding them to the live timeline).\n      liveEvent: false\n    };\n    this.emit(RoomEvent.Timeline, event, this.room, false, false, data);\n  }\n\n  /**\n   * Replaces event with ID oldEventId with one with newEventId, if oldEventId is\n   * recognised.  Otherwise, add to the live timeline.  Used to handle remote echos.\n   *\n   * @param localEvent -     the new event to be added to the timeline\n   * @param oldEventId -          the ID of the original event\n   * @param newEventId -         the ID of the replacement event\n   *\n   * @remarks\n   * Fires {@link RoomEvent.Timeline}\n   */\n  handleRemoteEcho(localEvent, oldEventId, newEventId) {\n    // XXX: why don't we infer newEventId from localEvent?\n    var existingTimeline = this._eventIdToTimeline.get(oldEventId);\n    if (existingTimeline) {\n      this._eventIdToTimeline.delete(oldEventId);\n      this._eventIdToTimeline.set(newEventId, existingTimeline);\n    } else if (!this.filter || this.filter.filterRoomTimeline([localEvent]).length) {\n      this.addEventToTimeline(localEvent, this.liveTimeline, {\n        toStartOfTimeline: false,\n        addToState: false\n      });\n    }\n  }\n\n  /**\n   * Removes a single event from this room.\n   *\n   * @param eventId -  The id of the event to remove\n   *\n   * @returns the removed event, or null if the event was not found\n   * in this room.\n   */\n  removeEvent(eventId) {\n    var timeline = this._eventIdToTimeline.get(eventId);\n    if (!timeline) {\n      return null;\n    }\n    var removed = timeline.removeEvent(eventId);\n    if (removed) {\n      this._eventIdToTimeline.delete(eventId);\n      var data = {\n        timeline: timeline\n      };\n      this.emit(RoomEvent.Timeline, removed, this.room, undefined, true, data);\n    }\n    return removed;\n  }\n\n  /**\n   * Determine where two events appear in the timeline relative to one another\n   *\n   * @param eventId1 -   The id of the first event\n   * @param eventId2 -   The id of the second event\n    * @returns -1 if eventId1 precedes eventId2, and +1 eventId1 succeeds\n   * eventId2. 0 if they are the same event; null if we can't tell (either\n   * because we don't know about one of the events, or because they are in\n   * separate timelines which don't join up).\n   */\n  compareEventOrdering(eventId1, eventId2) {\n    if (eventId1 == eventId2) {\n      // optimise this case\n      return 0;\n    }\n    var timeline1 = this._eventIdToTimeline.get(eventId1);\n    var timeline2 = this._eventIdToTimeline.get(eventId2);\n    if (timeline1 === undefined) {\n      return null;\n    }\n    if (timeline2 === undefined) {\n      return null;\n    }\n    if (timeline1 === timeline2) {\n      // both events are in the same timeline - figure out their relative indices\n      var idx1 = undefined;\n      var idx2 = undefined;\n      var events = timeline1.getEvents();\n      for (var idx = 0; idx < events.length && (idx1 === undefined || idx2 === undefined); idx++) {\n        var evId = events[idx].getId();\n        if (evId == eventId1) {\n          idx1 = idx;\n        }\n        if (evId == eventId2) {\n          idx2 = idx;\n        }\n      }\n      var difference = idx1 - idx2;\n\n      // Return the sign of difference.\n      if (difference < 0) {\n        return -1;\n      } else if (difference > 0) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n\n    // the events are in different timelines. Iterate through the\n    // linkedlist to see which comes first.\n\n    // first work forwards from timeline1\n    var tl = timeline1;\n    while (tl) {\n      if (tl === timeline2) {\n        // timeline1 is before timeline2\n        return -1;\n      }\n      tl = tl.getNeighbouringTimeline(EventTimeline.FORWARDS);\n    }\n\n    // now try backwards from timeline1\n    tl = timeline1;\n    while (tl) {\n      if (tl === timeline2) {\n        // timeline2 is before timeline1\n        return 1;\n      }\n      tl = tl.getNeighbouringTimeline(EventTimeline.BACKWARDS);\n    }\n\n    // the timelines are not contiguous.\n    return null;\n  }\n\n  /**\n   * Determine whether a given event can sanely be added to this event timeline set,\n   * for timeline sets relating to a thread, only return true for events in the same\n   * thread timeline, for timeline sets not relating to a thread only return true\n   * for events which should be shown in the main room timeline.\n   * Requires the `room` property to have been set at EventTimelineSet construction time.\n   *\n   * @param event - the event to check whether it belongs to this timeline set.\n   * @throws Error if `room` was not set when constructing this timeline set.\n   * @returns whether the event belongs to this timeline set.\n   */\n  canContain(event) {\n    if (!this.room) {\n      throw new Error(\"Cannot call `EventTimelineSet::canContain without a `room` set. \" + \"Set the room when creating the EventTimelineSet to call this method.\");\n    }\n    var {\n      threadId,\n      shouldLiveInRoom,\n      shouldLiveInThread\n    } = this.room.eventShouldLiveIn(event);\n    if (this.thread) {\n      return this.thread.id === threadId;\n    }\n    if (!shouldLiveInRoom && !shouldLiveInThread) {\n      var _this$room2;\n      logger.warn(\"EventTimelineSet:canContain event encountered which cannot be added to any timeline roomId=\".concat((_this$room2 = this.room) === null || _this$room2 === void 0 ? void 0 : _this$room2.roomId, \" eventId=\").concat(event.getId(), \" threadId=\").concat(event.threadRootId));\n    }\n    return shouldLiveInRoom;\n  }\n}\n//# sourceMappingURL=event-timeline-set.js.map","/*!\n * content-type\n * Copyright(c) 2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * RegExp to match *( \";\" parameter ) in RFC 7231 sec 3.1.1.1\n *\n * parameter     = token \"=\" ( token / quoted-string )\n * token         = 1*tchar\n * tchar         = \"!\" / \"#\" / \"$\" / \"%\" / \"&\" / \"'\" / \"*\"\n *               / \"+\" / \"-\" / \".\" / \"^\" / \"_\" / \"`\" / \"|\" / \"~\"\n *               / DIGIT / ALPHA\n *               ; any VCHAR, except delimiters\n * quoted-string = DQUOTE *( qdtext / quoted-pair ) DQUOTE\n * qdtext        = HTAB / SP / %x21 / %x23-5B / %x5D-7E / obs-text\n * obs-text      = %x80-FF\n * quoted-pair   = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n */\nvar PARAM_REGEXP = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *(\"(?:[\\u000b\\u0020\\u0021\\u0023-\\u005b\\u005d-\\u007e\\u0080-\\u00ff]|\\\\[\\u000b\\u0020-\\u00ff])*\"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g // eslint-disable-line no-control-regex\nvar TEXT_REGEXP = /^[\\u000b\\u0020-\\u007e\\u0080-\\u00ff]+$/ // eslint-disable-line no-control-regex\nvar TOKEN_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * RegExp to match quoted-pair in RFC 7230 sec 3.2.6\n *\n * quoted-pair = \"\\\" ( HTAB / SP / VCHAR / obs-text )\n * obs-text    = %x80-FF\n */\nvar QESC_REGEXP = /\\\\([\\u000b\\u0020-\\u00ff])/g // eslint-disable-line no-control-regex\n\n/**\n * RegExp to match chars that must be quoted-pair in RFC 7230 sec 3.2.6\n */\nvar QUOTE_REGEXP = /([\\\\\"])/g\n\n/**\n * RegExp to match type in RFC 7231 sec 3.1.1.1\n *\n * media-type = type \"/\" subtype\n * type       = token\n * subtype    = token\n */\nvar TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/\n\n/**\n * Module exports.\n * @public\n */\n\nexports.format = format\nexports.parse = parse\n\n/**\n * Format object to media type.\n *\n * @param {object} obj\n * @return {string}\n * @public\n */\n\nfunction format (obj) {\n  if (!obj || typeof obj !== 'object') {\n    throw new TypeError('argument obj is required')\n  }\n\n  var parameters = obj.parameters\n  var type = obj.type\n\n  if (!type || !TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid type')\n  }\n\n  var string = type\n\n  // append parameters\n  if (parameters && typeof parameters === 'object') {\n    var param\n    var params = Object.keys(parameters).sort()\n\n    for (var i = 0; i < params.length; i++) {\n      param = params[i]\n\n      if (!TOKEN_REGEXP.test(param)) {\n        throw new TypeError('invalid parameter name')\n      }\n\n      string += '; ' + param + '=' + qstring(parameters[param])\n    }\n  }\n\n  return string\n}\n\n/**\n * Parse media type to object.\n *\n * @param {string|object} string\n * @return {Object}\n * @public\n */\n\nfunction parse (string) {\n  if (!string) {\n    throw new TypeError('argument string is required')\n  }\n\n  // support req/res-like objects as argument\n  var header = typeof string === 'object'\n    ? getcontenttype(string)\n    : string\n\n  if (typeof header !== 'string') {\n    throw new TypeError('argument string is required to be a string')\n  }\n\n  var index = header.indexOf(';')\n  var type = index !== -1\n    ? header.slice(0, index).trim()\n    : header.trim()\n\n  if (!TYPE_REGEXP.test(type)) {\n    throw new TypeError('invalid media type')\n  }\n\n  var obj = new ContentType(type.toLowerCase())\n\n  // parse parameters\n  if (index !== -1) {\n    var key\n    var match\n    var value\n\n    PARAM_REGEXP.lastIndex = index\n\n    while ((match = PARAM_REGEXP.exec(header))) {\n      if (match.index !== index) {\n        throw new TypeError('invalid parameter format')\n      }\n\n      index += match[0].length\n      key = match[1].toLowerCase()\n      value = match[2]\n\n      if (value.charCodeAt(0) === 0x22 /* \" */) {\n        // remove quotes\n        value = value.slice(1, -1)\n\n        // remove escapes\n        if (value.indexOf('\\\\') !== -1) {\n          value = value.replace(QESC_REGEXP, '$1')\n        }\n      }\n\n      obj.parameters[key] = value\n    }\n\n    if (index !== header.length) {\n      throw new TypeError('invalid parameter format')\n    }\n  }\n\n  return obj\n}\n\n/**\n * Get content-type from req/res objects.\n *\n * @param {object}\n * @return {Object}\n * @private\n */\n\nfunction getcontenttype (obj) {\n  var header\n\n  if (typeof obj.getHeader === 'function') {\n    // res-like\n    header = obj.getHeader('content-type')\n  } else if (typeof obj.headers === 'object') {\n    // req-like\n    header = obj.headers && obj.headers['content-type']\n  }\n\n  if (typeof header !== 'string') {\n    throw new TypeError('content-type header is missing from object')\n  }\n\n  return header\n}\n\n/**\n * Quote a string if necessary.\n *\n * @param {string} val\n * @return {string}\n * @private\n */\n\nfunction qstring (val) {\n  var str = String(val)\n\n  // no need to quote tokens\n  if (TOKEN_REGEXP.test(str)) {\n    return str\n  }\n\n  if (str.length > 0 && !TEXT_REGEXP.test(str)) {\n    throw new TypeError('invalid parameter value')\n  }\n\n  return '\"' + str.replace(QUOTE_REGEXP, '\\\\$1') + '\"'\n}\n\n/**\n * Class to represent a content type.\n * @private\n */\nfunction ContentType (type) {\n  this.parameters = Object.create(null)\n  this.type = type\n}\n","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\n/*\nCopyright 2022 - 2024 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { parse as parseContentType } from \"content-type\";\nimport { logger } from \"../logger.js\";\nimport { sleep } from \"../utils.js\";\nimport { ConnectionError, HTTPError, MatrixError, safeGetRetryAfterMs } from \"./errors.js\";\n\n// Ponyfill for https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/timeout\nexport function timeoutSignal(ms) {\n  var controller = new AbortController();\n  setTimeout(() => {\n    controller.abort();\n  }, ms);\n  return controller.signal;\n}\nexport function anySignal(signals) {\n  var controller = new AbortController();\n  function cleanup() {\n    for (var signal of signals) {\n      signal.removeEventListener(\"abort\", onAbort);\n    }\n  }\n  function onAbort() {\n    controller.abort();\n    cleanup();\n  }\n  for (var signal of signals) {\n    if (signal.aborted) {\n      onAbort();\n      break;\n    }\n    signal.addEventListener(\"abort\", onAbort);\n  }\n  return {\n    signal: controller.signal,\n    cleanup\n  };\n}\n\n/**\n * Attempt to turn an HTTP error response into a Javascript Error.\n *\n * If it is a JSON response, we will parse it into a MatrixError. Otherwise\n * we return a generic Error.\n *\n * @param response - response object\n * @param body - raw body of the response\n * @returns\n */\nexport function parseErrorResponse(response, body) {\n  var _contentType, _contentType2;\n  var httpHeaders = isXhr(response) ? new Headers(response.getAllResponseHeaders().trim().split(/[\\r\\n]+/).map(header => {\n    var colonIdx = header.indexOf(\":\");\n    return [header.substring(0, colonIdx), header.substring(colonIdx + 1)];\n  })) : response.headers;\n  var contentType;\n  try {\n    contentType = getResponseContentType(httpHeaders);\n  } catch (e) {\n    return e;\n  }\n  if (((_contentType = contentType) === null || _contentType === void 0 ? void 0 : _contentType.type) === \"application/json\" && body) {\n    return new MatrixError(JSON.parse(body), response.status, isXhr(response) ? response.responseURL : response.url, undefined, httpHeaders);\n  }\n  if (((_contentType2 = contentType) === null || _contentType2 === void 0 ? void 0 : _contentType2.type) === \"text/plain\") {\n    return new HTTPError(\"Server returned \".concat(response.status, \" error: \").concat(body), response.status, httpHeaders);\n  }\n  return new HTTPError(\"Server returned \".concat(response.status, \" error\"), response.status, httpHeaders);\n}\nfunction isXhr(response) {\n  return \"getResponseHeader\" in response;\n}\n\n/**\n * extract the Content-Type header from response headers, and\n * parse it to a `{type, parameters}` object.\n *\n * returns null if no content-type header could be found.\n *\n * @param response - response object\n * @returns parsed content-type header, or null if not found\n */\nfunction getResponseContentType(headers) {\n  var contentType = headers.get(\"Content-Type\");\n  if (contentType === null) return null;\n  try {\n    return parseContentType(contentType);\n  } catch (e) {\n    throw new Error(\"Error parsing Content-Type '\".concat(contentType, \"': \").concat(e));\n  }\n}\n\n/**\n * Retries a network operation run in a callback.\n * @param maxAttempts - maximum attempts to try\n * @param callback - callback that returns a promise of the network operation. If rejected with ConnectionError, it will be retried by calling the callback again.\n * @returns the result of the network operation\n * @throws {@link ConnectionError} If after maxAttempts the callback still throws ConnectionError\n */\nexport function retryNetworkOperation(_x, _x2) {\n  return _retryNetworkOperation.apply(this, arguments);\n}\n\n/**\n * Calculate the backoff time for a request retry attempt.\n * This produces wait times of 2, 4, 8, and 16 seconds (30s total) after which we give up. If the\n * failure was due to a rate limited request, the time specified in the error is returned.\n *\n * Returns -1 if the error is not retryable, or if we reach the maximum number of attempts.\n *\n * @param err - The error thrown by the http call\n * @param attempts - The number of attempts made so far, including the one that just failed.\n * @param retryConnectionError - Whether to retry on {@link ConnectionError} (CORS, connection is down, etc.)\n */\nfunction _retryNetworkOperation() {\n  _retryNetworkOperation = _asyncToGenerator(function* (maxAttempts, callback) {\n    var attempts = 0;\n    var lastConnectionError = null;\n    while (attempts < maxAttempts) {\n      try {\n        if (attempts > 0) {\n          var timeout = 1000 * Math.pow(2, attempts);\n          logger.log(\"network operation failed \".concat(attempts, \" times, retrying in \").concat(timeout, \"ms...\"));\n          yield sleep(timeout);\n        }\n        return yield callback();\n      } catch (err) {\n        if (err instanceof ConnectionError) {\n          attempts += 1;\n          lastConnectionError = err;\n        } else {\n          throw err;\n        }\n      }\n    }\n    throw lastConnectionError;\n  });\n  return _retryNetworkOperation.apply(this, arguments);\n}\nexport function calculateRetryBackoff(err, attempts, retryConnectionError) {\n  if (attempts > 4) {\n    return -1; // give up\n  }\n  if (err instanceof ConnectionError && !retryConnectionError) {\n    return -1;\n  }\n  if (err.httpStatus && Math.floor(err.httpStatus / 100) === 4 && err.httpStatus !== 429) {\n    // client error; no amount of retrying will save you now (except for rate limiting which is handled below)\n    return -1;\n  }\n  if (err.name === \"AbortError\") {\n    // this is a client timeout, that is already very high 60s/80s\n    // we don't want to retry, as it could do it for very long\n    return -1;\n  }\n\n  // If we are trying to send an event (or similar) that is too large in any way, then retrying won't help\n  if (err.name === \"M_TOO_LARGE\") {\n    return -1;\n  }\n  return safeGetRetryAfterMs(err, 1000 * Math.pow(2, attempts));\n}\n//# sourceMappingURL=utils.js.map","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n/*\nCopyright 2025 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MatrixError, TokenRefreshLogoutError } from \"./errors.js\";\nimport { sleep } from \"../utils.js\";\n\n/**\n * This is an internal module. See {@link MatrixHttpApi} for the public class.\n */\n\nexport var TokenRefreshOutcome = /*#__PURE__*/function (TokenRefreshOutcome) {\n  TokenRefreshOutcome[\"Success\"] = \"success\";\n  TokenRefreshOutcome[\"Failure\"] = \"failure\";\n  TokenRefreshOutcome[\"Logout\"] = \"logout\";\n  return TokenRefreshOutcome;\n}({});\n// If the token expires in less than this time amount of time, we will eagerly refresh it before making the intended request.\nvar REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS = 500;\n// If we get an unknown token error and the token expires in less than this time amount of time, we will refresh it before making the intended request.\n// Otherwise, we will error as the token should not have expired yet and we need to avoid retrying indefinitely.\nvar REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS = 60 * 1000;\n/**\n * This class is responsible for managing the access token and refresh token for authenticated requests.\n * It will automatically refresh the access token when it is about to expire, and will handle unknown token errors.\n */\nexport class TokenRefresher {\n  constructor(opts) {\n    this.opts = opts;\n    /**\n     * Promise used to block authenticated requests during a token refresh to avoid repeated expected errors.\n     * @private\n     */\n    _defineProperty(this, \"tokenRefreshPromise\", void 0);\n    _defineProperty(this, \"latestTokenRefreshExpiry\", void 0);\n  }\n  /**\n   * This function is called before every request to ensure that the access token is valid.\n   * @returns a snapshot containing the access token and other properties which must be passed to the handleUnknownToken\n   *     handler if an M_UNKNOWN_TOKEN error is encountered.\n   */\n  prepareForRequest() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // Ensure our token is refreshed before we build the headers/params\n      yield _this.refreshIfNeeded();\n      return {\n        accessToken: _this.opts.accessToken,\n        refreshToken: _this.opts.refreshToken,\n        expiry: _this.latestTokenRefreshExpiry\n      };\n    })();\n  }\n  refreshIfNeeded() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.tokenRefreshPromise) {\n        return _this2.tokenRefreshPromise;\n      }\n      // If we don't know the token expiry, we can't eagerly refresh\n      if (!_this2.latestTokenRefreshExpiry) return;\n      var expiresIn = _this2.latestTokenRefreshExpiry.getTime() - Date.now();\n      if (expiresIn <= REFRESH_IF_TOKEN_EXPIRES_WITHIN_MS) {\n        yield _this2._handleUnknownToken();\n      }\n    })();\n  }\n\n  /**\n   * This function is called when an M_UNKNOWN_TOKEN error is encountered.\n   * It will attempt to refresh the access token if it is unknown, and will return a TokenRefreshOutcome.\n   * @param snapshot - the snapshot returned by prepareForRequest\n   * @param attempt - the number of attempts made for this request so far\n   * @returns a TokenRefreshOutcome indicating the result of the refresh attempt\n   */\n  handleUnknownToken(snapshot, attempt) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3._handleUnknownToken(snapshot, attempt);\n    })();\n  }\n\n  /* eslint-disable @typescript-eslint/naming-convention */\n\n  _handleUnknownToken(snapshot, attempt) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (snapshot !== null && snapshot !== void 0 && snapshot.expiry) {\n        // If our token is unknown, but it should not have expired yet, then we should not refresh\n        var expiresIn = snapshot.expiry.getTime() - Date.now();\n        // If it still has plenty of time left on the clock, we assume something else must be wrong and\n        // do not refresh. Otherwise if it's expired, or will soon, we try refreshing.\n        if (expiresIn >= REFRESH_ON_ERROR_IF_TOKEN_EXPIRES_WITHIN_MS) {\n          return TokenRefreshOutcome.Logout;\n        }\n      }\n      if (!snapshot || (snapshot === null || snapshot === void 0 ? void 0 : snapshot.accessToken) === _this4.opts.accessToken) {\n        var _this4$tokenRefreshPr;\n        // If we have a snapshot, but the access token is the same as the current one then a refresh\n        // did not happen behind us but one may be ongoing anyway\n        (_this4$tokenRefreshPr = _this4.tokenRefreshPromise) !== null && _this4$tokenRefreshPr !== void 0 ? _this4$tokenRefreshPr : _this4.tokenRefreshPromise = _this4.doTokenRefresh(attempt);\n        try {\n          return yield _this4.tokenRefreshPromise;\n        } finally {\n          _this4.tokenRefreshPromise = undefined;\n        }\n      }\n\n      // We may end up here if the token was refreshed in the background due to another request\n      return TokenRefreshOutcome.Success;\n    })();\n  }\n\n  /**\n   * Attempt to refresh access tokens.\n   * On success, sets new access and refresh tokens in opts.\n   * @returns Promise that resolves to a boolean - true when token was refreshed successfully\n   */\n  doTokenRefresh(attempt) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this5.opts.refreshToken || !_this5.opts.tokenRefreshFunction) {\n        var _this5$opts$logger;\n        (_this5$opts$logger = _this5.opts.logger) === null || _this5$opts$logger === void 0 || _this5$opts$logger.error(\"Unable to refresh token - no refresh token or refresh function\");\n        return TokenRefreshOutcome.Logout;\n      }\n      if (attempt && attempt > 1) {\n        // Exponential backoff to ensure we don't trash the server, up to 2^5 seconds\n        yield sleep(1000 * Math.min(32, 2 ** attempt));\n      }\n      try {\n        var _this5$opts$logger2, _this5$opts$logger3;\n        (_this5$opts$logger2 = _this5.opts.logger) === null || _this5$opts$logger2 === void 0 || _this5$opts$logger2.debug(\"Attempting to refresh token\");\n        var {\n          accessToken,\n          refreshToken,\n          expiry\n        } = yield _this5.opts.tokenRefreshFunction(_this5.opts.refreshToken);\n        _this5.opts.accessToken = accessToken;\n        _this5.opts.refreshToken = refreshToken;\n        _this5.latestTokenRefreshExpiry = expiry;\n        (_this5$opts$logger3 = _this5.opts.logger) === null || _this5$opts$logger3 === void 0 || _this5$opts$logger3.debug(\"... token refresh complete, new token expiry:\", expiry);\n\n        // successfully got new tokens\n        return TokenRefreshOutcome.Success;\n      } catch (error) {\n        var _this5$opts$logger5;\n        // If we get a TokenError or MatrixError, we should log out, otherwise assume transient\n        if (error instanceof TokenRefreshLogoutError || error instanceof MatrixError) {\n          var _this5$opts$logger4;\n          (_this5$opts$logger4 = _this5.opts.logger) === null || _this5$opts$logger4 === void 0 || _this5$opts$logger4.error(\"Failed to refresh token\", error);\n          return TokenRefreshOutcome.Logout;\n        }\n        (_this5$opts$logger5 = _this5.opts.logger) === null || _this5$opts$logger5 === void 0 || _this5$opts$logger5.warn(\"Failed to refresh token\", error);\n        return TokenRefreshOutcome.Failure;\n      }\n    })();\n  }\n}\n//# sourceMappingURL=refresh.js.map","var grammar = require('./grammar');\n\n// customized util.format - discards excess arguments and can void middle ones\nvar formatRegExp = /%[sdv%]/g;\nvar format = function (formatStr) {\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  return formatStr.replace(formatRegExp, function (x) {\n    if (i >= len) {\n      return x; // missing argument\n    }\n    var arg = args[i];\n    i += 1;\n    switch (x) {\n    case '%%':\n      return '%';\n    case '%s':\n      return String(arg);\n    case '%d':\n      return Number(arg);\n    case '%v':\n      return '';\n    }\n  });\n  // NB: we discard excess arguments - they are typically undefined from makeLine\n};\n\nvar makeLine = function (type, obj, location) {\n  var str = obj.format instanceof Function ?\n    (obj.format(obj.push ? location : location[obj.name])) :\n    obj.format;\n\n  var args = [type + '=' + str];\n  if (obj.names) {\n    for (var i = 0; i < obj.names.length; i += 1) {\n      var n = obj.names[i];\n      if (obj.name) {\n        args.push(location[obj.name][n]);\n      }\n      else { // for mLine and push attributes\n        args.push(location[obj.names[i]]);\n      }\n    }\n  }\n  else {\n    args.push(location[obj.name]);\n  }\n  return format.apply(null, args);\n};\n\n// RFC specified order\n// TODO: extend this with all the rest\nvar defaultOuterOrder = [\n  'v', 'o', 's', 'i',\n  'u', 'e', 'p', 'c',\n  'b', 't', 'r', 'z', 'a'\n];\nvar defaultInnerOrder = ['i', 'c', 'b', 'a'];\n\n\nmodule.exports = function (session, opts) {\n  opts = opts || {};\n  // ensure certain properties exist\n  if (session.version == null) {\n    session.version = 0; // 'v=0' must be there (only defined version atm)\n  }\n  if (session.name == null) {\n    session.name = ' '; // 's= ' must be there if no meaningful name set\n  }\n  session.media.forEach(function (mLine) {\n    if (mLine.payloads == null) {\n      mLine.payloads = '';\n    }\n  });\n\n  var outerOrder = opts.outerOrder || defaultOuterOrder;\n  var innerOrder = opts.innerOrder || defaultInnerOrder;\n  var sdp = [];\n\n  // loop through outerOrder for matching properties on session\n  outerOrder.forEach(function (type) {\n    grammar[type].forEach(function (obj) {\n      if (obj.name in session && session[obj.name] != null) {\n        sdp.push(makeLine(type, obj, session));\n      }\n      else if (obj.push in session && session[obj.push] != null) {\n        session[obj.push].forEach(function (el) {\n          sdp.push(makeLine(type, obj, el));\n        });\n      }\n    });\n  });\n\n  // then for each media line, follow the innerOrder\n  session.media.forEach(function (mLine) {\n    sdp.push(makeLine('m', grammar.m[0], mLine));\n\n    innerOrder.forEach(function (type) {\n      grammar[type].forEach(function (obj) {\n        if (obj.name in mLine && mLine[obj.name] != null) {\n          sdp.push(makeLine(type, obj, mLine));\n        }\n        else if (obj.push in mLine && mLine[obj.push] != null) {\n          mLine[obj.push].forEach(function (el) {\n            sdp.push(makeLine(type, obj, el));\n          });\n        }\n      });\n    });\n  });\n\n  return sdp.join('\\r\\n') + '\\r\\n';\n};\n","var parser = require('./parser');\nvar writer = require('./writer');\nvar grammar = require('./grammar');\n\nexports.grammar = grammar;\nexports.write = writer;\nexports.parse = parser.parse;\nexports.parseParams = parser.parseParams;\nexports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().\nexports.parsePayloads = parser.parsePayloads;\nexports.parseRemoteCandidates = parser.parseRemoteCandidates;\nexports.parseImageAttributes = parser.parseImageAttributes;\nexports.parseSimulcastStreamList = parser.parseSimulcastStreamList;\n","/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Base64 encoding and decoding utilities\n */\n\nfunction toBase64(uint8Array, options) {\n  if (typeof uint8Array.toBase64 === \"function\") {\n    // Currently this is only supported in Firefox,\n    // but we match the options in the hope in the future we can rely on it for all environments.\n    // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.prototype.tobase64\n    return uint8Array.toBase64(options);\n  }\n  var base64 = btoa(uint8Array.reduce((acc, current) => acc + String.fromCharCode(current), \"\"));\n  if (options.omitPadding) {\n    base64 = base64.replace(/={1,2}$/, \"\");\n  }\n  if (options.alphabet === \"base64url\") {\n    base64 = base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n  }\n  return base64;\n}\n\n/**\n * Encode a typed array of uint8 as base64.\n * @param uint8Array - The data to encode.\n * @returns The base64.\n */\nexport function encodeBase64(uint8Array) {\n  return toBase64(uint8Array, {\n    alphabet: \"base64\",\n    omitPadding: false\n  });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64(uint8Array) {\n  return toBase64(uint8Array, {\n    alphabet: \"base64\",\n    omitPadding: true\n  });\n}\n\n/**\n * Encode a typed array of uint8 as unpadded base64 using the URL-safe encoding.\n * @param uint8Array - The data to encode.\n * @returns The unpadded base64.\n */\nexport function encodeUnpaddedBase64Url(uint8Array) {\n  return toBase64(uint8Array, {\n    alphabet: \"base64url\",\n    omitPadding: true\n  });\n}\nfunction fromBase64(base64, options) {\n  if (typeof Uint8Array.fromBase64 === \"function\") {\n    // Currently this is only supported in Firefox,\n    // but we match the options in the hope in the future we can rely on it for all environments.\n    // https://tc39.es/proposal-arraybuffer-base64/spec/#sec-uint8array.frombase64\n    return Uint8Array.fromBase64(base64, options);\n  }\n  return Uint8Array.from(atob(base64), c => c.charCodeAt(0));\n}\n\n/**\n * Decode a base64 (or base64url) string to a typed array of uint8.\n * @param base64 - The base64 to decode.\n * @returns The decoded data.\n */\nexport function decodeBase64(base64) {\n  // The function requires us to select an alphabet, but we don't know if base64url was used so we convert.\n  return fromBase64(base64.replace(/-/g, \"+\").replace(/_/g, \"/\"), {\n    alphabet: \"base64\",\n    lastChunkHandling: \"loose\"\n  });\n}\n//# sourceMappingURL=base64.js.map","/*\nCopyright 2018 New Vector Ltd\nCopyright 2019 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { encodeUnpaddedBase64Url } from \"./base64.js\";\n\n/**\n * String representing the lowercase latin alphabet for use in {@link secureRandomStringFrom}\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport var LOWERCASE = \"abcdefghijklmnopqrstuvwxyz\";\n\n/**\n * String representing the uppercase latin alphabet for use in secureRandomStringFrom\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport var UPPERCASE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n/**\n * String representing the arabic numerals for use in secureRandomStringFrom\n * (can be combined with other such exports or other characters by appending strings)\n */\nexport var DIGITS = \"0123456789\";\nexport function secureRandomBase64Url(len) {\n  var key = new Uint8Array(len);\n  globalThis.crypto.getRandomValues(key);\n  return encodeUnpaddedBase64Url(key);\n}\n\n/**\n * Generates a random string of uppercase and lowercase letters plus digits using a\n * cryptographically secure random number generator.\n * @param len The length of the string to generate\n * @returns Random string of uppercase and lowercase letters plus digits of length `len`\n */\nexport function secureRandomString(len) {\n  return secureRandomStringFrom(len, UPPERCASE + LOWERCASE + DIGITS);\n}\n\n/**\n * Generate a cryptographically secure random string using characters given.\n *\n * @param len - The length of the string to generate (must be positive and less than 32768).\n * @param chars - The characters to use in the random string (between 2 and 256 characters long).\n * @returns Random string of characters of length `len`.\n */\nexport function secureRandomStringFrom(len, chars) {\n  // This is intended for latin strings so 256 possibilities should be more than enough and\n  // means we can use random bytes, minimising the amount of entropy we need to ask for.\n  if (chars.length < 2 || chars.length > 256) {\n    throw new Error(\"Character set must be between 2 and 256 characters long\");\n  }\n  if (len < 1 || len > 32768) {\n    throw new Error(\"Requested random string length must be between 1 and 32768\");\n  }\n\n  // We'll generate random unsigned bytes, so get the largest number less than 256 that is a multiple\n  // of the length of the character set: We'll need to discard any random values that are larger than\n  // this as we can't possibly map them onto the character set while keeping each character equally\n  // likely to be chosen (minus 1 to convert to indices in a string). (Essentially, we're using a d8\n  // to choose between 7 possibilities and re-rolling on an 8, keeping all 7 outcomes equally likely.)\n  // Our random values must be strictly less than this\n  var randomValueCutoff = 256 - 256 % chars.length;\n\n  // Grab 30% more entropy than we need. This should be enough that we can discard the values that are\n  // too high without having to go back and grab more unless we're super unlucky.\n  var entropyBuffer = new Uint8Array(Math.floor(len * 1.3));\n  // Mark all of this buffer as used to start with (we haven't populated it with entropy yet) so it will\n  // be filled on the first iteration.\n  var entropyBufferPos = entropyBuffer.length;\n  var result = [];\n  while (result.length < len) {\n    if (entropyBufferPos === entropyBuffer.length) {\n      globalThis.crypto.getRandomValues(entropyBuffer);\n      entropyBufferPos = 0;\n    }\n    var randomByte = entropyBuffer[entropyBufferPos++];\n    if (randomByte < randomValueCutoff) {\n      result.push(chars[randomByte % chars.length]);\n    }\n  }\n  return result.join(\"\");\n}\n//# sourceMappingURL=randomstring.js.map","import _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { logger as rootLogger } from \"../logger.js\";\nimport { sleep } from \"../utils.js\";\nimport { MembershipActionType } from \"./NewMembershipManager.js\";\n\n/** @internal */\n\n/** @internal */\n\n/**\n * This scheduler tracks the state of the current membership participation\n * and runs one central timer that wakes up a handler callback with the correct action + state\n * whenever necessary.\n *\n * It can also be awakened whenever a new action is added which is\n * earlier then the current \"next awake\".\n * @internal\n */\nexport class ActionScheduler {\n  constructor(/** This is the callback called for each scheduled action (`this.addAction()`) */\n  membershipLoopHandler, parentLogger) {\n    this.membershipLoopHandler = membershipLoopHandler;\n    _defineProperty(this, \"logger\", void 0);\n    /**\n     * This is tracking the state of the scheduler loop.\n     * Only used to prevent starting the loop twice.\n     */\n    _defineProperty(this, \"running\", false);\n    // function for the wakeup mechanism (in case we add an action externally and need to leave the current sleep)\n    _defineProperty(this, \"wakeup\", update => {\n      this.logger.error(\"Cannot call wakeup before calling `startWithJoin()`\");\n    });\n    _defineProperty(this, \"_actions\", []);\n    this.logger = (parentLogger !== null && parentLogger !== void 0 ? parentLogger : rootLogger).getChild(\"[NewMembershipActionScheduler]\");\n  }\n  get actions() {\n    return this._actions;\n  }\n\n  /**\n   * This starts the main loop of the membership manager that handles event sending, delayed event sending and delayed event restarting.\n   * @param initialActions The initial actions the manager will start with. It should be enough to pass: DelayedLeaveActionType.Initial\n   * @returns Promise that resolves once all actions have run and no more are scheduled.\n   * @throws This throws an error if one of the actions throws.\n   * In most other error cases the manager will try to handle any server errors by itself.\n   */\n  startWithJoin() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.running) {\n        _this.logger.error(\"Cannot call startWithJoin() on NewMembershipActionScheduler while already running\");\n        return;\n      }\n      _this.running = true;\n      _this._actions = [{\n        ts: Date.now(),\n        type: MembershipActionType.SendDelayedEvent\n      }];\n      try {\n        var _loop = function* _loop() {\n          // Sort so next (smallest ts) action is at the beginning\n          _this._actions.sort((a, b) => a.ts - b.ts);\n          var nextAction = _this._actions[0];\n          var wakeupUpdate = undefined;\n\n          // while we await for the next action, wakeup has to resolve the wakeupPromise\n          var wakeupPromise = new Promise(resolve => {\n            _this.wakeup = update => {\n              wakeupUpdate = update;\n              resolve();\n            };\n          });\n          if (nextAction.ts > Date.now()) yield Promise.race([wakeupPromise, sleep(nextAction.ts - Date.now())]);\n          var handlerResult = {};\n          if (!wakeupUpdate) {\n            _this.logger.debug(\"Current MembershipManager processing: \".concat(nextAction.type, \"\\nQueue:\"), _this._actions, \"\\nDate.now: \\\"\".concat(Date.now()));\n            try {\n              // `this.wakeup` can also be called and sets the `wakeupUpdate` object while we are in the handler.\n              handlerResult = yield _this.membershipLoopHandler(nextAction.type);\n            } catch (e) {\n              throw Error(\"The MembershipManager shut down because of the end condition: \".concat(e));\n            }\n          }\n          // remove the processed action only after we are done processing\n          _this._actions.splice(0, 1);\n          // The wakeupUpdate always wins since that is a direct external update.\n          var actionUpdate = wakeupUpdate !== null && wakeupUpdate !== void 0 ? wakeupUpdate : handlerResult;\n          if (\"replace\" in actionUpdate) {\n            _this._actions = actionUpdate.replace;\n          } else if (\"insert\" in actionUpdate) {\n            _this._actions.push(...actionUpdate.insert);\n          }\n        };\n        while (_this._actions.length > 0) {\n          yield* _loop();\n        }\n      } finally {\n        // Set the rtc session running state since we cannot recover from here and the consumer user of the\n        // MatrixRTCSession class needs to manually rejoin.\n        _this.running = false;\n      }\n      _this.logger.debug(\"Leave MembershipManager ActionScheduler loop (no more actions)\");\n    })();\n  }\n  initiateJoin() {\n    var _this$wakeup;\n    (_this$wakeup = this.wakeup) === null || _this$wakeup === void 0 || _this$wakeup.call(this, {\n      replace: [{\n        ts: Date.now(),\n        type: MembershipActionType.SendDelayedEvent\n      }]\n    });\n  }\n  initiateLeave() {\n    var _this$wakeup2;\n    (_this$wakeup2 = this.wakeup) === null || _this$wakeup2 === void 0 || _this$wakeup2.call(this, {\n      replace: [{\n        ts: Date.now(),\n        type: MembershipActionType.SendScheduledDelayedLeaveEvent\n      }]\n    });\n  }\n}\n//# sourceMappingURL=NewMembershipManagerActionScheduler.js.map","import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"server\", \"limit\", \"since\"];\nfunction ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }\nfunction _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }\n/*\nCopyright 2015-2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * This is an internal module. See {@link MatrixClient} for the public class.\n */\n\nimport { SyncApi, SyncState } from \"./sync.js\";\nimport { EventStatus, MatrixEvent, MatrixEventEvent } from \"./models/event.js\";\nimport { StubStore } from \"./store/stub.js\";\nimport { createNewMatrixCall, supportsMatrixCall } from \"./webrtc/call.js\";\nimport { Filter } from \"./filter.js\";\nimport { CallEventHandler } from \"./webrtc/callEventHandler.js\";\nimport { GroupCallEventHandler } from \"./webrtc/groupCallEventHandler.js\";\nimport * as utils from \"./utils.js\";\nimport { deepCompare, defer, noUnsafeEventProps, replaceParam, safeSet, sleep } from \"./utils.js\";\nimport { Direction, EventTimeline } from \"./models/event-timeline.js\";\nimport { PushProcessor } from \"./pushprocessor.js\";\nimport { AutoDiscovery } from \"./autodiscovery.js\";\nimport { encodeUnpaddedBase64Url } from \"./base64.js\";\nimport { TypedReEmitter } from \"./ReEmitter.js\";\nimport { logger } from \"./logger.js\";\nimport { SERVICE_TYPES } from \"./service-types.js\";\nimport { ClientPrefix, IdentityPrefix, MatrixError, MatrixHttpApi, MediaPrefix, Method, retryNetworkOperation } from \"./http-api/index.js\";\nimport { User, UserEvent } from \"./models/user.js\";\nimport { getHttpUriForMxc } from \"./content-repo.js\";\nimport { SearchResult } from \"./models/search-result.js\";\nimport * as ContentHelpers from \"./content-helpers.js\";\nimport { NotificationCountType } from \"./models/room.js\";\nimport { RoomMemberEvent } from \"./models/room-member.js\";\nimport { EventType, LOCAL_NOTIFICATION_SETTINGS_PREFIX, MSC3912_RELATION_BASED_REDACTIONS_PROP, MsgType, PUSHER_ENABLED, RelationType, RoomCreateTypeField, RoomType, UNSTABLE_MSC3088_ENABLED, UNSTABLE_MSC3088_PURPOSE, UNSTABLE_MSC3089_TREE_SUBTYPE } from \"./@types/event.js\";\nimport { GuestAccess, HistoryVisibility, Preset } from \"./@types/partials.js\";\nimport { eventMapperFor } from \"./event-mapper.js\";\nimport { secureRandomString } from \"./randomstring.js\";\nimport { DEFAULT_TREE_POWER_LEVELS_TEMPLATE, MSC3089TreeSpace } from \"./models/MSC3089TreeSpace.js\";\nimport { SearchOrderBy } from \"./@types/search.js\";\nimport { PushRuleActionName, PushRuleKind } from \"./@types/PushRules.js\";\nimport { GroupCall } from \"./webrtc/groupCall.js\";\nimport { MediaHandler } from \"./webrtc/mediaHandler.js\";\nimport { TypedEventEmitter } from \"./models/typed-event-emitter.js\";\nimport { MAIN_ROOM_TIMELINE, ReceiptType } from \"./@types/read_receipts.js\";\nimport { SlidingSyncSdk } from \"./sliding-sync-sdk.js\";\nimport { determineFeatureSupport, FeatureSupport, Thread, THREAD_RELATION_TYPE, ThreadFilterType, threadFilterTypeToFilter } from \"./models/thread.js\";\nimport { M_BEACON_INFO } from \"./@types/beacon.js\";\nimport { NamespacedValue, UnstableValue } from \"./NamespacedValue.js\";\nimport { ToDeviceMessageQueue } from \"./ToDeviceMessageQueue.js\";\nimport { IgnoredInvites } from \"./models/invites-ignorer.js\";\nimport { buildFeatureSupportMap, Feature, ServerSupport } from \"./feature.js\";\nimport { RUST_SDK_STORE_PREFIX } from \"./rust-crypto/constants.js\";\nimport { CryptoEvent } from \"./crypto-api/index.js\";\nimport { ServerSideSecretStorageImpl } from \"./secret-storage.js\";\nimport { MatrixRTCSessionManager } from \"./matrixrtc/MatrixRTCSessionManager.js\";\nimport { getRelationsThreadFilter } from \"./thread-utils.js\";\nimport { KnownMembership } from \"./@types/membership.js\";\nimport { ServerCapabilities } from \"./serverCapabilities.js\";\nimport { sha256 } from \"./digest.js\";\nimport { discoverAndValidateOIDCIssuerWellKnown, validateAuthMetadataAndKeys } from \"./oidc/index.js\";\nimport { UnsupportedDelayedEventsEndpointError } from \"./errors.js\";\nvar SCROLLBACK_DELAY_MS = 3000;\nvar TURN_CHECK_INTERVAL = 10 * 60 * 1000; // poll for turn credentials every 10 minutes\n\nexport var UNSTABLE_MSC3852_LAST_SEEN_UA = new UnstableValue(\"last_seen_user_agent\", \"org.matrix.msc3852.last_seen_user_agent\");\nexport var PendingEventOrdering = /*#__PURE__*/function (PendingEventOrdering) {\n  PendingEventOrdering[\"Chronological\"] = \"chronological\";\n  PendingEventOrdering[\"Detached\"] = \"detached\";\n  return PendingEventOrdering;\n}({});\nexport var GET_LOGIN_TOKEN_CAPABILITY = new NamespacedValue(\"m.get_login_token\", \"org.matrix.msc3882.get_login_token\");\nexport var UNSTABLE_MSC2666_SHARED_ROOMS = \"uk.half-shot.msc2666\";\nexport var UNSTABLE_MSC2666_MUTUAL_ROOMS = \"uk.half-shot.msc2666.mutual_rooms\";\nexport var UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS = \"uk.half-shot.msc2666.query_mutual_rooms\";\nexport var UNSTABLE_MSC4140_DELAYED_EVENTS = \"org.matrix.msc4140\";\nexport var UNSTABLE_MSC4133_EXTENDED_PROFILES = \"uk.tcpip.msc4133\";\nvar CrossSigningKeyType = /*#__PURE__*/function (CrossSigningKeyType) {\n  CrossSigningKeyType[\"MasterKey\"] = \"master_key\";\n  CrossSigningKeyType[\"SelfSigningKey\"] = \"self_signing_key\";\n  CrossSigningKeyType[\"UserSigningKey\"] = \"user_signing_key\";\n  return CrossSigningKeyType;\n}(CrossSigningKeyType || {}); // Re-export for backwards compatibility\n/**\n * The summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n */\n/* eslint-enable camelcase */\n\n// We're using this constant for methods overloading and inspect whether a variable\n// contains an eventId or not. This was required to ensure backwards compatibility\n// of methods for threads\n// Probably not the most graceful solution but does a good enough job for now\nvar EVENT_ID_PREFIX = \"$\";\nexport var ClientEvent = /*#__PURE__*/function (ClientEvent) {\n  ClientEvent[\"Sync\"] = \"sync\";\n  ClientEvent[\"Event\"] = \"event\";\n  ClientEvent[\"ToDeviceEvent\"] = \"toDeviceEvent\";\n  ClientEvent[\"AccountData\"] = \"accountData\";\n  ClientEvent[\"Room\"] = \"Room\";\n  ClientEvent[\"DeleteRoom\"] = \"deleteRoom\";\n  ClientEvent[\"SyncUnexpectedError\"] = \"sync.unexpectedError\";\n  ClientEvent[\"ClientWellKnown\"] = \"WellKnown.client\";\n  ClientEvent[\"ReceivedVoipEvent\"] = \"received_voip_event\";\n  ClientEvent[\"UndecryptableToDeviceEvent\"] = \"toDeviceEvent.undecryptable\";\n  ClientEvent[\"TurnServers\"] = \"turnServers\";\n  ClientEvent[\"TurnServersError\"] = \"turnServers.error\";\n  return ClientEvent;\n}({});\nvar SSO_ACTION_PARAM = new UnstableValue(\"action\", \"org.matrix.msc3824.action\");\n\n/**\n * Represents a Matrix Client. Only directly construct this if you want to use\n * custom modules. Normally, {@link createClient} should be used\n * as it specifies 'sensible' defaults for these modules.\n */\nexport class MatrixClient extends TypedEventEmitter {\n  constructor(opts) {\n    var _opts$logger, _opts$usingExternalCr, _this, _opts$cryptoCallbacks;\n    // If a custom logger is provided, use it. Otherwise, default to the global\n    // one in logger.ts.\n    super();\n    _this = this;\n    _defineProperty(this, \"logger\", void 0);\n    _defineProperty(this, \"reEmitter\", new TypedReEmitter(this));\n    _defineProperty(this, \"olmVersion\", null);\n    // populated after initLegacyCrypto\n    _defineProperty(this, \"usingExternalCrypto\", false);\n    _defineProperty(this, \"_store\", void 0);\n    _defineProperty(this, \"deviceId\", void 0);\n    _defineProperty(this, \"credentials\", void 0);\n    /**\n     * Encryption key used for encrypting sensitive data (such as e2ee keys) in storage.\n     *\n     * As supplied in the constructor via {@link IMatrixClientCreateOpts#pickleKey}.\n     * Used for migration from the legacy crypto to the rust crypto\n     */\n    _defineProperty(this, \"legacyPickleKey\", void 0);\n    _defineProperty(this, \"scheduler\", void 0);\n    _defineProperty(this, \"clientRunning\", false);\n    _defineProperty(this, \"timelineSupport\", false);\n    _defineProperty(this, \"urlPreviewCache\", {});\n    _defineProperty(this, \"identityServer\", void 0);\n    _defineProperty(this, \"http\", void 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"cryptoBackend\", void 0);\n    // one of crypto or rustCrypto\n    _defineProperty(this, \"cryptoCallbacks\", void 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"callEventHandler\", void 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"groupCallEventHandler\", void 0);\n    _defineProperty(this, \"supportsCallTransfer\", false);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"forceTURN\", false);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"iceCandidatePoolSize\", 0);\n    // XXX: Intended private, used in code.\n    _defineProperty(this, \"idBaseUrl\", void 0);\n    _defineProperty(this, \"baseUrl\", void 0);\n    _defineProperty(this, \"isVoipWithNoMediaAllowed\", void 0);\n    _defineProperty(this, \"useLivekitForGroupCalls\", void 0);\n    // Note: these are all `protected` to let downstream consumers make mistakes if they want to.\n    // We don't technically support this usage, but have reasons to do this.\n    _defineProperty(this, \"canSupportVoip\", false);\n    _defineProperty(this, \"peekSync\", null);\n    _defineProperty(this, \"isGuestAccount\", false);\n    _defineProperty(this, \"ongoingScrollbacks\", {});\n    _defineProperty(this, \"notifTimelineSet\", null);\n    /**\n     * Legacy crypto store used for migration from the legacy crypto to the rust crypto\n     * @private\n     */\n    _defineProperty(this, \"legacyCryptoStore\", void 0);\n    _defineProperty(this, \"verificationMethods\", void 0);\n    _defineProperty(this, \"fallbackICEServerAllowed\", false);\n    _defineProperty(this, \"syncApi\", void 0);\n    _defineProperty(this, \"roomNameGenerator\", void 0);\n    _defineProperty(this, \"pushRules\", void 0);\n    _defineProperty(this, \"syncLeftRoomsPromise\", void 0);\n    _defineProperty(this, \"syncedLeftRooms\", false);\n    _defineProperty(this, \"clientOpts\", void 0);\n    _defineProperty(this, \"clientWellKnownIntervalID\", void 0);\n    _defineProperty(this, \"canResetTimelineCallback\", void 0);\n    _defineProperty(this, \"canSupport\", new Map());\n    // The pushprocessor caches useful things, so keep one and re-use it\n    _defineProperty(this, \"pushProcessor\", new PushProcessor(this));\n    // Promise to a response of the server's /versions response\n    // TODO: This should expire: https://github.com/matrix-org/matrix-js-sdk/issues/1020\n    _defineProperty(this, \"serverVersionsPromise\", void 0);\n    _defineProperty(this, \"clientWellKnown\", void 0);\n    _defineProperty(this, \"clientWellKnownPromise\", void 0);\n    _defineProperty(this, \"turnServers\", []);\n    _defineProperty(this, \"turnServersExpiry\", 0);\n    _defineProperty(this, \"checkTurnServersIntervalID\", void 0);\n    _defineProperty(this, \"txnCtr\", 0);\n    _defineProperty(this, \"mediaHandler\", new MediaHandler(this));\n    _defineProperty(this, \"sessionId\", void 0);\n    /** IDs of events which are currently being encrypted.\n     *\n     * This is part of the cancellation mechanism: if the event is no longer listed here when encryption completes,\n     * that tells us that it has been cancelled, and we should not send it.\n     */\n    _defineProperty(this, \"eventsBeingEncrypted\", new Set());\n    _defineProperty(this, \"useE2eForGroupCall\", true);\n    _defineProperty(this, \"toDeviceMessageQueue\", void 0);\n    _defineProperty(this, \"livekitServiceURL\", void 0);\n    _defineProperty(this, \"_secretStorage\", void 0);\n    // A manager for determining which invites should be ignored.\n    _defineProperty(this, \"ignoredInvites\", void 0);\n    _defineProperty(this, \"matrixRTC\", void 0);\n    _defineProperty(this, \"serverCapabilitiesService\", void 0);\n    _defineProperty(this, \"startCallEventHandler\", () => {\n      if (this.isInitialSyncComplete()) {\n        if (supportsMatrixCall()) {\n          this.callEventHandler.start();\n          this.groupCallEventHandler.start();\n        }\n        this.off(ClientEvent.Sync, this.startCallEventHandler);\n      }\n    });\n    _defineProperty(this, \"startMatrixRTC\", () => {\n      if (this.isInitialSyncComplete()) {\n        this.matrixRTC.start();\n        this.off(ClientEvent.Sync, this.startMatrixRTC);\n      }\n    });\n    /**\n     * Once the client has been initialised, we want to clear notifications we\n     * know for a fact should be here.\n     * This issue should also be addressed on synapse's side and is tracked as part\n     * of https://github.com/matrix-org/synapse/issues/14837\n     *\n     * We consider a room or a thread as fully read if the current user has sent\n     * the last event in the live timeline of that context and if the read receipt\n     * we have on record matches.\n     */\n    _defineProperty(this, \"fixupRoomNotifications\", () => {\n      if (this.isInitialSyncComplete()) {\n        var _this$getRooms;\n        var unreadRooms = ((_this$getRooms = this.getRooms()) !== null && _this$getRooms !== void 0 ? _this$getRooms : []).filter(room => {\n          return room.getUnreadNotificationCount(NotificationCountType.Total) > 0;\n        });\n        for (var _room of unreadRooms) {\n          var currentUserId = this.getSafeUserId();\n          _room.fixupNotifications(currentUserId);\n        }\n        this.off(ClientEvent.Sync, this.fixupRoomNotifications);\n      }\n    });\n    this.logger = (_opts$logger = opts.logger) !== null && _opts$logger !== void 0 ? _opts$logger : logger;\n    opts.baseUrl = utils.ensureNoTrailingSlash(opts.baseUrl);\n    opts.idBaseUrl = utils.ensureNoTrailingSlash(opts.idBaseUrl);\n    this.baseUrl = opts.baseUrl;\n    this.idBaseUrl = opts.idBaseUrl;\n    this.identityServer = opts.identityServer;\n    this.usingExternalCrypto = (_opts$usingExternalCr = opts.usingExternalCrypto) !== null && _opts$usingExternalCr !== void 0 ? _opts$usingExternalCr : false;\n    this.store = opts.store || new StubStore();\n    this.deviceId = opts.deviceId || null;\n    this.sessionId = secureRandomString(10);\n    var userId = opts.userId || null;\n    this.credentials = {\n      userId\n    };\n    this.http = new MatrixHttpApi(this, {\n      fetchFn: opts.fetchFn,\n      baseUrl: opts.baseUrl,\n      idBaseUrl: opts.idBaseUrl,\n      accessToken: opts.accessToken,\n      refreshToken: opts.refreshToken,\n      tokenRefreshFunction: opts.tokenRefreshFunction,\n      prefix: ClientPrefix.V3,\n      onlyData: true,\n      extraParams: opts.queryParams,\n      localTimeoutMs: opts.localTimeoutMs,\n      useAuthorizationHeader: opts.useAuthorizationHeader,\n      logger: this.logger\n    });\n    if (opts.pickleKey) {\n      this.legacyPickleKey = opts.pickleKey;\n    }\n    this.useLivekitForGroupCalls = Boolean(opts.useLivekitForGroupCalls);\n    this.scheduler = opts.scheduler;\n    if (this.scheduler) {\n      this.scheduler.setProcessFunction(/*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (eventToSend) {\n          var room = _this.getRoom(eventToSend.getRoomId());\n          if (eventToSend.status !== EventStatus.SENDING) {\n            _this.updatePendingEventStatus(room, eventToSend, EventStatus.SENDING);\n          }\n          var res = yield _this.sendEventHttpRequest(eventToSend);\n          if (room) {\n            // ensure we update pending event before the next scheduler run so that any listeners to event id\n            // updates on the synchronous event emitter get a chance to run first.\n            room.updatePendingEvent(eventToSend, EventStatus.SENT, res.event_id);\n          }\n          return res;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    }\n    if (supportsMatrixCall()) {\n      this.callEventHandler = new CallEventHandler(this);\n      this.groupCallEventHandler = new GroupCallEventHandler(this);\n      this.canSupportVoip = true;\n      // Start listening for calls after the initial sync is done\n      // We do not need to backfill the call event buffer\n      // with encrypted events that might never get decrypted\n      this.on(ClientEvent.Sync, this.startCallEventHandler);\n    }\n\n    // NB. We initialise MatrixRTC whether we have call support or not: this is just\n    // the underlying session management and doesn't use any actual media capabilities\n    this.matrixRTC = new MatrixRTCSessionManager(this);\n    this.serverCapabilitiesService = new ServerCapabilities(this.http);\n    this.on(ClientEvent.Sync, this.fixupRoomNotifications);\n    this.timelineSupport = Boolean(opts.timelineSupport);\n    this.legacyCryptoStore = opts.cryptoStore;\n    this.verificationMethods = opts.verificationMethods;\n    this.cryptoCallbacks = opts.cryptoCallbacks || {};\n    this.forceTURN = opts.forceTURN || false;\n    this.iceCandidatePoolSize = opts.iceCandidatePoolSize === undefined ? 0 : opts.iceCandidatePoolSize;\n    this.supportsCallTransfer = opts.supportsCallTransfer || false;\n    this.fallbackICEServerAllowed = opts.fallbackICEServerAllowed || false;\n    this.isVoipWithNoMediaAllowed = opts.isVoipWithNoMediaAllowed || false;\n    if (opts.useE2eForGroupCall !== undefined) this.useE2eForGroupCall = opts.useE2eForGroupCall;\n    this.livekitServiceURL = opts.livekitServiceURL;\n    this.roomNameGenerator = opts.roomNameGenerator;\n    this.toDeviceMessageQueue = new ToDeviceMessageQueue(this);\n\n    // The SDK doesn't really provide a clean way for events to recalculate the push\n    // actions for themselves, so we have to kinda help them out when they are encrypted.\n    // We do this so that push rules are correctly executed on events in their decrypted\n    // state, such as highlights when the user's name is mentioned.\n    this.on(MatrixEventEvent.Decrypted, event => {\n      fixNotificationCountOnDecryption(this, event);\n    });\n    this.ignoredInvites = new IgnoredInvites(this);\n    this._secretStorage = new ServerSideSecretStorageImpl(this, (_opts$cryptoCallbacks = opts.cryptoCallbacks) !== null && _opts$cryptoCallbacks !== void 0 ? _opts$cryptoCallbacks : {});\n\n    // having lots of event listeners is not unusual. 0 means \"unlimited\".\n    this.setMaxListeners(0);\n  }\n  set store(newStore) {\n    this._store = newStore;\n    this._store.setUserCreator(userId => User.createUser(userId, this));\n  }\n  get store() {\n    return this._store;\n  }\n\n  /**\n   * High level helper method to begin syncing and poll for new events. To listen for these\n   * events, add a listener for {@link ClientEvent.Event}\n   * via {@link MatrixClient#on}. Alternatively, listen for specific\n   * state change events.\n   * @param opts - Options to apply when syncing.\n   */\n  startClient(opts) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.clientRunning) {\n        // client is already running.\n        return;\n      }\n      _this2.clientRunning = true;\n      _this2.on(ClientEvent.Sync, _this2.startMatrixRTC);\n\n      // Create our own user object artificially (instead of waiting for sync)\n      // so it's always available, even if the user is not in any rooms etc.\n      var userId = _this2.getUserId();\n      if (userId) {\n        _this2.store.storeUser(new User(userId));\n      }\n\n      // periodically poll for turn servers if we support voip\n      if (_this2.canSupportVoip) {\n        _this2.checkTurnServersIntervalID = setInterval(() => {\n          _this2.checkTurnServers();\n        }, TURN_CHECK_INTERVAL);\n        // noinspection ES6MissingAwait\n        _this2.checkTurnServers();\n      }\n      if (_this2.syncApi) {\n        // This shouldn't happen since we thought the client was not running\n        _this2.logger.error(\"Still have sync object whilst not running: stopping old one\");\n        _this2.syncApi.stop();\n      }\n      try {\n        yield _this2.getVersions();\n\n        // This should be done with `canSupport`\n        // TODO: https://github.com/vector-im/element-web/issues/23643\n        var {\n          threads,\n          list,\n          fwdPagination\n        } = yield _this2.doesServerSupportThread();\n        Thread.setServerSideSupport(threads);\n        Thread.setServerSideListSupport(list);\n        Thread.setServerSideFwdPaginationSupport(fwdPagination);\n      } catch (e) {\n        _this2.logger.error(\"Can't fetch server versions, continuing to initialise sync, this will be retried later\", e);\n      }\n      _this2.clientOpts = opts !== null && opts !== void 0 ? opts : {};\n      if (_this2.clientOpts.slidingSync) {\n        _this2.syncApi = new SlidingSyncSdk(_this2.clientOpts.slidingSync, _this2, _this2.clientOpts, _this2.buildSyncApiOptions());\n      } else {\n        _this2.syncApi = new SyncApi(_this2, _this2.clientOpts, _this2.buildSyncApiOptions());\n      }\n      _this2.syncApi.sync().catch(e => _this2.logger.info(\"Sync startup aborted with an error:\", e));\n      if (_this2.clientOpts.clientWellKnownPollPeriod !== undefined) {\n        _this2.clientWellKnownIntervalID = setInterval(() => {\n          _this2.fetchClientWellKnown();\n        }, 1000 * _this2.clientOpts.clientWellKnownPollPeriod);\n        _this2.fetchClientWellKnown();\n      }\n      _this2.toDeviceMessageQueue.start();\n      _this2.serverCapabilitiesService.start();\n    })();\n  }\n\n  /**\n   * Construct a SyncApiOptions for this client, suitable for passing into the SyncApi constructor\n   */\n  buildSyncApiOptions() {\n    return {\n      cryptoCallbacks: this.cryptoBackend,\n      canResetEntireTimeline: roomId => {\n        if (!this.canResetTimelineCallback) {\n          return false;\n        }\n        return this.canResetTimelineCallback(roomId);\n      }\n    };\n  }\n\n  /**\n   * High level helper method to stop the client from polling and allow a\n   * clean shutdown.\n   */\n  stopClient() {\n    var _this$cryptoBackend, _this$syncApi, _this$peekSync, _this$callEventHandle, _this$groupCallEventH;\n    (_this$cryptoBackend = this.cryptoBackend) === null || _this$cryptoBackend === void 0 || _this$cryptoBackend.stop(); // crypto might have been initialised even if the client wasn't fully started\n\n    this.off(ClientEvent.Sync, this.startMatrixRTC);\n    if (!this.clientRunning) return; // already stopped\n\n    this.logger.debug(\"stopping MatrixClient\");\n    this.clientRunning = false;\n    (_this$syncApi = this.syncApi) === null || _this$syncApi === void 0 || _this$syncApi.stop();\n    this.syncApi = undefined;\n    (_this$peekSync = this.peekSync) === null || _this$peekSync === void 0 || _this$peekSync.stopPeeking();\n    (_this$callEventHandle = this.callEventHandler) === null || _this$callEventHandle === void 0 || _this$callEventHandle.stop();\n    (_this$groupCallEventH = this.groupCallEventHandler) === null || _this$groupCallEventH === void 0 || _this$groupCallEventH.stop();\n    this.callEventHandler = undefined;\n    this.groupCallEventHandler = undefined;\n    globalThis.clearInterval(this.checkTurnServersIntervalID);\n    this.checkTurnServersIntervalID = undefined;\n    if (this.clientWellKnownIntervalID !== undefined) {\n      globalThis.clearInterval(this.clientWellKnownIntervalID);\n    }\n    this.toDeviceMessageQueue.stop();\n    this.matrixRTC.stop();\n    this.serverCapabilitiesService.stop();\n  }\n\n  /**\n   * Clear any data out of the persistent stores used by the client.\n   *\n   * @returns Promise which resolves when the stores have been cleared.\n   */\n  clearStores() {\n    var _this3 = this;\n    if (this.clientRunning) {\n      throw new Error(\"Cannot clear stores while client is running\");\n    }\n    var promises = [];\n    promises.push(this.store.deleteAllData());\n    if (this.legacyCryptoStore) {\n      promises.push(this.legacyCryptoStore.deleteAllData());\n    }\n\n    // delete the stores used by the rust matrix-sdk-crypto, in case they were used\n    var deleteRustSdkStore = /*#__PURE__*/function () {\n      var _ref2 = _asyncToGenerator(function* () {\n        var indexedDB;\n        try {\n          indexedDB = globalThis.indexedDB;\n          if (!indexedDB) return; // No indexedDB support\n        } catch (_unused) {\n          // No indexedDB support\n          return;\n        }\n        var _loop = function* _loop(dbname) {\n          var prom = new Promise((resolve, reject) => {\n            _this3.logger.info(\"Removing IndexedDB instance \".concat(dbname));\n            var req = indexedDB.deleteDatabase(dbname);\n            req.onsuccess = _ => {\n              _this3.logger.info(\"Removed IndexedDB instance \".concat(dbname));\n              resolve(0);\n            };\n            req.onerror = e => {\n              // In private browsing, Firefox has a globalThis.indexedDB, but attempts to delete an indexeddb\n              // (even a non-existent one) fail with \"DOMException: A mutation operation was attempted on a\n              // database that did not allow mutations.\"\n              //\n              // it seems like the only thing we can really do is ignore the error.\n              _this3.logger.warn(\"Failed to remove IndexedDB instance \".concat(dbname, \":\"), e);\n              resolve(0);\n            };\n            req.onblocked = e => {\n              _this3.logger.info(\"cannot yet remove IndexedDB instance \".concat(dbname));\n            };\n          });\n          yield prom;\n        };\n        for (var dbname of [\"\".concat(RUST_SDK_STORE_PREFIX, \"::matrix-sdk-crypto\"), \"\".concat(RUST_SDK_STORE_PREFIX, \"::matrix-sdk-crypto-meta\")]) {\n          yield* _loop(dbname);\n        }\n      });\n      return function deleteRustSdkStore() {\n        return _ref2.apply(this, arguments);\n      };\n    }();\n    promises.push(deleteRustSdkStore());\n    return Promise.all(promises).then(); // .then to fix types\n  }\n\n  /**\n   * Get the user-id of the logged-in user\n   *\n   * @returns MXID for the logged-in user, or null if not logged in\n   */\n  getUserId() {\n    var _this$credentials$use, _this$credentials;\n    return (_this$credentials$use = (_this$credentials = this.credentials) === null || _this$credentials === void 0 ? void 0 : _this$credentials.userId) !== null && _this$credentials$use !== void 0 ? _this$credentials$use : null;\n  }\n\n  /**\n   * Get the user-id of the logged-in user\n   *\n   * @returns MXID for the logged-in user\n   * @throws Error if not logged in\n   */\n  getSafeUserId() {\n    var userId = this.getUserId();\n    if (!userId) {\n      throw new Error(\"Expected logged in user but found none.\");\n    }\n    return userId;\n  }\n\n  /**\n   * Get the domain for this client's MXID\n   * @returns Domain of this MXID\n   */\n  getDomain() {\n    var _this$credentials2;\n    if ((_this$credentials2 = this.credentials) !== null && _this$credentials2 !== void 0 && _this$credentials2.userId) {\n      return this.credentials.userId.replace(/^.*?:/, \"\");\n    }\n    return null;\n  }\n\n  /**\n   * Get the local part of the current user ID e.g. \"foo\" in \"\\@foo:bar\".\n   * @returns The user ID localpart or null.\n   */\n  getUserIdLocalpart() {\n    var _this$credentials$use2, _this$credentials3;\n    return (_this$credentials$use2 = (_this$credentials3 = this.credentials) === null || _this$credentials3 === void 0 || (_this$credentials3 = _this$credentials3.userId) === null || _this$credentials3 === void 0 ? void 0 : _this$credentials3.split(\":\")[0].substring(1)) !== null && _this$credentials$use2 !== void 0 ? _this$credentials$use2 : null;\n  }\n\n  /**\n   * Get the device ID of this client\n   * @returns device ID\n   */\n  getDeviceId() {\n    return this.deviceId;\n  }\n\n  /**\n   * Get the session ID of this client\n   * @returns session ID\n   */\n  getSessionId() {\n    return this.sessionId;\n  }\n\n  /**\n   * Check if the runtime environment supports VoIP calling.\n   * @returns True if VoIP is supported.\n   */\n  supportsVoip() {\n    return this.canSupportVoip;\n  }\n\n  /**\n   * @returns\n   */\n  getMediaHandler() {\n    return this.mediaHandler;\n  }\n\n  /**\n   * Set whether VoIP calls are forced to use only TURN\n   * candidates. This is the same as the forceTURN option\n   * when creating the client.\n   * @param force - True to force use of TURN servers\n   */\n  setForceTURN(force) {\n    this.forceTURN = force;\n  }\n\n  /**\n   * Set whether to advertise transfer support to other parties on Matrix calls.\n   * @param support - True to advertise the 'm.call.transferee' capability\n   */\n  setSupportsCallTransfer(support) {\n    this.supportsCallTransfer = support;\n  }\n\n  /**\n   * Returns true if to-device signalling for group calls will be encrypted with Olm.\n   * If false, it will be sent unencrypted.\n   * @returns boolean Whether group call signalling will be encrypted\n   */\n  getUseE2eForGroupCall() {\n    return this.useE2eForGroupCall;\n  }\n\n  /**\n   * Creates a new call.\n   * The place*Call methods on the returned call can be used to actually place a call\n   *\n   * @param roomId - The room the call is to be placed in.\n   * @returns the call or null if the browser doesn't support calling.\n   */\n  createCall(roomId) {\n    return createNewMatrixCall(this, roomId);\n  }\n\n  /**\n   * Creates a new group call and sends the associated state event\n   * to alert other members that the room now has a group call.\n   *\n   * @param roomId - The room the call is to be placed in.\n   */\n  createGroupCall(roomId, type, isPtt, intent, dataChannelsEnabled, dataChannelOptions) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (_this4.getGroupCallForRoom(roomId)) {\n        throw new Error(\"\".concat(roomId, \" already has an existing group call\"));\n      }\n      var room = _this4.getRoom(roomId);\n      if (!room) {\n        throw new Error(\"Cannot find room \".concat(roomId));\n      }\n\n      // Because without Media section a WebRTC connection is not possible, so need a RTCDataChannel to set up a\n      // no media WebRTC connection anyway.\n      return new GroupCall(_this4, room, type, isPtt, intent, undefined, dataChannelsEnabled || _this4.isVoipWithNoMediaAllowed, dataChannelOptions, _this4.isVoipWithNoMediaAllowed, _this4.useLivekitForGroupCalls, _this4.livekitServiceURL).create();\n    })();\n  }\n  getLivekitServiceURL() {\n    return this.livekitServiceURL;\n  }\n\n  // This shouldn't need to exist, but the widget API has startup ordering problems that\n  // mean it doesn't know the livekit URL fast enough: remove this once this is fixed.\n  setLivekitServiceURL(newURL) {\n    this.livekitServiceURL = newURL;\n  }\n\n  /**\n   * Wait until an initial state for the given room has been processed by the\n   * client and the client is aware of any ongoing group calls. Awaiting on\n   * the promise returned by this method before calling getGroupCallForRoom()\n   * avoids races where getGroupCallForRoom is called before the state for that\n   * room has been processed. It does not, however, fix other races, eg. two\n   * clients both creating a group call at the same time.\n   * @param roomId - The room ID to wait for\n   * @returns A promise that resolves once existing group calls in the room\n   *          have been processed.\n   */\n  waitUntilRoomReadyForGroupCalls(roomId) {\n    return this.groupCallEventHandler.waitUntilRoomReadyForGroupCalls(roomId);\n  }\n\n  /**\n   * Get an existing group call for the provided room.\n   * @returns The group call or null if it doesn't already exist.\n   */\n  getGroupCallForRoom(roomId) {\n    return this.groupCallEventHandler.groupCalls.get(roomId) || null;\n  }\n\n  /**\n   * Get the current sync state.\n   * @returns the sync state, which may be null.\n   * @see MatrixClient#event:\"sync\"\n   */\n  getSyncState() {\n    var _this$syncApi$getSync, _this$syncApi2;\n    return (_this$syncApi$getSync = (_this$syncApi2 = this.syncApi) === null || _this$syncApi2 === void 0 ? void 0 : _this$syncApi2.getSyncState()) !== null && _this$syncApi$getSync !== void 0 ? _this$syncApi$getSync : null;\n  }\n\n  /**\n   * Returns the additional data object associated with\n   * the current sync state, or null if there is no\n   * such data.\n   * Sync errors, if available, are put in the 'error' key of\n   * this object.\n   */\n  getSyncStateData() {\n    if (!this.syncApi) {\n      return null;\n    }\n    return this.syncApi.getSyncStateData();\n  }\n\n  /**\n   * Whether the initial sync has completed.\n   * @returns True if at least one sync has happened.\n   */\n  isInitialSyncComplete() {\n    var state = this.getSyncState();\n    if (!state) {\n      return false;\n    }\n    return state === SyncState.Prepared || state === SyncState.Syncing;\n  }\n\n  /**\n   * Return whether the client is configured for a guest account.\n   * @returns True if this is a guest access_token (or no token is supplied).\n   */\n  isGuest() {\n    return this.isGuestAccount;\n  }\n\n  /**\n   * Set whether this client is a guest account. <b>This method is experimental\n   * and may change without warning.</b>\n   * @param guest - True if this is a guest account.\n   * @experimental if the token is a macaroon, it should be encoded in it that it is a 'guest'\n   * access token, which means that the SDK can determine this entirely without\n   * the dev manually flipping this flag.\n   */\n  setGuest(guest) {\n    this.isGuestAccount = guest;\n  }\n\n  /**\n   * Return the provided scheduler, if any.\n   * @returns The scheduler or undefined\n   */\n  getScheduler() {\n    return this.scheduler;\n  }\n\n  /**\n   * Retry a backed off syncing request immediately. This should only be used when\n   * the user <b>explicitly</b> attempts to retry their lost connection.\n   * Will also retry any outbound to-device messages currently in the queue to be sent\n   * (retries of regular outgoing events are handled separately, per-event).\n   * @returns True if this resulted in a request being retried.\n   */\n  retryImmediately() {\n    var _this$syncApi$retryIm, _this$syncApi3;\n    // don't await for this promise: we just want to kick it off\n    this.toDeviceMessageQueue.sendQueue();\n    return (_this$syncApi$retryIm = (_this$syncApi3 = this.syncApi) === null || _this$syncApi3 === void 0 ? void 0 : _this$syncApi3.retryImmediately()) !== null && _this$syncApi$retryIm !== void 0 ? _this$syncApi$retryIm : false;\n  }\n\n  /**\n   * Return the global notification EventTimelineSet, if any\n   *\n   * @returns the globl notification EventTimelineSet\n   */\n  getNotifTimelineSet() {\n    return this.notifTimelineSet;\n  }\n\n  /**\n   * Set the global notification EventTimelineSet\n   *\n   */\n  setNotifTimelineSet(set) {\n    this.notifTimelineSet = set;\n  }\n\n  /**\n   * Gets the cached capabilities of the homeserver, returning cached ones if available.\n   * If there are no cached capabilities and none can be fetched, throw an exception.\n   *\n   * @returns Promise resolving with The capabilities of the homeserver\n   */\n  getCapabilities() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      var caps = _this5.serverCapabilitiesService.getCachedCapabilities();\n      if (caps) return caps;\n      return _this5.serverCapabilitiesService.fetchCapabilities();\n    })();\n  }\n\n  /**\n   * Gets the cached capabilities of the homeserver. If none have been fetched yet,\n   * return undefined.\n   *\n   * @returns The capabilities of the homeserver\n   */\n  getCachedCapabilities() {\n    return this.serverCapabilitiesService.getCachedCapabilities();\n  }\n\n  /**\n   * Fetches the latest capabilities from the homeserver, ignoring any cached\n   * versions. The newly returned version is cached.\n   *\n   * @returns A promise which resolves to the capabilities of the homeserver\n   */\n  fetchCapabilities() {\n    return this.serverCapabilitiesService.fetchCapabilities();\n  }\n\n  /**\n   * Initialise support for end-to-end encryption in this client, using the rust matrix-sdk-crypto.\n   *\n   * **WARNING**: the cryptography stack is not thread-safe. Having multiple `MatrixClient` instances connected to\n   * the same Indexed DB will cause data corruption and decryption failures. The application layer is responsible for\n   * ensuring that only one `MatrixClient` issue is instantiated at a time.\n   *\n   * @param args.useIndexedDB - True to use an indexeddb store, false to use an in-memory store. Defaults to 'true'.\n   * @param args.storageKey - A key with which to encrypt the indexeddb store. If provided, it must be exactly\n   *    32 bytes of data, and must be the same each time the client is initialised for a given device.\n   *    If both this and `storagePassword` are unspecified, the store will be unencrypted.\n   * @param args.storagePassword - An alternative to `storageKey`. A password which will be used to derive a key to\n   *    encrypt the store with. Deriving a key from a password is (deliberately) a slow operation, so prefer\n   *    to pass a `storageKey` directly where possible.\n   *\n   * @returns a Promise which will resolve when the crypto layer has been\n   *    successfully initialised.\n   */\n  initRustCrypto() {\n    var _arguments = arguments,\n      _this6 = this;\n    return _asyncToGenerator(function* () {\n      var _this6$legacyPickleKe;\n      var args = _arguments.length > 0 && _arguments[0] !== undefined ? _arguments[0] : {};\n      if (_this6.cryptoBackend) {\n        _this6.logger.warn(\"Attempt to re-initialise e2e encryption on MatrixClient\");\n        return;\n      }\n      var userId = _this6.getUserId();\n      if (userId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown userId: \" + \"ensure userId is passed in createClient().\");\n      }\n      var deviceId = _this6.getDeviceId();\n      if (deviceId === null) {\n        throw new Error(\"Cannot enable encryption on MatrixClient with unknown deviceId: \" + \"ensure deviceId is passed in createClient().\");\n      }\n\n      // importing rust-crypto will download the webassembly, so we delay it until we know it will be\n      // needed.\n      _this6.logger.debug(\"Downloading Rust crypto library\");\n      var RustCrypto = yield import(\"./rust-crypto/index.js\");\n      var rustCrypto = yield RustCrypto.initRustCrypto({\n        logger: _this6.logger,\n        http: _this6.http,\n        userId: userId,\n        deviceId: deviceId,\n        secretStorage: _this6.secretStorage,\n        cryptoCallbacks: _this6.cryptoCallbacks,\n        storePrefix: args.useIndexedDB === false ? null : RUST_SDK_STORE_PREFIX,\n        storeKey: args.storageKey,\n        storePassphrase: args.storagePassword,\n        legacyCryptoStore: _this6.legacyCryptoStore,\n        legacyPickleKey: (_this6$legacyPickleKe = _this6.legacyPickleKey) !== null && _this6$legacyPickleKe !== void 0 ? _this6$legacyPickleKe : \"DEFAULT_KEY\",\n        legacyMigrationProgressListener: (progress, total) => {\n          _this6.emit(CryptoEvent.LegacyCryptoStoreMigrationProgress, progress, total);\n        }\n      });\n      rustCrypto.setSupportedVerificationMethods(_this6.verificationMethods);\n      _this6.cryptoBackend = rustCrypto;\n\n      // attach the event listeners needed by RustCrypto\n      _this6.on(RoomMemberEvent.Membership, rustCrypto.onRoomMembership.bind(rustCrypto));\n      _this6.on(ClientEvent.Event, event => {\n        rustCrypto.onLiveEventFromSync(event);\n      });\n\n      // re-emit the events emitted by the crypto impl\n      _this6.reEmitter.reEmit(rustCrypto, [CryptoEvent.VerificationRequestReceived, CryptoEvent.UserTrustStatusChanged, CryptoEvent.KeyBackupStatus, CryptoEvent.KeyBackupSessionsRemaining, CryptoEvent.KeyBackupFailed, CryptoEvent.KeyBackupDecryptionKeyCached, CryptoEvent.KeysChanged, CryptoEvent.DevicesUpdated, CryptoEvent.WillUpdateDevices, CryptoEvent.DehydratedDeviceCreated, CryptoEvent.DehydratedDeviceUploaded, CryptoEvent.RehydrationStarted, CryptoEvent.RehydrationProgress, CryptoEvent.RehydrationCompleted, CryptoEvent.RehydrationError, CryptoEvent.DehydrationKeyCached, CryptoEvent.DehydratedDeviceRotationError]);\n    })();\n  }\n\n  /**\n   * Access the server-side secret storage API for this client.\n   */\n  get secretStorage() {\n    return this._secretStorage;\n  }\n\n  /**\n   * Access the crypto API for this client.\n   *\n   * If end-to-end encryption has been enabled for this client (via {@link initRustCrypto}),\n   * returns an object giving access to the crypto API. Otherwise, returns `undefined`.\n   */\n  getCrypto() {\n    return this.cryptoBackend;\n  }\n\n  /**\n   * Whether encryption is enabled for a room.\n   * @param roomId - the room id to query.\n   * @returns whether encryption is enabled.\n   *\n   * @deprecated Not correctly supported for Rust Cryptography. Use {@link CryptoApi.isEncryptionEnabledInRoom} and/or\n   *    {@link Room.hasEncryptionStateEvent}.\n   */\n  isRoomEncrypted(roomId) {\n    var room = this.getRoom(roomId);\n    if (!room) {\n      // we don't know about this room, so can't determine if it should be\n      // encrypted. Let's assume not.\n      return false;\n    }\n\n    // if there is an 'm.room.encryption' event in this room, it should be\n    // encrypted (independently of whether we actually support encryption)\n    return room.hasEncryptionStateEvent();\n  }\n\n  /**\n   * Check whether the key backup private key is stored in secret storage.\n   * @returns map of key name to key info the secret is\n   *     encrypted with, or null if it is not present or not encrypted with a\n   *     trusted key\n   */\n  isKeyBackupKeyStored() {\n    return Promise.resolve(this.secretStorage.isStored(\"m.megolm_backup.v1\"));\n  }\n  makeKeyBackupPath(roomId, sessionId, version) {\n    var path;\n    if (sessionId !== undefined) {\n      path = utils.encodeUri(\"/room_keys/keys/$roomId/$sessionId\", {\n        $roomId: roomId,\n        $sessionId: sessionId\n      });\n    } else if (roomId !== undefined) {\n      path = utils.encodeUri(\"/room_keys/keys/$roomId\", {\n        $roomId: roomId\n      });\n    } else {\n      path = \"/room_keys/keys\";\n    }\n    var queryData = version === undefined ? undefined : {\n      version\n    };\n    return {\n      path,\n      queryData\n    };\n  }\n  deleteKeysFromBackup(roomId, sessionId, version) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      var path = _this7.makeKeyBackupPath(roomId, sessionId, version);\n      yield _this7.http.authedRequest(Method.Delete, path.path, path.queryData, undefined, {\n        prefix: ClientPrefix.V3\n      });\n    })();\n  }\n\n  /**\n   * Get the config for the media repository.\n   *\n   * @param useAuthenticatedMedia - If true, the caller supports authenticated\n   * media and wants an authentication-required URL. Note that server support\n   * for authenticated media will *not* be checked - it is the caller's responsibility\n   * to do so before calling this function.\n   *\n   * @returns Promise which resolves with an object containing the config.\n   */\n  getMediaConfig() {\n    var useAuthenticatedMedia = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var path = useAuthenticatedMedia ? \"/media/config\" : \"/config\";\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: useAuthenticatedMedia ? ClientPrefix.V1 : MediaPrefix.V3\n    });\n  }\n\n  /**\n   * Get the room for the given room ID.\n   * This function will return a valid room for any room for which a Room event\n   * has been emitted. Note in particular that other events, eg. RoomState.members\n   * will be emitted for a room before this function will return the given room.\n   * @param roomId - The room ID\n   * @returns The Room or null if it doesn't exist or there is no data store.\n   */\n  getRoom(roomId) {\n    if (!roomId) {\n      return null;\n    }\n    return this.store.getRoom(roomId);\n  }\n\n  /**\n   * Retrieve all known rooms.\n   * @returns A list of rooms, or an empty list if there is no data store.\n   */\n  getRooms() {\n    return this.store.getRooms();\n  }\n\n  /**\n   * Retrieve all rooms that should be displayed to the user\n   * This is essentially getRooms() with some rooms filtered out, eg. old versions\n   * of rooms that have been replaced or (in future) other rooms that have been\n   * marked at the protocol level as not to be displayed to the user.\n   *\n   * @param msc3946ProcessDynamicPredecessor - if true, look for an\n   *                                           m.room.predecessor state event and\n   *                                           use it if found (MSC3946).\n   * @returns A list of rooms, or an empty list if there is no data store.\n   */\n  getVisibleRooms() {\n    var msc3946ProcessDynamicPredecessor = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var allRooms = this.store.getRooms();\n    var replacedRooms = new Set();\n    for (var r of allRooms) {\n      var _r$findPredecessor;\n      var predecessor = (_r$findPredecessor = r.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _r$findPredecessor === void 0 ? void 0 : _r$findPredecessor.roomId;\n      if (predecessor) {\n        replacedRooms.add(predecessor);\n      }\n    }\n    return allRooms.filter(r => {\n      var tombstone = r.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n      if (tombstone && replacedRooms.has(r.roomId)) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Retrieve a user.\n   * @param userId - The user ID to retrieve.\n   * @returns A user or null if there is no data store or the user does\n   * not exist.\n   */\n  getUser(userId) {\n    return this.store.getUser(userId);\n  }\n\n  /**\n   * Retrieve all known users.\n   * @returns A list of users, or an empty list if there is no data store.\n   */\n  getUsers() {\n    return this.store.getUsers();\n  }\n\n  /**\n   * Set account data event for the current user, and wait for the result to be echoed over `/sync`.\n   *\n   * Waiting for the remote echo ensures that a subsequent call to {@link getAccountData} will return the updated\n   * value.\n   *\n   * If called before the client is started with {@link startClient}, logs a warning and falls back to\n   * {@link setAccountDataRaw}.\n   *\n   * Retries the request up to 5 times in the case of an {@link ConnectionError}.\n   *\n   * @param eventType - The event type\n   * @param content - the contents object for the event\n   */\n  setAccountData(eventType, content) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // If the sync loop is not running, fall back to setAccountDataRaw.\n      if (!_this8.clientRunning) {\n        logger.warn(\"Calling `setAccountData` before the client is started: `getAccountData` may return inconsistent results.\");\n        return yield retryNetworkOperation(5, () => _this8.setAccountDataRaw(eventType, content));\n      }\n\n      // If the account data is already correct, then we cannot expect an update over sync, and the operation\n      // is, in any case, a no-op.\n      //\n      // NB that we rely on this operation being synchronous to avoid a race condition: there must be no `await`\n      // between here and `this.addListener` below, in case we miss an update.\n      var existingData = _this8.store.getAccountData(eventType);\n      if (existingData && deepCompare(existingData.event.content, content)) return {};\n\n      // Create a promise which will resolve when the update is received\n      var updatedDefer = defer();\n      function accountDataListener(event) {\n        // Note that we cannot safely check that the content matches what we expected, because there is a race:\n        //   * We set the new content\n        //   * Another client sets alternative content\n        //   * Then /sync returns, but only reflects the latest content.\n        //\n        // Of course there is room for debate over what we should actually do in that case -- a subsequent\n        // `getAccountData` isn't going to return the expected value, but whose fault is that? Databases are hard.\n        //\n        // Anyway, what we *shouldn't* do is get stuck in a loop. I think the best we can do is check that the event\n        // type matches.\n        if (event.getType() === eventType) updatedDefer.resolve();\n      }\n      _this8.addListener(ClientEvent.AccountData, accountDataListener);\n      try {\n        var result = yield retryNetworkOperation(5, () => _this8.setAccountDataRaw(eventType, content));\n        yield updatedDefer.promise;\n        return result;\n      } finally {\n        _this8.removeListener(ClientEvent.AccountData, accountDataListener);\n      }\n    })();\n  }\n\n  /**\n   * Set account data event for the current user, without waiting for the remote echo.\n   *\n   * @param eventType - The event type\n   * @param content - the contents object for the event\n   */\n  setAccountDataRaw(eventType, content) {\n    var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n      $userId: this.credentials.userId,\n      $type: eventType\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, content);\n  }\n\n  /**\n   * Get account data event of given type for the current user.\n   * @param eventType - The event type\n   * @returns The contents of the given account data event\n   */\n  getAccountData(eventType) {\n    return this.store.getAccountData(eventType);\n  }\n\n  /**\n   * Get account data event of given type for the current user. This variant\n   * gets account data directly from the homeserver if the local store is not\n   * ready, which can be useful very early in startup before the initial sync.\n   * @param eventType - The event type\n   * @returns Promise which resolves: The contents of the given account data event.\n   * @returns Rejects: with an error response.\n   */\n  getAccountDataFromServer(eventType) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.isInitialSyncComplete()) {\n        var _event = _this9.store.getAccountData(eventType);\n        if (!_event) {\n          return null;\n        }\n        // The network version below returns just the content, so this branch\n        // does the same to match.\n        return _event.getContent();\n      }\n      var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n        $userId: _this9.credentials.userId,\n        $type: eventType\n      });\n      try {\n        return yield _this9.http.authedRequest(Method.Get, path);\n      } catch (e) {\n        var _data;\n        if (((_data = e.data) === null || _data === void 0 ? void 0 : _data.errcode) === \"M_NOT_FOUND\") {\n          return null;\n        }\n        throw e;\n      }\n    })();\n  }\n  deleteAccountData(eventType) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      var msc3391DeleteAccountDataServerSupport = _this10.canSupport.get(Feature.AccountDataDeletion);\n      // if deletion is not supported overwrite with empty content\n      if (msc3391DeleteAccountDataServerSupport === ServerSupport.Unsupported) {\n        yield _this10.setAccountData(eventType, {});\n        return;\n      }\n      var path = utils.encodeUri(\"/user/$userId/account_data/$type\", {\n        $userId: _this10.getSafeUserId(),\n        $type: eventType\n      });\n      var options = msc3391DeleteAccountDataServerSupport === ServerSupport.Unstable ? {\n        prefix: \"/_matrix/client/unstable/org.matrix.msc3391\"\n      } : undefined;\n      return yield _this10.http.authedRequest(Method.Delete, path, undefined, undefined, options);\n    })();\n  }\n\n  /**\n   * Gets the users that are ignored by this client\n   * @returns The array of users that are ignored (empty if none)\n   */\n  getIgnoredUsers() {\n    var event = this.getAccountData(EventType.IgnoredUserList);\n    if (!(event !== null && event !== void 0 && event.getContent()[\"ignored_users\"])) return [];\n    return Object.keys(event.getContent()[\"ignored_users\"]);\n  }\n\n  /**\n   * Sets the users that the current user should ignore.\n   * @param userIds - the user IDs to ignore\n   * @returns Promise which resolves: an empty object\n   * @returns Rejects: with an error response.\n   */\n  setIgnoredUsers(userIds) {\n    var content = {\n      ignored_users: {}\n    };\n    userIds.forEach(u => {\n      content.ignored_users[u] = {};\n    });\n    return this.setAccountData(EventType.IgnoredUserList, content);\n  }\n\n  /**\n   * Gets whether or not a specific user is being ignored by this client.\n   * @param userId - the user ID to check\n   * @returns true if the user is ignored, false otherwise\n   */\n  isUserIgnored(userId) {\n    return this.getIgnoredUsers().includes(userId);\n  }\n\n  /**\n   * Join a room. If you have already joined the room, this will no-op.\n   * @param roomIdOrAlias - The room ID or room alias to join.\n   * @param opts - Options when joining the room.\n   * @returns Promise which resolves: Room object.\n   * @returns Rejects: with an error response.\n   */\n  joinRoom(roomIdOrAlias) {\n    var _arguments2 = arguments,\n      _this11 = this;\n    return _asyncToGenerator(function* () {\n      var opts = _arguments2.length > 1 && _arguments2[1] !== undefined ? _arguments2[1] : {};\n      if (opts.syncRoom === undefined) {\n        opts.syncRoom = true;\n      }\n      var room = _this11.getRoom(roomIdOrAlias);\n      if (room !== null && room !== void 0 && room.hasMembershipState(_this11.credentials.userId, KnownMembership.Join)) return room;\n      var signPromise = Promise.resolve();\n      if (opts.inviteSignUrl) {\n        var _url = new URL(opts.inviteSignUrl);\n        _url.searchParams.set(\"mxid\", _this11.credentials.userId);\n        signPromise = _this11.http.requestOtherUrl(Method.Post, _url);\n      }\n      var queryParams = {};\n      if (opts.viaServers) {\n        // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n        queryParams.server_name = opts.viaServers;\n        queryParams.via = opts.viaServers;\n      }\n      var data = {};\n      var signedInviteObj = yield signPromise;\n      if (signedInviteObj) {\n        data.third_party_signed = signedInviteObj;\n      }\n      var path = utils.encodeUri(\"/join/$roomid\", {\n        $roomid: roomIdOrAlias\n      });\n      var res = yield _this11.http.authedRequest(Method.Post, path, queryParams, data);\n      var roomId = res.room_id;\n      // In case we were originally given an alias, check the room cache again\n      // with the resolved ID - this method is supposed to no-op if we already\n      // were in the room, after all.\n      var resolvedRoom = _this11.getRoom(roomId);\n      if (resolvedRoom !== null && resolvedRoom !== void 0 && resolvedRoom.hasMembershipState(_this11.credentials.userId, KnownMembership.Join)) return resolvedRoom;\n      var syncApi = new SyncApi(_this11, _this11.clientOpts, _this11.buildSyncApiOptions());\n      var syncRoom = syncApi.createRoom(roomId);\n      if (opts.syncRoom) {\n        // v2 will do this for us\n        // return syncApi.syncRoom(room);\n      }\n      return syncRoom;\n    })();\n  }\n\n  /**\n   * Knock a room. If you have already knocked the room, this will no-op.\n   * @param roomIdOrAlias - The room ID or room alias to knock.\n   * @param opts - Options when knocking the room.\n   * @returns Promise which resolves: `{room_id: {string}}`\n   * @returns Rejects: with an error response.\n   */\n  knockRoom(roomIdOrAlias) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var room = this.getRoom(roomIdOrAlias);\n    if (room !== null && room !== void 0 && room.hasMembershipState(this.credentials.userId, KnownMembership.Knock)) {\n      return Promise.resolve({\n        room_id: room.roomId\n      });\n    }\n    var path = utils.encodeUri(\"/knock/$roomIdOrAlias\", {\n      $roomIdOrAlias: roomIdOrAlias\n    });\n    var queryParams = {};\n    if (opts.viaServers) {\n      // server_name has been deprecated in favour of via with Matrix >1.11 (MSC4156)\n      queryParams.server_name = opts.viaServers;\n      queryParams.via = opts.viaServers;\n    }\n    var body = {};\n    if (opts.reason) {\n      body.reason = opts.reason;\n    }\n    return this.http.authedRequest(Method.Post, path, queryParams, body);\n  }\n\n  /**\n   * Resend an event. Will also retry any to-device messages waiting to be sent.\n   * @param event - The event to resend.\n   * @param room - Optional. The room the event is in. Will update the\n   * timeline entry if provided.\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n  resendEvent(event, room) {\n    // also kick the to-device queue to retry\n    this.toDeviceMessageQueue.sendQueue();\n    this.updatePendingEventStatus(room, event, EventStatus.SENDING);\n    return this.encryptAndSendEvent(room, event);\n  }\n\n  /**\n   * Cancel a queued or unsent event.\n   *\n   * @param event -   Event to cancel\n   * @throws Error if the event is not in QUEUED, NOT_SENT or ENCRYPTING state\n   */\n  cancelPendingEvent(event) {\n    if (![EventStatus.QUEUED, EventStatus.NOT_SENT, EventStatus.ENCRYPTING].includes(event.status)) {\n      throw new Error(\"cannot cancel an event with status \" + event.status);\n    }\n\n    // If the event is currently being encrypted then remove it from the pending list, to indicate that it should\n    // not be sent.\n    if (event.status === EventStatus.ENCRYPTING) {\n      this.eventsBeingEncrypted.delete(event.getId());\n    } else if (this.scheduler && event.status === EventStatus.QUEUED) {\n      // tell the scheduler to forget about it, if it's queued\n      this.scheduler.removeEventFromQueue(event);\n    }\n\n    // then tell the room about the change of state, which will remove it\n    // from the room's list of pending events.\n    var room = this.getRoom(event.getRoomId());\n    this.updatePendingEventStatus(room, event, EventStatus.CANCELLED);\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  setRoomName(roomId, name) {\n    return this.sendStateEvent(roomId, EventType.RoomName, {\n      name: name\n    });\n  }\n\n  /**\n   * @param roomId - The room to update the topic in.\n   * @param topic - The plaintext topic. May be empty to remove the topic.\n   * @param htmlTopic - Optional.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  setRoomTopic(roomId, topic, htmlTopic) {\n    var content = ContentHelpers.makeTopicContent(topic, htmlTopic);\n    return this.sendStateEvent(roomId, EventType.RoomTopic, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to an object keyed by tagId with objects containing a numeric order field.\n   * @returns Rejects: with an error response.\n   */\n  getRoomTags(roomId) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param tagName - name of room tag to be set\n   * @param metadata - associated with that tag to be stored\n   * @returns Promise which resolves: to an empty object\n   * @returns Rejects: with an error response.\n   */\n  setRoomTag(roomId, tagName) {\n    var metadata = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $tag: tagName\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, metadata);\n  }\n\n  /**\n   * @param tagName - name of room tag to be removed\n   * @returns Promise which resolves: to an empty object\n   * @returns Rejects: with an error response.\n   */\n  deleteRoomTag(roomId, tagName) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/tags/$tag\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $tag: tagName\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * @param eventType - event type to be set\n   * @param content - event content\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setRoomAccountData(roomId, eventType, content) {\n    var path = utils.encodeUri(\"/user/$userId/rooms/$roomId/account_data/$type\", {\n      $userId: this.credentials.userId,\n      $roomId: roomId,\n      $type: eventType\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, content);\n  }\n\n  /**\n   * Set a power level to one or multiple users.\n   * Will apply changes atop of current power level event from local state if running & synced, falling back\n   * to fetching latest from the `/state/` API.\n   * @param roomId - the room to update power levels in\n   * @param userId - the ID of the user or users to update power levels of\n   * @param powerLevel - the numeric power level to update given users to\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n  setPowerLevel(roomId, userId, powerLevel) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      var _content;\n      var content;\n      if (_this12.clientRunning && _this12.isInitialSyncComplete()) {\n        var _this12$getRoom;\n        content = (_this12$getRoom = _this12.getRoom(roomId)) === null || _this12$getRoom === void 0 || (_this12$getRoom = _this12$getRoom.currentState) === null || _this12$getRoom === void 0 || (_this12$getRoom = _this12$getRoom.getStateEvents(EventType.RoomPowerLevels, \"\")) === null || _this12$getRoom === void 0 ? void 0 : _this12$getRoom.getContent();\n      }\n      if (!content) {\n        try {\n          content = yield _this12.getStateEvent(roomId, EventType.RoomPowerLevels, \"\");\n        } catch (e) {\n          // It is possible for a Matrix room to not have a power levels event\n          if (e instanceof MatrixError && e.errcode === \"M_NOT_FOUND\") {\n            content = {};\n          } else {\n            throw e;\n          }\n        }\n      }\n\n      // take a copy of the content to ensure we don't corrupt\n      // existing client state with a failed power level change\n      content = utils.deepCopy(content);\n      if (!((_content = content) !== null && _content !== void 0 && _content.users)) {\n        content.users = {};\n      }\n      var users = Array.isArray(userId) ? userId : [userId];\n      for (var user of users) {\n        if (powerLevel == null) {\n          delete content.users[user];\n        } else {\n          content.users[user] = powerLevel;\n        }\n      }\n      return _this12.sendStateEvent(roomId, EventType.RoomPowerLevels, content, \"\");\n    })();\n  }\n\n  /**\n   * Create an m.beacon_info event\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  unstable_createLiveBeacon(roomId, beaconInfoContent) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return _this13.unstable_setLiveBeacon(roomId, beaconInfoContent);\n    })();\n  }\n\n  /**\n   * Upsert a live beacon event\n   * using a specific m.beacon_info.* event variable type\n   * @param roomId - string\n   * @returns\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  unstable_setLiveBeacon(roomId, beaconInfoContent) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return _this14.sendStateEvent(roomId, M_BEACON_INFO.name, beaconInfoContent, _this14.getUserId());\n    })();\n  }\n  sendEvent(roomId, threadIdOrEventType, eventTypeOrContent, contentOrTxnId, txnIdOrVoid) {\n    var threadId;\n    var eventType;\n    var content;\n    var txnId;\n    if (!(threadIdOrEventType !== null && threadIdOrEventType !== void 0 && threadIdOrEventType.startsWith(EVENT_ID_PREFIX)) && threadIdOrEventType !== null) {\n      txnId = contentOrTxnId;\n      content = eventTypeOrContent;\n      eventType = threadIdOrEventType;\n      threadId = null;\n    } else {\n      txnId = txnIdOrVoid;\n      content = contentOrTxnId;\n      eventType = eventTypeOrContent;\n      threadId = threadIdOrEventType;\n    }\n    this.addThreadRelationIfNeeded(content, threadId, roomId);\n    return this.sendCompleteEvent(roomId, threadId, {\n      type: eventType,\n      content\n    }, txnId);\n  }\n\n  /**\n   * If we expect that an event is part of a thread but is missing the relation\n   * we need to add it manually, as well as the reply fallback\n   */\n  addThreadRelationIfNeeded(content, threadId, roomId) {\n    var _content$mRelates_to;\n    if (threadId && !((_content$mRelates_to = content[\"m.relates_to\"]) !== null && _content$mRelates_to !== void 0 && _content$mRelates_to.rel_type)) {\n      var _content$mRelates_to2, _this$getRoom;\n      var isReply = !!((_content$mRelates_to2 = content[\"m.relates_to\"]) !== null && _content$mRelates_to2 !== void 0 && _content$mRelates_to2[\"m.in_reply_to\"]);\n      content[\"m.relates_to\"] = _objectSpread(_objectSpread({}, content[\"m.relates_to\"]), {}, {\n        rel_type: THREAD_RELATION_TYPE.name,\n        event_id: threadId,\n        // Set is_falling_back to true unless this is actually intended to be a reply\n        is_falling_back: !isReply\n      });\n      var thread = (_this$getRoom = this.getRoom(roomId)) === null || _this$getRoom === void 0 ? void 0 : _this$getRoom.getThread(threadId);\n      if (thread && !isReply) {\n        var _thread$lastReply$get, _thread$lastReply;\n        content[\"m.relates_to\"][\"m.in_reply_to\"] = {\n          event_id: (_thread$lastReply$get = (_thread$lastReply = thread.lastReply(ev => {\n            return ev.isRelation(THREAD_RELATION_TYPE.name) && !ev.status;\n          })) === null || _thread$lastReply === void 0 ? void 0 : _thread$lastReply.getId()) !== null && _thread$lastReply$get !== void 0 ? _thread$lastReply$get : threadId\n        };\n      }\n    }\n  }\n\n  /**\n   * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n\n  /**\n   * Sends a delayed event (MSC4140).\n   * @param eventObject - An object with the partial structure of an event, to which event_id, user_id, room_id and origin_server_ts will be added.\n   * @param delayOpts - Properties of the delay for this event.\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n\n  sendCompleteEvent(roomId, threadId, eventObject, delayOptsOrTxnId, txnIdOrVoid) {\n    var delayOpts;\n    var txnId;\n    if (typeof delayOptsOrTxnId === \"string\") {\n      txnId = delayOptsOrTxnId;\n    } else {\n      delayOpts = delayOptsOrTxnId;\n      txnId = txnIdOrVoid;\n    }\n    if (!txnId) {\n      txnId = this.makeTxnId();\n    }\n\n    // We always construct a MatrixEvent when sending because the store and scheduler use them.\n    // We'll extract the params back out if it turns out the client has no scheduler or store.\n    var localEvent = new MatrixEvent(Object.assign(eventObject, {\n      event_id: \"~\" + roomId + \":\" + txnId,\n      user_id: this.credentials.userId,\n      sender: this.credentials.userId,\n      room_id: roomId,\n      origin_server_ts: new Date().getTime()\n    }));\n    var room = this.getRoom(roomId);\n    var thread = threadId ? room === null || room === void 0 ? void 0 : room.getThread(threadId) : undefined;\n    if (thread) {\n      localEvent.setThread(thread);\n    }\n    if (!delayOpts) {\n      // set up re-emitter for this new event - this is normally the job of EventMapper but we don't use it here\n      this.reEmitter.reEmit(localEvent, [MatrixEventEvent.Replaced, MatrixEventEvent.VisibilityChange]);\n      room === null || room === void 0 || room.reEmitter.reEmit(localEvent, [MatrixEventEvent.BeforeRedaction]);\n    }\n\n    // if this is a relation or redaction of an event\n    // that hasn't been sent yet (e.g. with a local id starting with a ~)\n    // then listen for the remote echo of that event so that by the time\n    // this event does get sent, we have the correct event_id\n    var targetId = localEvent.getAssociatedId();\n    if (targetId !== null && targetId !== void 0 && targetId.startsWith(\"~\")) {\n      var target = room === null || room === void 0 ? void 0 : room.getPendingEvents().find(e => e.getId() === targetId);\n      target === null || target === void 0 || target.once(MatrixEventEvent.LocalEventIdReplaced, () => {\n        localEvent.updateAssociatedId(target.getId());\n      });\n    }\n    var type = localEvent.getType();\n    this.logger.debug(\"sendEvent of type \".concat(type, \" in \").concat(roomId, \" with txnId \").concat(txnId).concat(delayOpts ? \" (delayed event)\" : \"\"));\n    localEvent.setTxnId(txnId);\n    localEvent.setStatus(EventStatus.SENDING);\n\n    // TODO: separate store for delayed events?\n    if (!delayOpts) {\n      // add this event immediately to the local store as 'sending'.\n      room === null || room === void 0 || room.addPendingEvent(localEvent, txnId);\n\n      // addPendingEvent can change the state to NOT_SENT if it believes\n      // that there's other events that have failed. We won't bother to\n      // try sending the event if the state has changed as such.\n      if (localEvent.status === EventStatus.NOT_SENT) {\n        return Promise.reject(new Error(\"Event blocked by other events not yet sent\"));\n      }\n      return this.encryptAndSendEvent(room, localEvent);\n    } else {\n      return this.encryptAndSendEvent(room, localEvent, delayOpts);\n    }\n  }\n\n  /**\n   * encrypts the event if necessary; adds the event to the queue, or sends it; marks the event as sent/unsent\n   * @returns returns a promise which resolves with the result of the send request\n   */\n\n  /**\n   * Simply sends a delayed event without encrypting it.\n   * TODO: Allow encrypted delayed events, and encrypt them properly\n   * @param delayOpts - Properties of the delay for this event.\n   * @returns returns a promise which resolves with the result of the delayed send request\n   */\n\n  encryptAndSendEvent(room, event, delayOpts) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      if (delayOpts) {\n        return _this15.sendEventHttpRequest(event, delayOpts);\n      }\n      try {\n        var cancelled;\n        _this15.eventsBeingEncrypted.add(event.getId());\n        try {\n          yield _this15.encryptEventIfNeeded(event, room !== null && room !== void 0 ? room : undefined);\n        } finally {\n          cancelled = !_this15.eventsBeingEncrypted.delete(event.getId());\n        }\n        if (cancelled) {\n          // cancelled via MatrixClient::cancelPendingEvent\n          return {};\n        }\n\n        // encryptEventIfNeeded may have updated the status from SENDING to ENCRYPTING. If so, we need\n        // to put it back.\n        if (event.status === EventStatus.ENCRYPTING) {\n          _this15.updatePendingEventStatus(room, event, EventStatus.SENDING);\n        }\n        var promise = null;\n        if (_this15.scheduler) {\n          // if this returns a promise then the scheduler has control now and will\n          // resolve/reject when it is done. Internally, the scheduler will invoke\n          // processFn which is set to this._sendEventHttpRequest so the same code\n          // path is executed regardless.\n          promise = _this15.scheduler.queueEvent(event);\n          if (promise && _this15.scheduler.getQueueForEvent(event).length > 1) {\n            // event is processed FIFO so if the length is 2 or more we know\n            // this event is stuck behind an earlier event.\n            _this15.updatePendingEventStatus(room, event, EventStatus.QUEUED);\n          }\n        }\n        if (!promise) {\n          promise = _this15.sendEventHttpRequest(event);\n          if (room) {\n            promise = promise.then(res => {\n              room.updatePendingEvent(event, EventStatus.SENT, res[\"event_id\"]);\n              return res;\n            });\n          }\n        }\n        return yield promise;\n      } catch (err) {\n        _this15.logger.error(\"Error sending event\", err);\n        try {\n          // set the error on the event before we update the status:\n          // updating the status emits the event, so the state should be\n          // consistent at that point.\n          event.error = err;\n          _this15.updatePendingEventStatus(room, event, EventStatus.NOT_SENT);\n        } catch (e) {\n          _this15.logger.error(\"Exception in error handler!\", e);\n        }\n        if (err instanceof MatrixError) {\n          err.event = event;\n        }\n        throw err;\n      }\n    })();\n  }\n  encryptEventIfNeeded(event, room) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      // If the room is unknown, we cannot encrypt for it\n      if (!room) return;\n      if (!(yield _this16.shouldEncryptEventForRoom(event, room))) return;\n      if (!_this16.cryptoBackend && _this16.usingExternalCrypto) {\n        // The client has opted to allow sending messages to encrypted\n        // rooms even if the room is encrypted, and we haven't set up\n        // crypto. This is useful for users of matrix-org/pantalaimon\n        return;\n      }\n      if (!_this16.cryptoBackend) {\n        throw new Error(\"This room is configured to use encryption, but your client does not support encryption.\");\n      }\n      _this16.updatePendingEventStatus(room, event, EventStatus.ENCRYPTING);\n      yield _this16.cryptoBackend.encryptEvent(event, room);\n    })();\n  }\n\n  /**\n   * Determine whether a given event should be encrypted when we send it to the given room.\n   *\n   * This takes into account event type and room configuration.\n   */\n  shouldEncryptEventForRoom(event, room) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      var _this17$cryptoBackend;\n      if (event.isEncrypted()) {\n        // this event has already been encrypted; this happens if the\n        // encryption step succeeded, but the send step failed on the first\n        // attempt.\n        return false;\n      }\n      if (event.getType() === EventType.Reaction) {\n        // For reactions, there is a very little gained by encrypting the entire\n        // event, as relation data is already kept in the clear. Event\n        // encryption for a reaction effectively only obscures the event type,\n        // but the purpose is still obvious from the relation data, so nothing\n        // is really gained. It also causes quite a few problems, such as:\n        //   * triggers notifications via default push rules\n        //   * prevents server-side bundling for reactions\n        // The reaction key / content / emoji value does warrant encrypting, but\n        // this will be handled separately by encrypting just this value.\n        // See https://github.com/matrix-org/matrix-doc/pull/1849#pullrequestreview-248763642\n        return false;\n      }\n      if (event.isRedaction()) {\n        // Redactions do not support encryption in the spec at this time.\n        // Whilst it mostly worked in some clients, it wasn't compliant.\n        return false;\n      }\n\n      // If the room has an m.room.encryption event, we should encrypt.\n      if (room.hasEncryptionStateEvent()) return true;\n\n      // If we have a crypto impl, and *it* thinks we should encrypt, then we should.\n      if (yield (_this17$cryptoBackend = _this17.cryptoBackend) === null || _this17$cryptoBackend === void 0 ? void 0 : _this17$cryptoBackend.isEncryptionEnabledInRoom(room.roomId)) return true;\n\n      // Otherwise, no need to encrypt.\n      return false;\n    })();\n  }\n\n  /**\n   * Returns the eventType that should be used taking encryption into account\n   * for a given eventType.\n   * @param roomId - the room for the events `eventType` relates to\n   * @param eventType - the event type\n   * @returns the event type taking encryption into account\n   */\n  getEncryptedIfNeededEventType(roomId, eventType) {\n    var _this$getRoom2;\n    if (eventType === EventType.Reaction) return eventType;\n    return (_this$getRoom2 = this.getRoom(roomId)) !== null && _this$getRoom2 !== void 0 && _this$getRoom2.hasEncryptionStateEvent() ? EventType.RoomMessageEncrypted : eventType;\n  }\n  updatePendingEventStatus(room, event, newStatus) {\n    if (room) {\n      room.updatePendingEvent(event, newStatus);\n    } else {\n      event.setStatus(newStatus);\n    }\n  }\n  sendEventHttpRequest(event, delayOpts) {\n    var txnId = event.getTxnId();\n    if (!txnId) {\n      txnId = this.makeTxnId();\n      event.setTxnId(txnId);\n    }\n    var pathParams = {\n      $roomId: event.getRoomId(),\n      $eventType: event.getWireType(),\n      $stateKey: event.getStateKey(),\n      $txnId: txnId\n    };\n    var path;\n    if (event.isState()) {\n      var pathTemplate = \"/rooms/$roomId/state/$eventType\";\n      if (event.getStateKey() && event.getStateKey().length > 0) {\n        pathTemplate = \"/rooms/$roomId/state/$eventType/$stateKey\";\n      }\n      path = utils.encodeUri(pathTemplate, pathParams);\n    } else if (event.isRedaction() && event.event.redacts) {\n      var _pathTemplate = \"/rooms/$roomId/redact/$redactsEventId/$txnId\";\n      path = utils.encodeUri(_pathTemplate, _objectSpread({\n        $redactsEventId: event.event.redacts\n      }, pathParams));\n    } else {\n      path = utils.encodeUri(\"/rooms/$roomId/send/$eventType/$txnId\", pathParams);\n    }\n    var content = event.getWireContent();\n    if (!delayOpts) {\n      return this.http.authedRequest(Method.Put, path, undefined, content).then(res => {\n        this.logger.debug(\"Event sent to \".concat(event.getRoomId(), \" with event id \").concat(res.event_id));\n        return res;\n      });\n    } else {\n      return this.http.authedRequest(Method.Put, path, getUnstableDelayQueryOpts(delayOpts), content);\n    }\n  }\n\n  /**\n   * @param txnId -  transaction id. One will be made up if not supplied.\n   * @param opts - Redact options\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   * @throws Error if called with `with_rel_types` (MSC3912) but the server does not support it.\n   *         Callers should check whether the server supports MSC3912 via `MatrixClient.canSupport`.\n   */\n\n  redactEvent(roomId, threadId, eventId, txnId, opts) {\n    var _eventId, _opts, _opts2;\n    if (!((_eventId = eventId) !== null && _eventId !== void 0 && _eventId.startsWith(EVENT_ID_PREFIX))) {\n      opts = txnId;\n      txnId = eventId;\n      eventId = threadId;\n      threadId = null;\n    }\n    var reason = (_opts = opts) === null || _opts === void 0 ? void 0 : _opts.reason;\n    var content = {\n      reason\n    };\n    if (((_opts2 = opts) === null || _opts2 === void 0 ? void 0 : _opts2.with_rel_types) !== undefined) {\n      if (this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Unsupported) {\n        throw new Error(\"Server does not support relation based redactions \" + \"roomId \".concat(roomId, \" eventId \").concat(eventId, \" txnId: \").concat(txnId, \" threadId \").concat(threadId));\n      }\n      var withRelTypesPropName = this.canSupport.get(Feature.RelationBasedRedactions) === ServerSupport.Stable ? MSC3912_RELATION_BASED_REDACTIONS_PROP.stable : MSC3912_RELATION_BASED_REDACTIONS_PROP.unstable;\n      content[withRelTypesPropName] = opts.with_rel_types;\n    }\n    return this.sendCompleteEvent(roomId, threadId, {\n      type: EventType.RoomRedaction,\n      content,\n      redacts: eventId\n    }, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to an ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendMessage(roomId, threadId, content, txnId) {\n    if (typeof threadId !== \"string\" && threadId !== null) {\n      txnId = content;\n      content = threadId;\n      threadId = null;\n    }\n    var eventType = EventType.RoomMessage;\n    var sendContent = content;\n    return this.sendEvent(roomId, threadId, eventType, sendContent, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns\n   * @returns Rejects: with an error response.\n   */\n\n  sendTextMessage(roomId, threadId, body, txnId) {\n    var _threadId;\n    if (!((_threadId = threadId) !== null && _threadId !== void 0 && _threadId.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeTextMessage(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendNotice(roomId, threadId, body, txnId) {\n    var _threadId2;\n    if (!((_threadId2 = threadId) !== null && _threadId2 !== void 0 && _threadId2.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeNotice(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @param txnId - Optional.\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendEmoteMessage(roomId, threadId, body, txnId) {\n    var _threadId3;\n    if (!((_threadId3 = threadId) !== null && _threadId3 !== void 0 && _threadId3.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      txnId = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeEmoteMessage(body);\n    return this.sendMessage(roomId, threadId, content, txnId);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendImageMessage(roomId, threadId, url, info) {\n    var _threadId4;\n    var text = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Image\";\n    if (!((_threadId4 = threadId) !== null && _threadId4 !== void 0 && _threadId4.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      text = info || \"Image\";\n      info = url;\n      url = threadId;\n      threadId = null;\n    }\n    var content = {\n      msgtype: MsgType.Image,\n      url: url,\n      info: info,\n      body: text\n    };\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendStickerMessage(roomId, threadId, url, info) {\n    var _threadId5;\n    var text = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : \"Sticker\";\n    if (!((_threadId5 = threadId) !== null && _threadId5 !== void 0 && _threadId5.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      text = info || \"Sticker\";\n      info = url;\n      url = threadId;\n      threadId = null;\n    }\n    var content = {\n      url: url,\n      info: info,\n      body: text\n    };\n    return this.sendEvent(roomId, threadId, EventType.Sticker, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlMessage(roomId, threadId, body, htmlBody) {\n    var _threadId6;\n    if (!((_threadId6 = threadId) !== null && _threadId6 !== void 0 && _threadId6.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlMessage(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlNotice(roomId, threadId, body, htmlBody) {\n    var _threadId7;\n    if (!((_threadId7 = threadId) !== null && _threadId7 !== void 0 && _threadId7.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlNotice(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * @returns Promise which resolves: to a ISendEventResponse object\n   * @returns Rejects: with an error response.\n   */\n\n  sendHtmlEmote(roomId, threadId, body, htmlBody) {\n    var _threadId8;\n    if (!((_threadId8 = threadId) !== null && _threadId8 !== void 0 && _threadId8.startsWith(EVENT_ID_PREFIX)) && threadId !== null) {\n      htmlBody = body;\n      body = threadId;\n      threadId = null;\n    }\n    var content = ContentHelpers.makeHtmlEmote(body, htmlBody);\n    return this.sendMessage(roomId, threadId, content);\n  }\n\n  /**\n   * Send a delayed timeline event.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_sendDelayedEvent(roomId, delayOpts, threadId, eventType, content, txnId) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this18.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw new UnsupportedDelayedEventsEndpointError(\"Server does not support the delayed events API\", \"sendDelayedEvent\");\n      }\n      _this18.addThreadRelationIfNeeded(content, threadId, roomId);\n      return _this18.sendCompleteEvent(roomId, threadId, {\n        type: eventType,\n        content\n      }, delayOpts, txnId);\n    })();\n  }\n\n  /**\n   * Send a delayed state event.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_sendDelayedStateEvent(roomId, delayOpts, eventType, content) {\n    var _arguments3 = arguments,\n      _this19 = this;\n    return _asyncToGenerator(function* () {\n      var stateKey = _arguments3.length > 4 && _arguments3[4] !== undefined ? _arguments3[4] : \"\";\n      var opts = _arguments3.length > 5 && _arguments3[5] !== undefined ? _arguments3[5] : {};\n      if (!(yield _this19.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw new UnsupportedDelayedEventsEndpointError(\"Server does not support the delayed events API\", \"sendDelayedStateEvent\");\n      }\n      var pathParams = {\n        $roomId: roomId,\n        $eventType: eventType,\n        $stateKey: stateKey\n      };\n      var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n      if (stateKey !== undefined) {\n        path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n      }\n      return _this19.http.authedRequest(Method.Put, path, getUnstableDelayQueryOpts(delayOpts), content, opts);\n    })();\n  }\n\n  /**\n   * Get all pending delayed events for the calling user.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_getDelayedEvents(fromToken) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this20.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw new UnsupportedDelayedEventsEndpointError(\"Server does not support the delayed events API\", \"getDelayedEvents\");\n      }\n      var queryDict = fromToken ? {\n        from: fromToken\n      } : undefined;\n      return yield _this20.http.authedRequest(Method.Get, \"/delayed_events\", queryDict, undefined, {\n        prefix: \"\".concat(ClientPrefix.Unstable, \"/\").concat(UNSTABLE_MSC4140_DELAYED_EVENTS)\n      });\n    })();\n  }\n\n  /**\n   * Manage a delayed event associated with the given delay_id.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC4140](https://github.com/matrix-org/matrix-spec-proposals/pull/4140) for more details.\n   */\n  // eslint-disable-next-line\n  _unstable_updateDelayedEvent(delayId, action) {\n    var _arguments4 = arguments,\n      _this21 = this;\n    return _asyncToGenerator(function* () {\n      var requestOptions = _arguments4.length > 2 && _arguments4[2] !== undefined ? _arguments4[2] : {};\n      if (!(yield _this21.doesServerSupportUnstableFeature(UNSTABLE_MSC4140_DELAYED_EVENTS))) {\n        throw new UnsupportedDelayedEventsEndpointError(\"Server does not support the delayed events API\", \"updateDelayedEvent\");\n      }\n      var path = utils.encodeUri(\"/delayed_events/$delayId\", {\n        $delayId: delayId\n      });\n      var data = {\n        action\n      };\n      return yield _this21.http.authedRequest(Method.Post, path, undefined, data, _objectSpread(_objectSpread({}, requestOptions), {}, {\n        prefix: \"\".concat(ClientPrefix.Unstable, \"/\").concat(UNSTABLE_MSC4140_DELAYED_EVENTS)\n      }));\n    })();\n  }\n\n  /**\n   * Send a receipt.\n   * @param event - The event being acknowledged\n   * @param receiptType - The kind of receipt e.g. \"m.read\". Other than\n   * ReceiptType.Read are experimental!\n   * @param body - Additional content to send alongside the receipt.\n   * @param unthreaded - An unthreaded receipt will clear room+thread notifications\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendReceipt(event, receiptType, body) {\n    var _arguments5 = arguments,\n      _this22 = this;\n    return _asyncToGenerator(function* () {\n      var unthreaded = _arguments5.length > 3 && _arguments5[3] !== undefined ? _arguments5[3] : false;\n      if (_this22.isGuest()) {\n        return Promise.resolve({}); // guests cannot send receipts so don't bother.\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/receipt/$receiptType/$eventId\", {\n        $roomId: event.getRoomId(),\n        $receiptType: receiptType,\n        $eventId: event.getId()\n      });\n\n      // Unless we're explicitly making an unthreaded receipt or we don't\n      // support threads, include the `thread_id` property in the body.\n      var shouldAddThreadId = !unthreaded && _this22.supportsThreads();\n      var fullBody = shouldAddThreadId ? _objectSpread(_objectSpread({}, body), {}, {\n        thread_id: threadIdForReceipt(event)\n      }) : body;\n      var promise = _this22.http.authedRequest(Method.Post, path, undefined, fullBody || {});\n      var room = _this22.getRoom(event.getRoomId());\n      if (room && _this22.credentials.userId) {\n        room.addLocalEchoReceipt(_this22.credentials.userId, event, receiptType, unthreaded);\n      }\n      return promise;\n    })();\n  }\n\n  /**\n   * Send a read receipt.\n   * @param event - The event that has been read.\n   * @param receiptType - other than ReceiptType.Read are experimental! Optional.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendReadReceipt(event) {\n    var _arguments6 = arguments,\n      _this23 = this;\n    return _asyncToGenerator(function* () {\n      var receiptType = _arguments6.length > 1 && _arguments6[1] !== undefined ? _arguments6[1] : ReceiptType.Read;\n      var unthreaded = _arguments6.length > 2 && _arguments6[2] !== undefined ? _arguments6[2] : false;\n      if (!event) return;\n      var eventId = event.getId();\n      var room = _this23.getRoom(event.getRoomId());\n      if (room !== null && room !== void 0 && room.hasPendingEvent(eventId)) {\n        throw new Error(\"Cannot set read receipt to a pending event (\".concat(eventId, \")\"));\n      }\n      return _this23.sendReceipt(event, receiptType, {}, unthreaded);\n    })();\n  }\n\n  /**\n   * Set a marker to indicate the point in a room before which the user has read every\n   * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n   * and displayed as a horizontal line in the timeline that is visually distinct to the\n   * position of the user's own read receipt.\n   * @param roomId - ID of the room that has been read\n   * @param rmEventId - ID of the event that has been read\n   * @param rrEvent - the event tracked by the read receipt. This is here for\n   * convenience because the RR and the RM are commonly updated at the same time as each\n   * other. The local echo of this receipt will be done if set. Optional.\n   * @param rpEvent - the m.read.private read receipt event for when we don't\n   * want other users to see the read receipts. This is experimental. Optional.\n   * @returns Promise which resolves: the empty object, `{}`.\n   */\n  setRoomReadMarkers(roomId, rmEventId, rrEvent, rpEvent) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      var room = _this24.getRoom(roomId);\n      if (room !== null && room !== void 0 && room.hasPendingEvent(rmEventId)) {\n        throw new Error(\"Cannot set read marker to a pending event (\".concat(rmEventId, \")\"));\n      }\n\n      // Add the optional RR update, do local echo like `sendReceipt`\n      var rrEventId;\n      if (rrEvent) {\n        rrEventId = rrEvent.getId();\n        if (room !== null && room !== void 0 && room.hasPendingEvent(rrEventId)) {\n          throw new Error(\"Cannot set read receipt to a pending event (\".concat(rrEventId, \")\"));\n        }\n        room === null || room === void 0 || room.addLocalEchoReceipt(_this24.credentials.userId, rrEvent, ReceiptType.Read);\n      }\n\n      // Add the optional private RR update, do local echo like `sendReceipt`\n      var rpEventId;\n      if (rpEvent) {\n        rpEventId = rpEvent.getId();\n        if (room !== null && room !== void 0 && room.hasPendingEvent(rpEventId)) {\n          throw new Error(\"Cannot set read receipt to a pending event (\".concat(rpEventId, \")\"));\n        }\n        room === null || room === void 0 || room.addLocalEchoReceipt(_this24.credentials.userId, rpEvent, ReceiptType.ReadPrivate);\n      }\n      return yield _this24.setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, rpEventId);\n    })();\n  }\n\n  /**\n   * Get a preview of the given URL as of (roughly) the given point in time,\n   * described as an object with OpenGraph keys and associated values.\n   * Attributes may be synthesized where actual OG metadata is lacking.\n   * Caches results to prevent hammering the server.\n   * @param url - The URL to get preview data for\n   * @param ts - The preferred point in time that the preview should\n   * describe (ms since epoch).  The preview returned will either be the most\n   * recent one preceding this timestamp if available, or failing that the next\n   * most recent available preview.\n   * @returns Promise which resolves: Object of OG metadata.\n   * @returns Rejects: with an error response.\n   * May return synthesized attributes if the URL lacked OG meta.\n   */\n  getUrlPreview(url, ts) {\n    // bucket the timestamp to the nearest minute to prevent excessive spam to the server\n    // Surely 60-second accuracy is enough for anyone.\n    ts = Math.floor(ts / 60000) * 60000;\n    var parsed = new URL(url);\n    parsed.hash = \"\"; // strip the hash as it won't affect the preview\n    url = parsed.toString();\n    var key = ts + \"_\" + url;\n\n    // If there's already a request in flight (or we've handled it), return that instead.\n    if (key in this.urlPreviewCache) {\n      return this.urlPreviewCache[key];\n    }\n    var resp = this.http.authedRequest(Method.Get, \"/preview_url\", {\n      url,\n      ts: ts.toString()\n    }, undefined, {\n      prefix: MediaPrefix.V3,\n      priority: \"low\"\n    });\n    // TODO: Expire the URL preview cache sometimes\n    this.urlPreviewCache[key] = resp;\n    return resp;\n  }\n\n  /**\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  sendTyping(roomId, isTyping, timeoutMs) {\n    if (this.isGuest()) {\n      return Promise.resolve({}); // guests cannot send typing notifications so don't bother.\n    }\n    var path = utils.encodeUri(\"/rooms/$roomId/typing/$userId\", {\n      $roomId: roomId,\n      $userId: this.getUserId()\n    });\n    var data = {\n      typing: isTyping\n    };\n    if (isTyping) {\n      data.timeout = timeoutMs ? timeoutMs : 20000;\n    }\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * Determines the history of room upgrades for a given room, as far as the\n   * client can see. Returns an array of Rooms where the first entry is the\n   * oldest and the last entry is the newest (likely current) room. If the\n   * provided room is not found, this returns an empty list. This works in\n   * both directions, looking for older and newer rooms of the given room.\n   * @param roomId - The room ID to search from\n   * @param verifyLinks - If true, the function will only return rooms\n   * which can be proven to be linked. For example, rooms which have a create\n   * event pointing to an old room which the client is not aware of or doesn't\n   * have a matching tombstone would not be returned.\n   * @param msc3946ProcessDynamicPredecessor - if true, look for\n   * m.room.predecessor state events as well as create events, and prefer\n   * predecessor events where they exist (MSC3946).\n   * @returns An array of rooms representing the upgrade\n   * history.\n   */\n  getRoomUpgradeHistory(roomId) {\n    var verifyLinks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    var msc3946ProcessDynamicPredecessor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    var currentRoom = this.getRoom(roomId);\n    if (!currentRoom) return [];\n    var before = this.findPredecessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n    var after = this.findSuccessorRooms(currentRoom, verifyLinks, msc3946ProcessDynamicPredecessor);\n    return [...before, currentRoom, ...after];\n  }\n  findPredecessorRooms(room, verifyLinks, msc3946ProcessDynamicPredecessor) {\n    var _room$findPredecessor;\n    var ret = [];\n    var seenRoomIDs = new Set([room.roomId]);\n\n    // Work backwards from newer to older rooms\n    var predecessorRoomId = (_room$findPredecessor = room.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _room$findPredecessor === void 0 ? void 0 : _room$findPredecessor.roomId;\n    while (predecessorRoomId !== null) {\n      var _room$findPredecessor2;\n      if (predecessorRoomId) {\n        if (seenRoomIDs.has(predecessorRoomId)) break;\n        seenRoomIDs.add(predecessorRoomId);\n      }\n      var predecessorRoom = this.getRoom(predecessorRoomId);\n      if (predecessorRoom === null) {\n        break;\n      }\n      if (verifyLinks) {\n        var tombstone = predecessorRoom.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n        if (!tombstone || tombstone.getContent()[\"replacement_room\"] !== room.roomId) {\n          break;\n        }\n      }\n\n      // Insert at the front because we're working backwards from the currentRoom\n      ret.splice(0, 0, predecessorRoom);\n      room = predecessorRoom;\n      predecessorRoomId = (_room$findPredecessor2 = room.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _room$findPredecessor2 === void 0 ? void 0 : _room$findPredecessor2.roomId;\n    }\n    return ret;\n  }\n  findSuccessorRooms(room, verifyLinks, msc3946ProcessDynamicPredecessor) {\n    var ret = [];\n\n    // Work forwards, looking at tombstone events\n    var tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n    while (tombstoneEvent) {\n      var successorRoom = this.getRoom(tombstoneEvent.getContent()[\"replacement_room\"]);\n      if (!successorRoom) break; // end of the chain\n      if (successorRoom.roomId === room.roomId) break; // Tombstone is referencing its own room\n\n      if (verifyLinks) {\n        var _successorRoom$findPr;\n        var predecessorRoomId = (_successorRoom$findPr = successorRoom.findPredecessor(msc3946ProcessDynamicPredecessor)) === null || _successorRoom$findPr === void 0 ? void 0 : _successorRoom$findPr.roomId;\n        if (!predecessorRoomId || predecessorRoomId !== room.roomId) {\n          break;\n        }\n      }\n\n      // Push to the end because we're looking forwards\n      ret.push(successorRoom);\n      var roomIds = new Set(ret.map(ref => ref.roomId));\n      if (roomIds.size < ret.length) {\n        // The last room added to the list introduced a previous roomId\n        // To avoid recursion, return the last rooms - 1\n        return ret.slice(0, ret.length - 1);\n      }\n\n      // Set the current room to the reference room so we know where we're at\n      room = successorRoom;\n      tombstoneEvent = room.currentState.getStateEvents(EventType.RoomTombstone, \"\");\n    }\n    return ret;\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  invite(roomId, userId, reason) {\n    return this.membershipChange(roomId, userId, KnownMembership.Invite, reason);\n  }\n\n  /**\n   * Invite a user to a room based on their email address.\n   * @param roomId - The room to invite the user to.\n   * @param email - The email address to invite.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  inviteByEmail(roomId, email) {\n    return this.inviteByThreePid(roomId, \"email\", email);\n  }\n\n  /**\n   * Invite a user to a room based on a third-party identifier.\n   * @param roomId - The room to invite the user to.\n   * @param medium - The medium to invite the user e.g. \"email\".\n   * @param address - The address for the specified medium.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  inviteByThreePid(roomId, medium, address) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      var _this25$identityServe;\n      var path = utils.encodeUri(\"/rooms/$roomId/invite\", {\n        $roomId: roomId\n      });\n      var identityServerUrl = _this25.getIdentityServerUrl(true);\n      if (!identityServerUrl) {\n        return Promise.reject(new MatrixError({\n          error: \"No supplied identity server URL\",\n          errcode: \"ORG.MATRIX.JSSDK_MISSING_PARAM\"\n        }));\n      }\n      var params = {\n        id_server: identityServerUrl,\n        medium: medium,\n        address: address\n      };\n      if ((_this25$identityServe = _this25.identityServer) !== null && _this25$identityServe !== void 0 && _this25$identityServe.getAccessToken) {\n        var identityAccessToken = yield _this25.identityServer.getAccessToken();\n        if (identityAccessToken) {\n          params[\"id_access_token\"] = identityAccessToken;\n        }\n      }\n      return _this25.http.authedRequest(Method.Post, path, undefined, params);\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  leave(roomId) {\n    return this.membershipChange(roomId, undefined, KnownMembership.Leave);\n  }\n\n  /**\n   * Leaves all rooms in the chain of room upgrades based on the given room. By\n   * default, this will leave all the previous and upgraded rooms, including the\n   * given room. To only leave the given room and any previous rooms, keeping the\n   * upgraded (modern) rooms untouched supply `false` to `includeFuture`.\n   * @param roomId - The room ID to start leaving at\n   * @param includeFuture - If true, the whole chain (past and future) of\n   * upgraded rooms will be left.\n   * @returns Promise which resolves when completed with an object keyed\n   * by room ID and value of the error encountered when leaving or null.\n   */\n  leaveRoomChain(roomId) {\n    var includeFuture = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    var upgradeHistory = this.getRoomUpgradeHistory(roomId);\n    var eligibleToLeave = upgradeHistory;\n    if (!includeFuture) {\n      eligibleToLeave = [];\n      for (var _room2 of upgradeHistory) {\n        eligibleToLeave.push(_room2);\n        if (_room2.roomId === roomId) {\n          break;\n        }\n      }\n    }\n    var populationResults = {};\n    var promises = [];\n    var doLeave = roomId => {\n      return this.leave(roomId).then(() => {\n        delete populationResults[roomId];\n      }).catch(err => {\n        // suppress error\n        populationResults[roomId] = err;\n      });\n    };\n    for (var _room3 of eligibleToLeave) {\n      promises.push(doLeave(_room3.roomId));\n    }\n    return Promise.all(promises).then(() => populationResults);\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  ban(roomId, userId, reason) {\n    return this.membershipChange(roomId, userId, KnownMembership.Ban, reason);\n  }\n\n  /**\n   * @param deleteRoom - True to delete the room from the store on success.\n   * Default: true.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  forget(roomId) {\n    var _arguments7 = arguments,\n      _this26 = this;\n    return _asyncToGenerator(function* () {\n      var deleteRoom = _arguments7.length > 1 && _arguments7[1] !== undefined ? _arguments7[1] : true;\n      // API returns an empty object\n      var path = utils.encodeUri(\"/rooms/$room_id/forget\", {\n        $room_id: roomId\n      });\n      var response = yield _this26.http.authedRequest(Method.Post, path);\n      if (deleteRoom) {\n        _this26.store.removeRoom(roomId);\n        _this26.emit(ClientEvent.DeleteRoom, roomId);\n      }\n      return response;\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: Object (currently empty)\n   * @returns Rejects: with an error response.\n   */\n  unban(roomId, userId) {\n    // unbanning != set their state to leave: this used to be\n    // the case, but was then changed so that leaving was always\n    // a revoking of privilege, otherwise two people racing to\n    // kick / ban someone could end up banning and then un-banning\n    // them.\n    var path = utils.encodeUri(\"/rooms/$roomId/unban\", {\n      $roomId: roomId\n    });\n    var data = {\n      user_id: userId\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n\n  /**\n   * @param reason - Optional.\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  kick(roomId, userId, reason) {\n    var path = utils.encodeUri(\"/rooms/$roomId/kick\", {\n      $roomId: roomId\n    });\n    var data = {\n      user_id: userId,\n      reason: reason\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n  membershipChange(roomId, userId, membership, reason) {\n    // API returns an empty object\n    var path = utils.encodeUri(\"/rooms/$room_id/$membership\", {\n      $room_id: roomId,\n      $membership: membership\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      user_id: userId,\n      // may be undefined e.g. on leave\n      reason: reason\n    });\n  }\n\n  /**\n   * Obtain a dict of actions which should be performed for this event according\n   * to the push rules for this user.  Caches the dict on the event.\n   * @param event - The event to get push actions for.\n   * @param forceRecalculate - forces to recalculate actions for an event\n   * Useful when an event just got decrypted\n   * @returns A dict of actions to perform.\n   */\n  getPushActionsForEvent(event) {\n    var forceRecalculate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!event.getPushActions() || forceRecalculate) {\n      var {\n        actions,\n        rule\n      } = this.pushProcessor.actionsAndRuleForEvent(event);\n      event.setPushDetails(actions, rule);\n    }\n    return event.getPushActions();\n  }\n\n  /**\n   * Obtain a dict of actions which should be performed for this event according\n   * to the push rules for this user.  Caches the dict on the event.\n   * @param event - The event to get push actions for.\n   * @param forceRecalculate - forces to recalculate actions for an event\n   * Useful when an event just got decrypted\n   * @returns A dict of actions to perform.\n   */\n  getPushDetailsForEvent(event) {\n    var forceRecalculate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!event.getPushDetails() || forceRecalculate) {\n      var {\n        actions,\n        rule\n      } = this.pushProcessor.actionsAndRuleForEvent(event);\n      event.setPushDetails(actions, rule);\n    }\n    return event.getPushDetails();\n  }\n\n  /**\n   * @param info - The kind of info to set (e.g. 'avatar_url')\n   * @param data - The JSON object to set.\n   * @returns\n   * @returns Rejects: with an error response.\n   */\n  // eslint-disable-next-line camelcase\n\n  setProfileInfo(info, data) {\n    var path = utils.encodeUri(\"/profile/$userId/$info\", {\n      $userId: this.credentials.userId,\n      $info: info\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  setDisplayName(name) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      var prom = yield _this27.setProfileInfo(\"displayname\", {\n        displayname: name\n      });\n      // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n      var user = _this27.getUser(_this27.getUserId());\n      if (user) {\n        user.displayName = name;\n        user.emit(UserEvent.DisplayName, user.events.presence, user);\n      }\n      return prom;\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: `{}` an empty object.\n   * @returns Rejects: with an error response.\n   */\n  setAvatarUrl(url) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      var prom = yield _this28.setProfileInfo(\"avatar_url\", {\n        avatar_url: url\n      });\n      // XXX: synthesise a profile update for ourselves because Synapse is broken and won't\n      var user = _this28.getUser(_this28.getUserId());\n      if (user) {\n        user.avatarUrl = url;\n        user.emit(UserEvent.AvatarUrl, user.events.presence, user);\n      }\n      return prom;\n    })();\n  }\n\n  /**\n   * Turn an MXC URL into an HTTP one. <strong>This method is experimental and\n   * may change.</strong>\n   * @param mxcUrl - The MXC URL\n   * @param width - The desired width of the thumbnail.\n   * @param height - The desired height of the thumbnail.\n   * @param resizeMethod - The thumbnail resize method to use, either\n   * \"crop\" or \"scale\".\n   * @param allowDirectLinks - If true, return any non-mxc URLs\n   * directly. Fetching such URLs will leak information about the user to\n   * anyone they share a room with. If false, will return null for such URLs.\n   * @param allowRedirects - If true, the caller supports the URL being 307 or\n   * 308 redirected to another resource upon request. If false, redirects\n   * are not expected. Implied `true` when `useAuthentication` is `true`.\n   * @param useAuthentication - If true, the caller supports authenticated\n   * media and wants an authentication-required URL. Note that server support\n   * for authenticated media will *not* be checked - it is the caller's responsibility\n   * to do so before calling this function. Note also that `useAuthentication`\n   * implies `allowRedirects`. Defaults to false (unauthenticated endpoints).\n   * @returns the avatar URL or null.\n   */\n  mxcUrlToHttp(mxcUrl, width, height, resizeMethod, allowDirectLinks, allowRedirects, useAuthentication) {\n    return getHttpUriForMxc(this.baseUrl, mxcUrl, width, height, resizeMethod, allowDirectLinks, allowRedirects, useAuthentication);\n  }\n\n  /**\n   * Specify the set_presence value to be used for subsequent calls to the Sync API.\n   * This has an advantage over calls to the PUT /presence API in that it\n   * doesn't clobber status_msg set by other devices.\n   * @param presence - the presence to specify to set_presence of sync calls\n   */\n  setSyncPresence(presence) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      var _this29$syncApi;\n      (_this29$syncApi = _this29.syncApi) === null || _this29$syncApi === void 0 || _this29$syncApi.setPresence(presence);\n    })();\n  }\n\n  /**\n   * @param opts - Options to apply\n   * @returns Promise which resolves\n   * @returns Rejects: with an error response.\n   * @throws If 'presence' isn't a valid presence enum value.\n   */\n  setPresence(opts) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/presence/$userId/status\", {\n        $userId: _this30.credentials.userId\n      });\n      var validStates = [\"offline\", \"online\", \"unavailable\"];\n      if (validStates.indexOf(opts.presence) === -1) {\n        throw new Error(\"Bad presence value: \" + opts.presence);\n      }\n      yield _this30.http.authedRequest(Method.Put, path, undefined, opts);\n    })();\n  }\n\n  /**\n   * @param userId - The user to get presence for\n   * @returns Promise which resolves: The presence state for this user.\n   * @returns Rejects: with an error response.\n   */\n  getPresence(userId) {\n    var path = utils.encodeUri(\"/presence/$userId/status\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Retrieve older messages from the given room and put them in the timeline.\n   *\n   * If this is called multiple times whilst a request is ongoing, the <i>same</i>\n   * Promise will be returned. If there was a problem requesting scrollback, there\n   * will be a small delay before another request can be made (to prevent tight-looping\n   * when there is no connection).\n   *\n   * @param room - The room to get older messages in.\n   * @param limit - Optional. The maximum number of previous events to\n   * pull in. Default: 30.\n   * @returns Promise which resolves: Room. If you are at the beginning\n   * of the timeline, `Room.oldState.paginationToken` will be\n   * `null`.\n   * @returns Rejects: with an error response.\n   */\n  scrollback(room) {\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30;\n    var timeToWaitMs = 0;\n    var info = this.ongoingScrollbacks[room.roomId] || {};\n    if (info.promise) {\n      return info.promise;\n    } else if (info.errorTs) {\n      var timeWaitedMs = Date.now() - info.errorTs;\n      timeToWaitMs = Math.max(SCROLLBACK_DELAY_MS - timeWaitedMs, 0);\n    }\n    if (room.oldState.paginationToken === null) {\n      return Promise.resolve(room); // already at the start.\n    }\n    // attempt to grab more events from the store first\n    var numAdded = this.store.scrollback(room, limit).length;\n    if (numAdded === limit) {\n      // store contained everything we needed.\n      return Promise.resolve(room);\n    }\n    // reduce the required number of events appropriately\n    limit = limit - numAdded;\n    var promise = new Promise((resolve, reject) => {\n      // wait for a time before doing this request\n      // (which may be 0 in order not to special case the code paths)\n      sleep(timeToWaitMs).then(() => {\n        return this.createMessagesRequest(room.roomId, room.oldState.paginationToken, limit, Direction.Backward);\n      }).then(res => {\n        var _res$end, _res$end2;\n        var matrixEvents = res.chunk.map(this.getEventMapper());\n        if (res.state) {\n          var stateEvents = res.state.map(this.getEventMapper());\n          room.currentState.setUnknownStateEvents(stateEvents);\n        }\n        var [timelineEvents, threadedEvents, unknownRelations] = room.partitionThreadedEvents(matrixEvents);\n        this.processAggregatedTimelineEvents(room, timelineEvents);\n        room.addEventsToTimeline(timelineEvents, true, true, room.getLiveTimeline());\n        this.processThreadEvents(room, threadedEvents, true);\n        unknownRelations.forEach(event => room.relations.aggregateChildEvent(event));\n        room.oldState.paginationToken = (_res$end = res.end) !== null && _res$end !== void 0 ? _res$end : null;\n        if (res.chunk.length === 0) {\n          room.oldState.paginationToken = null;\n        }\n        this.store.storeEvents(room, matrixEvents, (_res$end2 = res.end) !== null && _res$end2 !== void 0 ? _res$end2 : null, true);\n        delete this.ongoingScrollbacks[room.roomId];\n        resolve(room);\n      }).catch(err => {\n        this.ongoingScrollbacks[room.roomId] = {\n          errorTs: Date.now()\n        };\n        reject(err);\n      });\n    });\n    info = {\n      promise\n    };\n    this.ongoingScrollbacks[room.roomId] = info;\n    return promise;\n  }\n  getEventMapper(options) {\n    return eventMapperFor(this, options || {});\n  }\n\n  /**\n   * Get an EventTimeline for the given event\n   *\n   * <p>If the EventTimelineSet object already has the given event in its store, the\n   * corresponding timeline will be returned. Otherwise, a /context request is\n   * made, and used to construct an EventTimeline.\n   * If the event does not belong to this EventTimelineSet then undefined will be returned.\n   *\n   * @param timelineSet -  The timelineSet to look for the event in, must be bound to a room\n   * @param eventId -  The ID of the event to look for\n   *\n   * @returns Promise which resolves:\n   *    {@link EventTimeline} including the given event\n   */\n  getEventTimeline(timelineSet, eventId) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      var _this31$clientOpts, _ref3, _timelineSet$getTimel, _timelineSet$room$fin;\n      // don't allow any timeline support unless it's been enabled.\n      if (!_this31.timelineSupport) {\n        throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable it.\");\n      }\n      if (!(timelineSet !== null && timelineSet !== void 0 && timelineSet.room)) {\n        throw new Error(\"getEventTimeline only supports room timelines\");\n      }\n      if (timelineSet.getTimelineForEvent(eventId)) {\n        return timelineSet.getTimelineForEvent(eventId);\n      }\n      if (timelineSet.thread && _this31.supportsThreads()) {\n        return _this31.getThreadTimeline(timelineSet, eventId);\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/context/$eventId\", {\n        $roomId: timelineSet.room.roomId,\n        $eventId: eventId\n      });\n      var params = undefined;\n      if ((_this31$clientOpts = _this31.clientOpts) !== null && _this31$clientOpts !== void 0 && _this31$clientOpts.lazyLoadMembers) {\n        params = {\n          filter: JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER)\n        };\n      }\n\n      // TODO: we should implement a backoff (as per scrollback()) to deal more nicely with HTTP errors.\n      var res = yield _this31.http.authedRequest(Method.Get, path, params);\n      if (!res.event) {\n        throw new Error(\"'event' not in '/context' result - homeserver too old?\");\n      }\n\n      // by the time the request completes, the event might have ended up in the timeline.\n      if (timelineSet.getTimelineForEvent(eventId)) {\n        return timelineSet.getTimelineForEvent(eventId);\n      }\n      var mapper = _this31.getEventMapper();\n      var event = mapper(res.event);\n      if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n        _this31.logger.warn(\"Tried loading a regular timeline at the position of a thread event\");\n        return undefined;\n      }\n      var events = [\n      // Order events from most recent to oldest (reverse-chronological).\n      // We start with the last event, since that's the point at which we have known state.\n      // events_after is already backwards; events_before is forwards.\n      ...res.events_after.reverse().map(mapper), event, ...res.events_before.map(mapper)];\n\n      // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n      var timeline = timelineSet.getTimelineForEvent(events[0].getId());\n      if (timeline) {\n        timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n      } else {\n        timeline = timelineSet.addTimeline();\n        timeline.initialiseState(res.state.map(mapper));\n        timeline.getState(EventTimeline.FORWARDS).paginationToken = res.end;\n      }\n      var [timelineEvents, threadedEvents, unknownRelations] = timelineSet.room.partitionThreadedEvents(events);\n      timelineSet.addEventsToTimeline(timelineEvents, true, false, timeline, res.start);\n      // The target event is not in a thread but process the contextual events, so we can show any threads around it.\n      _this31.processThreadEvents(timelineSet.room, threadedEvents, true);\n      _this31.processAggregatedTimelineEvents(timelineSet.room, timelineEvents);\n      unknownRelations.forEach(event => timelineSet.relations.aggregateChildEvent(event));\n\n      // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n      // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n      // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n      return (_ref3 = (_timelineSet$getTimel = timelineSet.getTimelineForEvent(eventId)) !== null && _timelineSet$getTimel !== void 0 ? _timelineSet$getTimel : (_timelineSet$room$fin = timelineSet.room.findThreadForEvent(event)) === null || _timelineSet$room$fin === void 0 ? void 0 : _timelineSet$room$fin.liveTimeline) !== null && _ref3 !== void 0 ? _ref3 :\n      // for Threads degraded support\n      timeline;\n    })();\n  }\n  getThreadTimeline(timelineSet, eventId) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      var _this32$clientOpts;\n      if (!_this32.supportsThreads()) {\n        throw new Error(\"could not get thread timeline: no client support\");\n      }\n      if (!timelineSet.room) {\n        throw new Error(\"could not get thread timeline: not a room timeline\");\n      }\n      if (!timelineSet.thread) {\n        throw new Error(\"could not get thread timeline: not a thread timeline\");\n      }\n      var path = utils.encodeUri(\"/rooms/$roomId/context/$eventId\", {\n        $roomId: timelineSet.room.roomId,\n        $eventId: eventId\n      });\n      var params = {\n        limit: \"0\"\n      };\n      if ((_this32$clientOpts = _this32.clientOpts) !== null && _this32$clientOpts !== void 0 && _this32$clientOpts.lazyLoadMembers) {\n        params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n      }\n\n      // TODO: we should implement a backoff (as per scrollback()) to deal more nicely with HTTP errors.\n      var res = yield _this32.http.authedRequest(Method.Get, path, params);\n      var mapper = _this32.getEventMapper();\n      var event = mapper(res.event);\n      if (!timelineSet.canContain(event)) {\n        return undefined;\n      }\n      var recurse = _this32.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n      if (Thread.hasServerSideSupport) {\n        if (Thread.hasServerSideFwdPaginationSupport) {\n          var _resOlder$next_batch, _resNewer$next_batch, _timelineSet$getTimel2;\n          if (!timelineSet.thread) {\n            throw new Error(\"could not get thread timeline: not a thread timeline\");\n          }\n          var thread = timelineSet.thread;\n          var resOlder = yield _this32.fetchRelations(timelineSet.room.roomId, thread.id, null, null, {\n            dir: Direction.Backward,\n            from: res.start,\n            recurse: recurse || undefined\n          });\n          var resNewer = yield _this32.fetchRelations(timelineSet.room.roomId, thread.id, null, null, {\n            dir: Direction.Forward,\n            from: res.end,\n            recurse: recurse || undefined\n          });\n          var events = [\n          // Order events from most recent to oldest (reverse-chronological).\n          // We start with the last event, since that's the point at which we have known state.\n          // events_after is already backwards; events_before is forwards.\n          ...resNewer.chunk.reverse().filter(getRelationsThreadFilter(thread.id)).map(mapper), event, ...resOlder.chunk.filter(getRelationsThreadFilter(thread.id)).map(mapper)];\n          for (var _event2 of events) {\n            var _timelineSet$thread;\n            yield (_timelineSet$thread = timelineSet.thread) === null || _timelineSet$thread === void 0 ? void 0 : _timelineSet$thread.processEvent(_event2);\n          }\n\n          // Here we handle non-thread timelines only, but still process any thread events to populate thread summaries.\n          var timeline = timelineSet.getTimelineForEvent(event.getId());\n          if (timeline) {\n            timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n          } else {\n            timeline = timelineSet.addTimeline();\n            timeline.initialiseState(res.state.map(mapper));\n          }\n          timelineSet.addEventsToTimeline(events, true, false, timeline, resNewer.next_batch);\n          if (!resOlder.next_batch) {\n            var originalEvent = yield _this32.fetchRoomEvent(timelineSet.room.roomId, thread.id);\n            timelineSet.addEventsToTimeline([mapper(originalEvent)], true, false, timeline, null);\n          }\n          timeline.setPaginationToken((_resOlder$next_batch = resOlder.next_batch) !== null && _resOlder$next_batch !== void 0 ? _resOlder$next_batch : null, Direction.Backward);\n          timeline.setPaginationToken((_resNewer$next_batch = resNewer.next_batch) !== null && _resNewer$next_batch !== void 0 ? _resNewer$next_batch : null, Direction.Forward);\n          _this32.processAggregatedTimelineEvents(timelineSet.room, events);\n\n          // There is no guarantee that the event ended up in \"timeline\" (we might have switched to a neighbouring\n          // timeline) - so check the room's index again. On the other hand, there's no guarantee the event ended up\n          // anywhere, if it was later redacted, so we just return the timeline we first thought of.\n          return (_timelineSet$getTimel2 = timelineSet.getTimelineForEvent(eventId)) !== null && _timelineSet$getTimel2 !== void 0 ? _timelineSet$getTimel2 : timeline;\n        } else {\n          var _resOlder$next_batch2;\n          // Where the event is a thread reply (not a root) and running in MSC-enabled mode the Thread timeline only\n          // functions contiguously, so we have to jump through some hoops to get our target event in it.\n          // XXX: workaround for https://github.com/vector-im/element-meta/issues/150\n\n          var _thread = timelineSet.thread;\n          var _resOlder = yield _this32.fetchRelations(timelineSet.room.roomId, _thread.id, THREAD_RELATION_TYPE.name, null, {\n            dir: Direction.Backward,\n            from: res.start,\n            recurse: recurse || undefined\n          });\n          var eventsNewer = [];\n          var nextBatch = res.end;\n          while (nextBatch) {\n            var _resNewer$next_batch2;\n            var _resNewer = yield _this32.fetchRelations(timelineSet.room.roomId, _thread.id, THREAD_RELATION_TYPE.name, null, {\n              dir: Direction.Forward,\n              from: nextBatch,\n              recurse: recurse || undefined\n            });\n            nextBatch = (_resNewer$next_batch2 = _resNewer.next_batch) !== null && _resNewer$next_batch2 !== void 0 ? _resNewer$next_batch2 : null;\n            eventsNewer.push(..._resNewer.chunk);\n          }\n          var _events = [\n          // Order events from most recent to oldest (reverse-chronological).\n          // We start with the last event, since that's the point at which we have known state.\n          // events_after is already backwards; events_before is forwards.\n          ...eventsNewer.reverse().map(mapper), event, ..._resOlder.chunk.map(mapper)];\n          for (var _event3 of _events) {\n            var _timelineSet$thread2;\n            yield (_timelineSet$thread2 = timelineSet.thread) === null || _timelineSet$thread2 === void 0 ? void 0 : _timelineSet$thread2.processEvent(_event3);\n          }\n\n          // Here we handle non-thread timelines only, but still process any thread events to populate thread\n          // summaries.\n          var _timeline = timelineSet.getLiveTimeline();\n          _timeline.getState(EventTimeline.BACKWARDS).setUnknownStateEvents(res.state.map(mapper));\n          timelineSet.addEventsToTimeline(_events, true, false, _timeline, null);\n          if (!_resOlder.next_batch) {\n            var _originalEvent = yield _this32.fetchRoomEvent(timelineSet.room.roomId, _thread.id);\n            timelineSet.addEventsToTimeline([mapper(_originalEvent)], true, false, _timeline, null);\n          }\n          _timeline.setPaginationToken((_resOlder$next_batch2 = _resOlder.next_batch) !== null && _resOlder$next_batch2 !== void 0 ? _resOlder$next_batch2 : null, Direction.Backward);\n          _timeline.setPaginationToken(null, Direction.Forward);\n          _this32.processAggregatedTimelineEvents(timelineSet.room, _events);\n          return _timeline;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Get an EventTimeline for the latest events in the room. This will just\n   * call `/messages` to get the latest message in the room, then use\n   * `client.getEventTimeline(...)` to construct a new timeline from it.\n   *\n   * @param timelineSet -  The timelineSet to find or add the timeline to\n   *\n   * @returns Promise which resolves:\n   *    {@link EventTimeline} timeline with the latest events in the room\n   */\n  getLatestTimeline(timelineSet) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      // don't allow any timeline support unless it's been enabled.\n      if (!_this33.timelineSupport) {\n        throw new Error(\"timeline support is disabled. Set the 'timelineSupport'\" + \" parameter to true when creating MatrixClient to enable it.\");\n      }\n      if (!timelineSet.room) {\n        throw new Error(\"getLatestTimeline only supports room timelines\");\n      }\n      var event;\n      if (timelineSet.threadListType !== null) {\n        var _res$chunk;\n        var res = yield _this33.createThreadListMessagesRequest(timelineSet.room.roomId, null, 1, Direction.Backward, timelineSet.threadListType, timelineSet.getFilter());\n        event = (_res$chunk = res.chunk) === null || _res$chunk === void 0 ? void 0 : _res$chunk[0];\n      } else if (timelineSet.thread && Thread.hasServerSideSupport) {\n        var _res$chunk2;\n        var recurse = _this33.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n        var _res = yield _this33.fetchRelations(timelineSet.room.roomId, timelineSet.thread.id, THREAD_RELATION_TYPE.name, null, {\n          dir: Direction.Backward,\n          limit: 1,\n          recurse: recurse || undefined\n        });\n        event = (_res$chunk2 = _res.chunk) === null || _res$chunk2 === void 0 ? void 0 : _res$chunk2[0];\n      } else {\n        var _this33$clientOpts, _res2$chunk;\n        var messagesPath = utils.encodeUri(\"/rooms/$roomId/messages\", {\n          $roomId: timelineSet.room.roomId\n        });\n        var params = {\n          dir: \"b\"\n        };\n        if ((_this33$clientOpts = _this33.clientOpts) !== null && _this33$clientOpts !== void 0 && _this33$clientOpts.lazyLoadMembers) {\n          params.filter = JSON.stringify(Filter.LAZY_LOADING_MESSAGES_FILTER);\n        }\n        var _res2 = yield _this33.http.authedRequest(Method.Get, messagesPath, params);\n        event = (_res2$chunk = _res2.chunk) === null || _res2$chunk === void 0 ? void 0 : _res2$chunk[0];\n      }\n      if (!event) {\n        throw new Error(\"No message returned when trying to construct getLatestTimeline\");\n      }\n      return _this33.getEventTimeline(timelineSet, event.event_id);\n    })();\n  }\n\n  /**\n   * Makes a request to /messages with the appropriate lazy loading filter set.\n   * XXX: if we do get rid of scrollback (as it's not used at the moment),\n   * we could inline this method again in paginateEventTimeline as that would\n   * then be the only call-site\n   * @param limit - the maximum amount of events the retrieve\n   * @param dir - 'f' or 'b'\n   * @param timelineFilter - the timeline filter to pass\n   */\n  // XXX: Intended private, used in code.\n  createMessagesRequest(roomId, fromToken) {\n    var _this$clientOpts;\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;\n    var dir = arguments.length > 3 ? arguments[3] : undefined;\n    var timelineFilter = arguments.length > 4 ? arguments[4] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/messages\", {\n      $roomId: roomId\n    });\n    var params = {\n      limit: limit.toString(),\n      dir: dir\n    };\n    if (fromToken) {\n      params.from = fromToken;\n    }\n    var filter = null;\n    if ((_this$clientOpts = this.clientOpts) !== null && _this$clientOpts !== void 0 && _this$clientOpts.lazyLoadMembers) {\n      // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n      // so the timelineFilter doesn't get written into it below\n      filter = Object.assign({}, Filter.LAZY_LOADING_MESSAGES_FILTER);\n    }\n    if (timelineFilter) {\n      var _timelineFilter$getRo;\n      // XXX: it's horrific that /messages' filter parameter doesn't match\n      // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n      filter = filter || {};\n      Object.assign(filter, (_timelineFilter$getRo = timelineFilter.getRoomTimelineFilterComponent()) === null || _timelineFilter$getRo === void 0 ? void 0 : _timelineFilter$getRo.toJSON());\n    }\n    if (filter) {\n      params.filter = JSON.stringify(filter);\n    }\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n\n  /**\n   * Makes a request to /messages with the appropriate lazy loading filter set.\n   * XXX: if we do get rid of scrollback (as it's not used at the moment),\n   * we could inline this method again in paginateEventTimeline as that would\n   * then be the only call-site\n   * @param limit - the maximum amount of events the retrieve\n   * @param dir - 'f' or 'b'\n   * @param timelineFilter - the timeline filter to pass\n   */\n  // XXX: Intended private, used by room.fetchRoomThreads\n  createThreadListMessagesRequest(roomId, fromToken) {\n    var _this$clientOpts2;\n    var limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;\n    var dir = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Direction.Backward;\n    var threadListType = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : ThreadFilterType.All;\n    var timelineFilter = arguments.length > 5 ? arguments[5] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/threads\", {\n      $roomId: roomId\n    });\n    var params = {\n      limit: limit.toString(),\n      dir: dir,\n      include: threadFilterTypeToFilter(threadListType)\n    };\n    if (fromToken) {\n      params.from = fromToken;\n    }\n    var filter = {};\n    if ((_this$clientOpts2 = this.clientOpts) !== null && _this$clientOpts2 !== void 0 && _this$clientOpts2.lazyLoadMembers) {\n      // create a shallow copy of LAZY_LOADING_MESSAGES_FILTER,\n      // so the timelineFilter doesn't get written into it below\n      filter = _objectSpread({}, Filter.LAZY_LOADING_MESSAGES_FILTER);\n    }\n    if (timelineFilter) {\n      var _timelineFilter$getRo2;\n      // XXX: it's horrific that /messages' filter parameter doesn't match\n      // /sync's one - see https://matrix.org/jira/browse/SPEC-451\n      filter = _objectSpread(_objectSpread({}, filter), (_timelineFilter$getRo2 = timelineFilter.getRoomTimelineFilterComponent()) === null || _timelineFilter$getRo2 === void 0 ? void 0 : _timelineFilter$getRo2.toJSON());\n    }\n    if (Object.keys(filter).length) {\n      params.filter = JSON.stringify(filter);\n    }\n    var opts = {\n      prefix: Thread.hasServerSideListSupport === FeatureSupport.Stable ? ClientPrefix.V1 : \"/_matrix/client/unstable/org.matrix.msc3856\"\n    };\n    return this.http.authedRequest(Method.Get, path, params, undefined, opts).then(res => {\n      var _res$chunk3;\n      return _objectSpread(_objectSpread({}, res), {}, {\n        chunk: (_res$chunk3 = res.chunk) === null || _res$chunk3 === void 0 ? void 0 : _res$chunk3.reverse(),\n        start: res.prev_batch,\n        end: res.next_batch\n      });\n    });\n  }\n\n  /**\n   * Take an EventTimeline, and back/forward-fill results.\n   *\n   * @param eventTimeline - timeline object to be updated\n   *\n   * @returns Promise which resolves to a boolean: false if there are no\n   *    events and we reached either end of the timeline; else true.\n   */\n  paginateEventTimeline(eventTimeline, opts) {\n    var _this34 = this;\n    var isNotifTimeline = eventTimeline.getTimelineSet() === this.notifTimelineSet;\n    var room = this.getRoom(eventTimeline.getRoomId());\n    var threadListType = eventTimeline.getTimelineSet().threadListType;\n    var thread = eventTimeline.getTimelineSet().thread;\n\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n    opts = opts || {};\n    var backwards = opts.backwards || false;\n    if (isNotifTimeline) {\n      if (!backwards) {\n        throw new Error(\"paginateNotifTimeline can only paginate backwards\");\n      }\n    }\n    var dir = backwards ? EventTimeline.BACKWARDS : EventTimeline.FORWARDS;\n    var token = eventTimeline.getPaginationToken(dir);\n    var pendingRequest = eventTimeline.paginationRequests[dir];\n    if (pendingRequest) {\n      // already a request in progress - return the existing promise\n      return pendingRequest;\n    }\n    var path;\n    var params;\n    var promise;\n    if (isNotifTimeline) {\n      var _opts$limit;\n      path = \"/notifications\";\n      params = {\n        limit: ((_opts$limit = opts.limit) !== null && _opts$limit !== void 0 ? _opts$limit : 30).toString(),\n        only: \"highlight\"\n      };\n      if (token && token !== \"end\") {\n        params.from = token;\n      }\n      promise = this.http.authedRequest(Method.Get, path, params).then(/*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (res) {\n          var token = res.next_token;\n          var matrixEvents = [];\n          res.notifications = res.notifications.filter(noUnsafeEventProps);\n          for (var i = 0; i < res.notifications.length; i++) {\n            var notification = res.notifications[i];\n            var _event4 = _this34.getEventMapper()(notification.event);\n\n            // @TODO(kerrya) reprocessing every notification is ugly\n            // remove if we get server MSC3994 support\n            _this34.getPushDetailsForEvent(_event4, true);\n            _event4.event.room_id = notification.room_id; // XXX: gutwrenching\n            matrixEvents[i] = _event4;\n          }\n\n          // No need to partition events for threads here, everything lives\n          // in the notification timeline set\n          var timelineSet = eventTimeline.getTimelineSet();\n          timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, token);\n          _this34.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n          // if we've hit the end of the timeline, we need to stop trying to\n          // paginate. We need to keep the 'forwards' token though, to make sure\n          // we can recover from gappy syncs.\n          if (backwards && !res.next_token) {\n            eventTimeline.setPaginationToken(null, dir);\n          }\n          return Boolean(res.next_token);\n        });\n        return function (_x2) {\n          return _ref4.apply(this, arguments);\n        };\n      }()).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else if (threadListType !== null) {\n      if (!room) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      if (!Thread.hasServerSideFwdPaginationSupport && dir === Direction.Forward) {\n        throw new Error(\"Cannot paginate threads forwards without server-side support for MSC 3715\");\n      }\n      promise = this.createThreadListMessagesRequest(eventTimeline.getRoomId(), token, opts.limit, dir, threadListType, eventTimeline.getFilter()).then(res => {\n        if (res.state) {\n          var roomState = eventTimeline.getState(dir);\n          var stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n          roomState.setUnknownStateEvents(stateEvents);\n        }\n        var token = res.end;\n        var matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n        var timelineSet = eventTimeline.getTimelineSet();\n        timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, token);\n        this.processAggregatedTimelineEvents(room, matrixEvents);\n        this.processThreadRoots(room, matrixEvents, backwards);\n\n        // if we've hit the end of the timeline, we need to stop trying to\n        // paginate. We need to keep the 'forwards' token though, to make sure\n        // we can recover from gappy syncs.\n        if (backwards && res.end == res.start) {\n          eventTimeline.setPaginationToken(null, dir);\n        }\n        return res.end !== res.start;\n      }).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else if (thread) {\n      var _eventTimeline$getRoo, _eventTimeline$getRoo2;\n      var _room4 = this.getRoom((_eventTimeline$getRoo = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo !== void 0 ? _eventTimeline$getRoo : undefined);\n      if (!_room4) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      var recurse = this.canSupport.get(Feature.RelationsRecursion) !== ServerSupport.Unsupported;\n      promise = this.fetchRelations((_eventTimeline$getRoo2 = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo2 !== void 0 ? _eventTimeline$getRoo2 : \"\", thread.id, null, null, {\n        dir,\n        limit: opts.limit,\n        from: token !== null && token !== void 0 ? token : undefined,\n        recurse: recurse || undefined\n      }).then(/*#__PURE__*/function () {\n        var _ref5 = _asyncToGenerator(function* (res) {\n          var mapper = _this34.getEventMapper();\n          var matrixEvents = res.chunk.filter(noUnsafeEventProps).filter(getRelationsThreadFilter(thread.id)).map(mapper);\n\n          // Process latest events first\n          for (var _event5 of matrixEvents.slice().reverse()) {\n            yield thread === null || thread === void 0 ? void 0 : thread.processEvent(_event5);\n            var sender = _event5.getSender();\n            if (!backwards || (thread === null || thread === void 0 ? void 0 : thread.getEventReadUpTo(sender)) === null) {\n              _room4.addLocalEchoReceipt(sender, _event5, ReceiptType.Read);\n            }\n          }\n          var newToken = res.next_batch;\n          var timelineSet = eventTimeline.getTimelineSet();\n          timelineSet.addEventsToTimeline(matrixEvents, backwards, false, eventTimeline, newToken !== null && newToken !== void 0 ? newToken : null);\n          if (!newToken && backwards) {\n            var _thread$rootEvent, _eventTimeline$getRoo3;\n            var originalEvent = (_thread$rootEvent = thread.rootEvent) !== null && _thread$rootEvent !== void 0 ? _thread$rootEvent : mapper(yield _this34.fetchRoomEvent((_eventTimeline$getRoo3 = eventTimeline.getRoomId()) !== null && _eventTimeline$getRoo3 !== void 0 ? _eventTimeline$getRoo3 : \"\", thread.id));\n            timelineSet.addEventsToTimeline([originalEvent], true, false, eventTimeline, null);\n          }\n          _this34.processAggregatedTimelineEvents(timelineSet.room, matrixEvents);\n\n          // if we've hit the end of the timeline, we need to stop trying to\n          // paginate. We need to keep the 'forwards' token though, to make sure\n          // we can recover from gappy syncs.\n          if (backwards && !newToken) {\n            eventTimeline.setPaginationToken(null, dir);\n          }\n          return Boolean(newToken);\n        });\n        return function (_x3) {\n          return _ref5.apply(this, arguments);\n        };\n      }()).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    } else {\n      if (!room) {\n        throw new Error(\"Unknown room \" + eventTimeline.getRoomId());\n      }\n      promise = this.createMessagesRequest(eventTimeline.getRoomId(), token, opts.limit, dir, eventTimeline.getFilter()).then(res => {\n        if (res.state) {\n          var roomState = eventTimeline.getState(dir);\n          var stateEvents = res.state.filter(noUnsafeEventProps).map(this.getEventMapper());\n          roomState.setUnknownStateEvents(stateEvents);\n        }\n        var token = res.end;\n        var matrixEvents = res.chunk.filter(noUnsafeEventProps).map(this.getEventMapper());\n        var timelineSet = eventTimeline.getTimelineSet();\n        var [timelineEvents,, unknownRelations] = room.partitionThreadedEvents(matrixEvents);\n        timelineSet.addEventsToTimeline(timelineEvents, backwards, false, eventTimeline, token);\n        this.processAggregatedTimelineEvents(room, timelineEvents);\n        this.processThreadRoots(room, timelineEvents.filter(it => it.getServerAggregatedRelation(THREAD_RELATION_TYPE.name)), false);\n        unknownRelations.forEach(event => room.relations.aggregateChildEvent(event));\n        var atEnd = res.end === undefined || res.end === res.start;\n\n        // if we've hit the end of the timeline, we need to stop trying to\n        // paginate. We need to keep the 'forwards' token though, to make sure\n        // we can recover from gappy syncs.\n        if (backwards && atEnd) {\n          eventTimeline.setPaginationToken(null, dir);\n        }\n        return !atEnd;\n      }).finally(() => {\n        eventTimeline.paginationRequests[dir] = null;\n      });\n      eventTimeline.paginationRequests[dir] = promise;\n    }\n    return promise;\n  }\n\n  /**\n   * Reset the notifTimelineSet entirely, paginating in some historical notifs as\n   * a starting point for subsequent pagination.\n   */\n  resetNotifTimelineSet() {\n    if (!this.notifTimelineSet) {\n      return;\n    }\n\n    // FIXME: This thing is a total hack, and results in duplicate events being\n    // added to the timeline both from /sync and /notifications, and lots of\n    // slow and wasteful processing and pagination.  The correct solution is to\n    // extend /messages or /search or something to filter on notifications.\n\n    // use the fictitious token 'end'. in practice we would ideally give it\n    // the oldest backwards pagination token from /sync, but /sync doesn't\n    // know about /notifications, so we have no choice but to start paginating\n    // from the current point in time.  This may well overlap with historical\n    // notifs which are then inserted into the timeline by /sync responses.\n    this.notifTimelineSet.resetLiveTimeline(\"end\");\n\n    // we could try to paginate a single event at this point in order to get\n    // a more valid pagination token, but it just ends up with an out of order\n    // timeline. given what a mess this is and given we're going to have duplicate\n    // events anyway, just leave it with the dummy token for now.\n    /*\n    this.paginateNotifTimeline(this._notifTimelineSet.getLiveTimeline(), {\n        backwards: true,\n        limit: 1\n    });\n    */\n  }\n\n  /**\n   * Peek into a room and receive updates about the room. This only works if the\n   * history visibility for the room is world_readable.\n   * @param roomId - The room to attempt to peek into.\n   * @param limit - The number of timeline events to initially retrieve.\n   * @returns Promise which resolves: Room object\n   * @returns Rejects: with an error response.\n   */\n  peekInRoom(roomId) {\n    var _this$peekSync2;\n    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;\n    (_this$peekSync2 = this.peekSync) === null || _this$peekSync2 === void 0 || _this$peekSync2.stopPeeking();\n    this.peekSync = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n    return this.peekSync.peek(roomId, limit);\n  }\n\n  /**\n   * Stop any ongoing room peeking.\n   */\n  stopPeeking() {\n    if (this.peekSync) {\n      this.peekSync.stopPeeking();\n      this.peekSync = null;\n    }\n  }\n\n  /**\n   * Set r/w flags for guest access in a room.\n   * @param roomId - The room to configure guest access in.\n   * @param opts - Options\n   * @returns Promise which resolves\n   * @returns Rejects: with an error response.\n   */\n  setGuestAccess(roomId, opts) {\n    var writePromise = this.sendStateEvent(roomId, EventType.RoomGuestAccess, {\n      guest_access: opts.allowJoin ? GuestAccess.CanJoin : GuestAccess.Forbidden\n    }, \"\");\n    var readPromise = Promise.resolve();\n    if (opts.allowRead) {\n      readPromise = this.sendStateEvent(roomId, EventType.RoomHistoryVisibility, {\n        history_visibility: HistoryVisibility.WorldReadable\n      }, \"\");\n    }\n    return Promise.all([readPromise, writePromise]).then(); // .then() to hide results for contract\n  }\n\n  /**\n   * Requests an email verification token for the purposes of registration.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   *\n   * Parameters and return value are as for requestEmailToken\n    * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestRegisterEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/register/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of registration.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   *\n   * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in which\n   *    phoneNumber should be parsed relative to.\n   * @param phoneNumber - The phone number, in national or international format\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestRegisterMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/register/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests an email verification token for the purposes of adding a\n   * third party identifier to an account.\n   * This API requests a token from the homeserver.\n   * The doesServerRequireIdServerParam() method can be used to determine if\n   * the server requires the id_server parameter to be provided.\n   * If an account with the given email address already exists and is\n   * associated with an account other than the one the user is authed as,\n   * it will either send an email to the address informing them of this\n   * or return M_THREEPID_IN_USE (which one is up to the homeserver).\n   *\n   * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestAdd3pidEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/3pid/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of adding a\n   * third party identifier to an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the addition of phone numbers to an\n   * account, as requestAdd3pidEmailToken.\n   *\n   * @param phoneCountry - As requestRegisterMsisdnToken\n   * @param phoneNumber - As requestRegisterMsisdnToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestAdd3pidMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/3pid/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests an email verification token for the purposes of resetting\n   * the password on an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the password resetting. Specifically,\n   * if no account with the given email address exists, it may either\n   * return M_THREEPID_NOT_FOUND or send an email\n   * to the address informing them of this (which one is up to the homeserver).\n   *\n   * requestEmailToken calls the equivalent API directly on the identity server,\n   * therefore bypassing the password reset specific logic.\n   *\n   * @param email - As requestEmailToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestPasswordEmailToken(email, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/password/email/requestToken\", {\n      email: email,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Requests a text message verification token for the purposes of resetting\n   * the password on an account.\n   * This API proxies the identity server /validate/email/requestToken API,\n   * adding specific behaviour for the password resetting, as requestPasswordEmailToken.\n   *\n   * @param phoneCountry - As requestRegisterMsisdnToken\n   * @param phoneNumber - As requestRegisterMsisdnToken\n   * @param clientSecret - As requestEmailToken\n   * @param sendAttempt - As requestEmailToken\n   * @param nextLink - As requestEmailToken\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestPasswordMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink) {\n    return this.requestTokenFromEndpoint(\"/account/password/msisdn/requestToken\", {\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      client_secret: clientSecret,\n      send_attempt: sendAttempt,\n      next_link: nextLink\n    });\n  }\n\n  /**\n   * Internal utility function for requesting validation tokens from usage-specific\n   * requestToken endpoints.\n   *\n   * @param endpoint - The endpoint to send the request to\n   * @param params - Parameters for the POST request\n   * @returns Promise which resolves: As requestEmailToken\n   */\n  requestTokenFromEndpoint(endpoint, params) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      var postParams = Object.assign({}, params);\n      return _this35.http.request(Method.Post, endpoint, undefined, postParams);\n    })();\n  }\n\n  /**\n   * Get the room-kind push rule associated with a room.\n   * @param scope - \"global\" or device-specific.\n   * @param roomId - the id of the room.\n   * @returns the rule or undefined.\n   */\n  getRoomPushRule(scope, roomId) {\n    // There can be only room-kind push rule per room\n    // and its id is the room id.\n    if (this.pushRules) {\n      var _this$pushRules$scope;\n      return (_this$pushRules$scope = this.pushRules[scope]) === null || _this$pushRules$scope === void 0 || (_this$pushRules$scope = _this$pushRules$scope.room) === null || _this$pushRules$scope === void 0 ? void 0 : _this$pushRules$scope.find(rule => rule.rule_id === roomId);\n    } else {\n      throw new Error(\"SyncApi.sync() must be done before accessing to push rules.\");\n    }\n  }\n\n  /**\n   * Set a room-kind muting push rule in a room.\n   * The operation also updates MatrixClient.pushRules at the end.\n   * @param scope - \"global\" or device-specific.\n   * @param roomId - the id of the room.\n   * @param mute - the mute state.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  setRoomMutePushRule(scope, roomId, mute) {\n    var promise;\n    var hasDontNotifyRule = false;\n\n    // Get the existing room-kind push rule if any\n    var roomPushRule = this.getRoomPushRule(scope, roomId);\n    if (roomPushRule !== null && roomPushRule !== void 0 && roomPushRule.actions.includes(PushRuleActionName.DontNotify)) {\n      hasDontNotifyRule = true;\n    }\n    if (!mute) {\n      // Remove the rule only if it is a muting rule\n      if (hasDontNotifyRule) {\n        promise = this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule.rule_id);\n      }\n    } else {\n      if (!roomPushRule) {\n        promise = this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n          actions: [PushRuleActionName.DontNotify]\n        });\n      } else if (!hasDontNotifyRule) {\n        // Remove the existing one before setting the mute push rule\n        // This is a workaround to SYN-590 (Push rule update fails)\n        var deferred = utils.defer();\n        this.deletePushRule(scope, PushRuleKind.RoomSpecific, roomPushRule.rule_id).then(() => {\n          this.addPushRule(scope, PushRuleKind.RoomSpecific, roomId, {\n            actions: [PushRuleActionName.DontNotify]\n          }).then(() => {\n            deferred.resolve();\n          }).catch(err => {\n            deferred.reject(err);\n          });\n        }).catch(err => {\n          deferred.reject(err);\n        });\n        promise = deferred.promise;\n      }\n    }\n    if (promise) {\n      return new Promise((resolve, reject) => {\n        // Update this.pushRules when the operation completes\n        promise.then(() => {\n          this.getPushRules().then(result => {\n            this.pushRules = result;\n            resolve();\n          }).catch(err => {\n            reject(err);\n          });\n        }).catch(err => {\n          // Update it even if the previous operation fails. This can help the\n          // app to recover when push settings has been modified from another client\n          this.getPushRules().then(result => {\n            this.pushRules = result;\n            reject(err);\n          }).catch(err2 => {\n            reject(err);\n          });\n        });\n      });\n    }\n  }\n  searchMessageText(opts) {\n    var roomEvents = {\n      search_term: opts.query\n    };\n    if (\"keys\" in opts) {\n      roomEvents.keys = opts.keys;\n    }\n    return this.search({\n      body: {\n        search_categories: {\n          room_events: roomEvents\n        }\n      }\n    });\n  }\n\n  /**\n   * Perform a server-side search for room events.\n   *\n   * The returned promise resolves to an object containing the fields:\n   *\n   *  * count:       estimate of the number of results\n   *  * next_batch:  token for back-pagination; if undefined, there are no more results\n   *  * highlights:  a list of words to highlight from the stemming algorithm\n   *  * results:     a list of results\n   *\n   * Each entry in the results list is a SearchResult.\n   *\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  searchRoomEvents(opts) {\n    // TODO: support search groups\n\n    var body = {\n      search_categories: {\n        room_events: {\n          search_term: opts.term,\n          filter: opts.filter,\n          order_by: SearchOrderBy.Recent,\n          event_context: {\n            before_limit: 1,\n            after_limit: 1,\n            include_profile: true\n          }\n        }\n      }\n    };\n    var searchResults = {\n      _query: body,\n      results: [],\n      highlights: []\n    };\n    return this.search({\n      body: body\n    }).then(res => this.processRoomEventsSearch(searchResults, res));\n  }\n\n  /**\n   * Take a result from an earlier searchRoomEvents call, and backfill results.\n   *\n   * @param searchResults -  the results object to be updated\n   * @returns Promise which resolves: updated result object\n   * @returns Rejects: with an error response.\n   */\n  backPaginateRoomEventsSearch(searchResults) {\n    // TODO: we should implement a backoff (as per scrollback()) to deal more\n    // nicely with HTTP errors.\n\n    if (!searchResults.next_batch) {\n      return Promise.reject(new Error(\"Cannot backpaginate event search any further\"));\n    }\n    if (searchResults.pendingRequest) {\n      // already a request in progress - return the existing promise\n      return searchResults.pendingRequest;\n    }\n    var searchOpts = {\n      body: searchResults._query,\n      next_batch: searchResults.next_batch\n    };\n    var promise = this.search(searchOpts, searchResults.abortSignal).then(res => this.processRoomEventsSearch(searchResults, res)).finally(() => {\n      searchResults.pendingRequest = undefined;\n    });\n    searchResults.pendingRequest = promise;\n    return promise;\n  }\n\n  /**\n   * helper for searchRoomEvents and backPaginateRoomEventsSearch. Processes the\n   * response from the API call and updates the searchResults\n   *\n   * @returns searchResults\n   * @internal\n   */\n  // XXX: Intended private, used in code\n  processRoomEventsSearch(searchResults, response) {\n    var _roomEvents$results$l, _roomEvents$results;\n    var roomEvents = response.search_categories.room_events;\n    searchResults.count = roomEvents.count;\n    searchResults.next_batch = roomEvents.next_batch;\n\n    // combine the highlight list with our existing list;\n    var highlights = new Set(roomEvents.highlights);\n    searchResults.highlights.forEach(hl => {\n      highlights.add(hl);\n    });\n\n    // turn it back into a list.\n    searchResults.highlights = Array.from(highlights);\n    var mapper = this.getEventMapper();\n\n    // append the new results to our existing results\n    var resultsLength = (_roomEvents$results$l = (_roomEvents$results = roomEvents.results) === null || _roomEvents$results === void 0 ? void 0 : _roomEvents$results.length) !== null && _roomEvents$results$l !== void 0 ? _roomEvents$results$l : 0;\n    for (var i = 0; i < resultsLength; i++) {\n      var sr = SearchResult.fromJson(roomEvents.results[i], mapper);\n      var _room5 = this.getRoom(sr.context.getEvent().getRoomId());\n      if (_room5) {\n        for (var ev of sr.context.getTimeline()) {\n          ev.setMetadata(_room5.currentState, false);\n        }\n      }\n      searchResults.results.push(sr);\n    }\n    return searchResults;\n  }\n\n  /**\n   * Populate the store with rooms the user has left.\n   * @returns Promise which resolves: TODO - Resolved when the rooms have\n   * been added to the data store.\n   * @returns Rejects: with an error response.\n   */\n  syncLeftRooms() {\n    // Guard against multiple calls whilst ongoing and multiple calls post success\n    if (this.syncedLeftRooms) {\n      return Promise.resolve([]); // don't call syncRooms again if it succeeded.\n    }\n    if (this.syncLeftRoomsPromise) {\n      return this.syncLeftRoomsPromise; // return the ongoing request\n    }\n    var syncApi = new SyncApi(this, this.clientOpts, this.buildSyncApiOptions());\n    this.syncLeftRoomsPromise = syncApi.syncLeftRooms();\n\n    // cleanup locks\n    this.syncLeftRoomsPromise.then(() => {\n      this.logger.debug(\"Marking success of sync left room request\");\n      this.syncedLeftRooms = true; // flip the bit on success\n    }).finally(() => {\n      this.syncLeftRoomsPromise = undefined; // cleanup ongoing request state\n    });\n    return this.syncLeftRoomsPromise;\n  }\n\n  /**\n   * Create a new filter.\n   * @param content - The HTTP body for the request\n   * @returns Promise which resolves to a Filter object.\n   * @returns Rejects: with an error response.\n   */\n  createFilter(content) {\n    var path = utils.encodeUri(\"/user/$userId/filter\", {\n      $userId: this.credentials.userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, content).then(response => {\n      // persist the filter\n      var filter = Filter.fromJson(this.credentials.userId, response.filter_id, content);\n      this.store.storeFilter(filter);\n      return filter;\n    });\n  }\n\n  /**\n   * Retrieve a filter.\n   * @param userId - The user ID of the filter owner\n   * @param filterId - The filter ID to retrieve\n   * @param allowCached - True to allow cached filters to be returned.\n   * Default: True.\n   * @returns Promise which resolves: a Filter object\n   * @returns Rejects: with an error response.\n   */\n  getFilter(userId, filterId, allowCached) {\n    if (allowCached) {\n      var filter = this.store.getFilter(userId, filterId);\n      if (filter) {\n        return Promise.resolve(filter);\n      }\n    }\n    var path = utils.encodeUri(\"/user/$userId/filter/$filterId\", {\n      $userId: userId,\n      $filterId: filterId\n    });\n    return this.http.authedRequest(Method.Get, path).then(response => {\n      // persist the filter\n      var filter = Filter.fromJson(userId, filterId, response);\n      this.store.storeFilter(filter);\n      return filter;\n    });\n  }\n\n  /**\n   * @returns Filter ID\n   */\n  getOrCreateFilter(filterName, filter) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      var filterId = _this36.store.getFilterIdByName(filterName);\n      var existingId;\n      if (filterId) {\n        // check that the existing filter matches our expectations\n        try {\n          var existingFilter = yield _this36.getFilter(_this36.credentials.userId, filterId, true);\n          if (existingFilter) {\n            var oldDef = existingFilter.getDefinition();\n            var newDef = filter.getDefinition();\n            if (utils.deepCompare(oldDef, newDef)) {\n              // super, just use that.\n              // debuglog(\"Using existing filter ID %s: %s\", filterId,\n              //          JSON.stringify(oldDef));\n              existingId = filterId;\n            }\n          }\n        } catch (error) {\n          // Synapse currently returns the following when the filter cannot be found:\n          // {\n          //     errcode: \"M_UNKNOWN\",\n          //     name: \"M_UNKNOWN\",\n          //     message: \"No row found\",\n          // }\n          if (error.errcode !== \"M_UNKNOWN\" && error.errcode !== \"M_NOT_FOUND\") {\n            throw error;\n          }\n        }\n        // if the filter doesn't exist anymore on the server, remove from store\n        if (!existingId) {\n          _this36.store.setFilterIdByName(filterName, undefined);\n        }\n      }\n      if (existingId) {\n        return existingId;\n      }\n\n      // create a new filter\n      var createdFilter = yield _this36.createFilter(filter.getDefinition());\n      _this36.store.setFilterIdByName(filterName, createdFilter.filterId);\n      return createdFilter.filterId;\n    })();\n  }\n\n  /**\n   * Gets a bearer token from the homeserver that the user can\n   * present to a third party in order to prove their ownership\n   * of the Matrix account they are logged into.\n   * @returns Promise which resolves: Token object\n   * @returns Rejects: with an error response.\n   */\n  getOpenIdToken() {\n    var path = utils.encodeUri(\"/user/$userId/openid/request_token\", {\n      $userId: this.credentials.userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {});\n  }\n  /**\n   * @returns Promise which resolves: ITurnServerResponse object\n   * @returns Rejects: with an error response.\n   */\n  turnServer() {\n    return this.http.authedRequest(Method.Get, \"/voip/turnServer\");\n  }\n\n  /**\n   * Get the TURN servers for this homeserver.\n   * @returns The servers or an empty list.\n   */\n  getTurnServers() {\n    return this.turnServers || [];\n  }\n\n  /**\n   * Get the unix timestamp (in milliseconds) at which the current\n   * TURN credentials (from getTurnServers) expire\n   * @returns The expiry timestamp in milliseconds\n   */\n  getTurnServersExpiry() {\n    return this.turnServersExpiry;\n  }\n  get pollingTurnServers() {\n    return this.checkTurnServersIntervalID !== undefined;\n  }\n\n  // XXX: Intended private, used in code.\n  checkTurnServers() {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this37.canSupportVoip) {\n        return;\n      }\n      var credentialsGood = false;\n      var remainingTime = _this37.turnServersExpiry - Date.now();\n      if (remainingTime > TURN_CHECK_INTERVAL) {\n        _this37.logger.debug(\"TURN creds are valid for another \" + remainingTime + \" ms: not fetching new ones.\");\n        credentialsGood = true;\n      } else {\n        _this37.logger.debug(\"Fetching new TURN credentials\");\n        try {\n          var res = yield _this37.turnServer();\n          if (res.uris) {\n            _this37.logger.debug(\"Got TURN URIs: \" + res.uris + \" refresh in \" + res.ttl + \" secs\");\n            // map the response to a format that can be fed to RTCPeerConnection\n            var servers = {\n              urls: res.uris,\n              username: res.username,\n              credential: res.password\n            };\n            _this37.turnServers = [servers];\n            // The TTL is in seconds but we work in ms\n            _this37.turnServersExpiry = Date.now() + res.ttl * 1000;\n            credentialsGood = true;\n            _this37.emit(ClientEvent.TurnServers, _this37.turnServers);\n          }\n        } catch (err) {\n          _this37.logger.error(\"Failed to get TURN URIs\", err);\n          if (err.httpStatus === 403) {\n            // We got a 403, so there's no point in looping forever.\n            _this37.logger.info(\"TURN access unavailable for this account: stopping credentials checks\");\n            if (_this37.checkTurnServersIntervalID !== null) {\n              globalThis.clearInterval(_this37.checkTurnServersIntervalID);\n            }\n            _this37.checkTurnServersIntervalID = undefined;\n            _this37.emit(ClientEvent.TurnServersError, err, true); // fatal\n          } else {\n            // otherwise, if we failed for whatever reason, try again the next time we're called.\n            _this37.emit(ClientEvent.TurnServersError, err, false); // non-fatal\n          }\n        }\n      }\n      return credentialsGood;\n    })();\n  }\n\n  /**\n   * Set whether to allow a fallback ICE server should be used for negotiating a\n   * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n   * false.\n   *\n   */\n  setFallbackICEServerAllowed(allow) {\n    this.fallbackICEServerAllowed = allow;\n  }\n\n  /**\n   * Get whether to allow a fallback ICE server should be used for negotiating a\n   * WebRTC connection if the homeserver doesn't provide any servers. Defaults to\n   * false.\n   *\n   * @returns\n   */\n  isFallbackICEServerAllowed() {\n    return this.fallbackICEServerAllowed;\n  }\n\n  /**\n   * Determines if the current user is an administrator of the Synapse homeserver.\n   * Returns false if untrue or the homeserver does not appear to be a Synapse\n   * homeserver. <strong>This function is implementation specific and may change\n   * as a result.</strong>\n   * @returns true if the user appears to be a Synapse administrator.\n   */\n  isSynapseAdministrator() {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/users/$userId/admin\", {\n      $userId: this.getUserId()\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: \"\"\n    }).then(r => r.admin); // pull out the specific boolean we want\n  }\n\n  /**\n   * Performs a whois lookup on a user using Synapse's administrator API.\n   * <strong>This function is implementation specific and may change as a\n   * result.</strong>\n   * @param userId - the User ID to look up.\n   * @returns the whois response - see Synapse docs for information.\n   */\n  whoisSynapseUser(userId) {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/whois/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: \"\"\n    });\n  }\n\n  /**\n   * Deactivates a user using Synapse's administrator API. <strong>This\n   * function is implementation specific and may change as a result.</strong>\n   * @param userId - the User ID to deactivate.\n   * @returns the deactivate response - see Synapse docs for information.\n   */\n  deactivateSynapseUser(userId) {\n    var path = utils.encodeUri(\"/_synapse/admin/v1/deactivate/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, undefined, {\n      prefix: \"\"\n    });\n  }\n  fetchClientWellKnown() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      var _this38$getDomain;\n      // `getRawClientConfig` does not throw or reject on network errors, instead\n      // it absorbs errors and returns `{}`.\n      _this38.clientWellKnownPromise = AutoDiscovery.getRawClientConfig((_this38$getDomain = _this38.getDomain()) !== null && _this38$getDomain !== void 0 ? _this38$getDomain : undefined);\n      _this38.clientWellKnown = yield _this38.clientWellKnownPromise;\n      _this38.emit(ClientEvent.ClientWellKnown, _this38.clientWellKnown);\n    })();\n  }\n  getClientWellKnown() {\n    return this.clientWellKnown;\n  }\n  waitForClientWellKnown() {\n    if (!this.clientRunning) {\n      throw new Error(\"Client is not running\");\n    }\n    return this.clientWellKnownPromise;\n  }\n\n  /**\n   * store client options with boolean/string/numeric values\n   * to know in the next session what flags the sync data was\n   * created with (e.g. lazy loading)\n   * @returns for store operation\n   */\n  storeClientOptions() {\n    // XXX: Intended private, used in code\n    var primTypes = [\"boolean\", \"string\", \"number\"];\n    var serializableOpts = Object.entries(this.clientOpts).filter(_ref6 => {\n      var [key, value] = _ref6;\n      return primTypes.includes(typeof value);\n    }).reduce((obj, _ref7) => {\n      var [key, value] = _ref7;\n      obj[key] = value;\n      return obj;\n    }, {});\n    return this.store.storeClientOptions(serializableOpts);\n  }\n\n  /**\n   * Gets a set of room IDs in common with another user.\n   *\n   * Note: This endpoint is unstable, and can throw an `Error`.\n   *   Check progress on [MSC2666](https://github.com/matrix-org/matrix-spec-proposals/pull/2666) for more details.\n   *\n   * @param userId - The userId to check.\n   * @returns Promise which resolves to an array of rooms\n   * @returns Rejects: with an error response.\n   */\n  // TODO: on spec release, rename this to getMutualRooms\n  // eslint-disable-next-line\n  _unstable_getSharedRooms(userId) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      // Initial variant of the MSC\n      var sharedRoomsSupport = yield _this39.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_SHARED_ROOMS);\n\n      // Newer variant that renamed shared rooms to mutual rooms\n      var mutualRoomsSupport = yield _this39.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_MUTUAL_ROOMS);\n\n      // Latest variant that changed from path elements to query elements\n      var queryMutualRoomsSupport = yield _this39.doesServerSupportUnstableFeature(UNSTABLE_MSC2666_QUERY_MUTUAL_ROOMS);\n      if (!sharedRoomsSupport && !mutualRoomsSupport && !queryMutualRoomsSupport) {\n        throw Error(\"Server does not support the Mutual Rooms API\");\n      }\n      var path;\n      var query;\n\n      // Cascading unstable support switching.\n      if (queryMutualRoomsSupport) {\n        path = \"/uk.half-shot.msc2666/user/mutual_rooms\";\n        query = {\n          user_id: userId\n        };\n      } else {\n        path = utils.encodeUri(\"/uk.half-shot.msc2666/user/\".concat(mutualRoomsSupport ? \"mutual_rooms\" : \"shared_rooms\", \"/$userId\"), {\n          $userId: userId\n        });\n        query = {};\n      }\n\n      // Accumulated rooms\n      var rooms = [];\n      var token = null;\n      do {\n        var tokenQuery = {};\n        if (token != null && queryMutualRoomsSupport) {\n          tokenQuery[\"batch_token\"] = token;\n        }\n        var res = yield _this39.http.authedRequest(Method.Get, path, _objectSpread(_objectSpread({}, query), tokenQuery), undefined, {\n          prefix: ClientPrefix.Unstable\n        });\n        rooms.push(...res.joined);\n        if (res.next_batch_token !== undefined) {\n          token = res.next_batch_token;\n        } else {\n          token = null;\n        }\n      } while (token != null);\n      return rooms;\n    })();\n  }\n\n  /**\n   * Get the API versions supported by the server, along with any\n   * unstable APIs it supports\n   * @returns The server /versions response\n   */\n  getVersions() {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      if (_this40.serverVersionsPromise) {\n        return _this40.serverVersionsPromise;\n      }\n\n      // We send an authenticated request as of MSC4026\n      _this40.serverVersionsPromise = _this40.http.authedRequest(Method.Get, \"/_matrix/client/versions\", undefined, undefined, {\n        prefix: \"\"\n      }).catch(e => {\n        // Need to unset this if it fails, otherwise we'll never retry\n        _this40.serverVersionsPromise = undefined;\n        // but rethrow the exception to anything that was waiting\n        throw e;\n      });\n      var serverVersions = yield _this40.serverVersionsPromise;\n      _this40.canSupport = yield buildFeatureSupportMap(serverVersions);\n      return _this40.serverVersionsPromise;\n    })();\n  }\n\n  /**\n   * Check if a particular spec version is supported by the server.\n   * @param version - The spec version (such as \"r0.5.0\") to check for.\n   * @returns Whether it is supported\n   */\n  isVersionSupported(version) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      var {\n        versions\n      } = yield _this41.getVersions();\n      return versions && versions.includes(version);\n    })();\n  }\n\n  /**\n   * Query the server to see if it lists support for an unstable feature\n   * in the /versions response\n   * @param feature - the feature name\n   * @returns true if the feature is supported\n   */\n  doesServerSupportUnstableFeature(feature) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this42.getVersions();\n      if (!response) return false;\n      var unstableFeatures = response[\"unstable_features\"];\n      return unstableFeatures && !!unstableFeatures[feature];\n    })();\n  }\n\n  /**\n   * Query the server to see if it is forcing encryption to be enabled for\n   * a given room preset, based on the /versions response.\n   * @param presetName - The name of the preset to check.\n   * @returns true if the server is forcing encryption\n   * for the preset.\n   */\n  doesServerForceEncryptionForPreset(presetName) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this43.getVersions();\n      if (!response) return false;\n      var unstableFeatures = response[\"unstable_features\"];\n\n      // The preset name in the versions response will be without the _chat suffix.\n      var versionsPresetName = presetName.includes(\"_chat\") ? presetName.substring(0, presetName.indexOf(\"_chat\")) : presetName;\n      return unstableFeatures && !!unstableFeatures[\"io.element.e2ee_forced.\".concat(versionsPresetName)];\n    })();\n  }\n  doesServerSupportThread() {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this44.isVersionSupported(\"v1.4\")) {\n        return {\n          threads: FeatureSupport.Stable,\n          list: FeatureSupport.Stable,\n          fwdPagination: FeatureSupport.Stable\n        };\n      }\n      try {\n        var [threadUnstable, threadStable, listUnstable, listStable, fwdPaginationUnstable, fwdPaginationStable] = yield Promise.all([_this44.doesServerSupportUnstableFeature(\"org.matrix.msc3440\"), _this44.doesServerSupportUnstableFeature(\"org.matrix.msc3440.stable\"), _this44.doesServerSupportUnstableFeature(\"org.matrix.msc3856\"), _this44.doesServerSupportUnstableFeature(\"org.matrix.msc3856.stable\"), _this44.doesServerSupportUnstableFeature(\"org.matrix.msc3715\"), _this44.doesServerSupportUnstableFeature(\"org.matrix.msc3715.stable\")]);\n        return {\n          threads: determineFeatureSupport(threadStable, threadUnstable),\n          list: determineFeatureSupport(listStable, listUnstable),\n          fwdPagination: determineFeatureSupport(fwdPaginationStable, fwdPaginationUnstable)\n        };\n      } catch (_unused2) {\n        return {\n          threads: FeatureSupport.None,\n          list: FeatureSupport.None,\n          fwdPagination: FeatureSupport.None\n        };\n      }\n    })();\n  }\n\n  /**\n   * Get if lazy loading members is being used.\n   * @returns Whether or not members are lazy loaded by this client\n   */\n  hasLazyLoadMembersEnabled() {\n    var _this$clientOpts3;\n    return !!((_this$clientOpts3 = this.clientOpts) !== null && _this$clientOpts3 !== void 0 && _this$clientOpts3.lazyLoadMembers);\n  }\n\n  /**\n   * Set a function which is called when /sync returns a 'limited' response.\n   * It is called with a room ID and returns a boolean. It should return 'true' if the SDK\n   * can SAFELY remove events from this room. It may not be safe to remove events if there\n   * are other references to the timelines for this room, e.g because the client is\n   * actively viewing events in this room.\n   * Default: returns false.\n   * @param cb - The callback which will be invoked.\n   */\n  setCanResetTimelineCallback(cb) {\n    this.canResetTimelineCallback = cb;\n  }\n\n  /**\n   * Get the callback set via `setCanResetTimelineCallback`.\n   * @returns The callback or null\n   */\n  getCanResetTimelineCallback() {\n    return this.canResetTimelineCallback;\n  }\n\n  /**\n   * Returns relations for a given event. Handles encryption transparently,\n   * with the caveat that the amount of events returned might be 0, even though you get a nextBatch.\n   * When the returned promise resolves, all messages should have finished trying to decrypt.\n   * @param roomId - the room of the event\n   * @param eventId - the id of the event\n   * @param relationType - the rel_type of the relations requested\n   * @param eventType - the event type of the relations requested\n   * @param opts - options with optional values for the request.\n   * @returns an object with `events` as `MatrixEvent[]` and optionally `nextBatch` if more relations are available.\n   */\n  relations(roomId, eventId, relationType, eventType) {\n    var _arguments8 = arguments,\n      _this45 = this;\n    return _asyncToGenerator(function* () {\n      var _result$next_batch, _result$prev_batch;\n      var opts = _arguments8.length > 4 && _arguments8[4] !== undefined ? _arguments8[4] : {\n        dir: Direction.Backward\n      };\n      var fetchedEventType = eventType ? _this45.getEncryptedIfNeededEventType(roomId, eventType) : null;\n      var [eventResult, result] = yield Promise.all([_this45.fetchRoomEvent(roomId, eventId), _this45.fetchRelations(roomId, eventId, relationType, fetchedEventType, opts)]);\n      var mapper = _this45.getEventMapper();\n      var originalEvent = eventResult ? mapper(eventResult) : undefined;\n      var events = result.chunk.map(mapper);\n      if (fetchedEventType === EventType.RoomMessageEncrypted) {\n        var allEvents = originalEvent ? events.concat(originalEvent) : events;\n        yield Promise.all(allEvents.map(e => _this45.decryptEventIfNeeded(e)));\n        if (eventType !== null) {\n          events = events.filter(e => e.getType() === eventType);\n        }\n      }\n      if (originalEvent && relationType === RelationType.Replace) {\n        events = events.filter(e => e.getSender() === originalEvent.getSender());\n      }\n      return {\n        originalEvent: originalEvent !== null && originalEvent !== void 0 ? originalEvent : null,\n        events,\n        nextBatch: (_result$next_batch = result.next_batch) !== null && _result$next_batch !== void 0 ? _result$next_batch : null,\n        prevBatch: (_result$prev_batch = result.prev_batch) !== null && _result$prev_batch !== void 0 ? _result$prev_batch : null\n      };\n    })();\n  }\n\n  /**\n   * Generates a random string suitable for use as a client secret. <strong>This\n   * method is experimental and may change.</strong>\n   * @returns A new client secret\n   */\n  generateClientSecret() {\n    return secureRandomString(32);\n  }\n\n  /**\n   * Attempts to decrypt an event\n   * @param event - The event to decrypt\n   * @returns A decryption promise\n   */\n  decryptEventIfNeeded(event, options) {\n    if (event.shouldAttemptDecryption() && this.getCrypto()) {\n      event.attemptDecryption(this.cryptoBackend, options);\n    }\n    if (event.isBeingDecrypted()) {\n      return event.getDecryptionPromise();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  termsUrlForService(serviceType, baseUrl) {\n    switch (serviceType) {\n      case SERVICE_TYPES.IS:\n        return this.http.getUrl(\"/terms\", undefined, IdentityPrefix.V2, baseUrl);\n      case SERVICE_TYPES.IM:\n        return this.http.getUrl(\"/terms\", undefined, \"/_matrix/integrations/v1\", baseUrl);\n      default:\n        throw new Error(\"Unsupported service type\");\n    }\n  }\n\n  /**\n   * Get the Homeserver URL of this client\n   * @returns Homeserver URL of this client\n   */\n  getHomeserverUrl() {\n    return this.baseUrl;\n  }\n\n  /**\n   * Get the identity server URL of this client\n   * @param stripProto - whether or not to strip the protocol from the URL\n   * @returns Identity server URL of this client\n   */\n  getIdentityServerUrl() {\n    var _this$idBaseUrl, _this$idBaseUrl2;\n    var stripProto = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (stripProto && ((_this$idBaseUrl = this.idBaseUrl) !== null && _this$idBaseUrl !== void 0 && _this$idBaseUrl.startsWith(\"http://\") || (_this$idBaseUrl2 = this.idBaseUrl) !== null && _this$idBaseUrl2 !== void 0 && _this$idBaseUrl2.startsWith(\"https://\"))) {\n      return this.idBaseUrl.split(\"://\")[1];\n    }\n    return this.idBaseUrl;\n  }\n\n  /**\n   * Set the identity server URL of this client\n   * @param url - New identity server URL\n   */\n  setIdentityServerUrl(url) {\n    this.idBaseUrl = utils.ensureNoTrailingSlash(url);\n    this.http.setIdBaseUrl(this.idBaseUrl);\n  }\n\n  /**\n   * Get the access token associated with this account.\n   * @returns The access_token or null\n   */\n  getAccessToken() {\n    return this.http.opts.accessToken || null;\n  }\n\n  /**\n   * Get the refresh token associated with this account.\n   * @returns The refresh_token or null\n   */\n  getRefreshToken() {\n    var _this$http$opts$refre;\n    return (_this$http$opts$refre = this.http.opts.refreshToken) !== null && _this$http$opts$refre !== void 0 ? _this$http$opts$refre : null;\n  }\n\n  /**\n   * Set the access token associated with this account.\n   * @param token - The new access token.\n   */\n  setAccessToken(token) {\n    this.http.opts.accessToken = token;\n    // The /versions response can vary for different users so clear the cache\n    this.serverVersionsPromise = undefined;\n  }\n\n  /**\n   * @returns true if there is a valid access_token for this client.\n   */\n  isLoggedIn() {\n    return this.http.opts.accessToken !== undefined;\n  }\n\n  /**\n   * Make up a new transaction id\n   *\n   * @returns a new, unique, transaction id\n   */\n  makeTxnId() {\n    return \"m\" + new Date().getTime() + \".\" + this.txnCtr++;\n  }\n\n  /**\n   * Check whether a username is available prior to registration. An error response\n   * indicates an invalid/unavailable username.\n   * @param username - The username to check the availability of.\n   * @returns Promise which resolves: to boolean of whether the username is available.\n   */\n  isUsernameAvailable(username) {\n    return this.http.authedRequest(Method.Get, \"/register/available\", {\n      username\n    }).then(response => {\n      return response.available;\n    }).catch(response => {\n      if (response.errcode === \"M_USER_IN_USE\") {\n        return false;\n      }\n      return Promise.reject(response);\n    });\n  }\n\n  /**\n   * @param bindThreepids - Set key 'email' to true to bind any email\n   *     threepid uses during registration in the identity server. Set 'msisdn' to\n   *     true to bind msisdn.\n   * @returns Promise which resolves to a RegisterResponse object\n   * @returns Rejects: with an error response.\n   */\n  register(username, password, sessionId, auth, bindThreepids, guestAccessToken, inhibitLogin) {\n    if (sessionId) {\n      auth.session = sessionId;\n    }\n    var params = {\n      auth: auth,\n      refresh_token: true // always ask for a refresh token - does nothing if unsupported\n    };\n    if (username !== undefined && username !== null) {\n      params.username = username;\n    }\n    if (password !== undefined && password !== null) {\n      params.password = password;\n    }\n    if (guestAccessToken !== undefined && guestAccessToken !== null) {\n      params.guest_access_token = guestAccessToken;\n    }\n    if (inhibitLogin !== undefined && inhibitLogin !== null) {\n      params.inhibit_login = inhibitLogin;\n    }\n    return this.registerRequest(params);\n  }\n\n  /**\n   * Register a guest account.\n   * This method returns the auth info needed to create a new authenticated client,\n   * Remember to call `setGuest(true)` on the (guest-)authenticated client, e.g:\n   * ```javascript\n   * const tmpClient = await sdk.createClient(MATRIX_INSTANCE);\n   * const { user_id, device_id, access_token } = tmpClient.registerGuest();\n   * const client = createClient({\n   *   baseUrl: MATRIX_INSTANCE,\n   *   accessToken: access_token,\n   *   userId: user_id,\n   *   deviceId: device_id,\n   * })\n   * client.setGuest(true);\n   * ```\n   *\n   * @param body - JSON HTTP body to provide.\n   * @returns Promise which resolves: JSON object that contains:\n   *                   `{ user_id, device_id, access_token, home_server }`\n   * @returns Rejects: with an error response.\n   */\n  registerGuest() {\n    var {\n      body\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.registerRequest(body || {}, \"guest\");\n  }\n\n  /**\n   * @param data - parameters for registration request\n   * @param kind - type of user to register. may be \"guest\"\n   * @returns Promise which resolves: to the /register response\n   * @returns Rejects: with an error response.\n   */\n  registerRequest(data, kind) {\n    var params = {};\n    if (kind) {\n      params.kind = kind;\n    }\n    return this.http.request(Method.Post, \"/register\", params, data);\n  }\n\n  /**\n   * Refreshes an access token using a provided refresh token. The refresh token\n   * must be valid for the current access token known to the client instance.\n   *\n   * Note that this function will not cause a logout if the token is deemed\n   * unknown by the server - the caller is responsible for managing logout\n   * actions on error.\n   * @param refreshToken - The refresh token.\n   * @returns Promise which resolves to the new token.\n   * @returns Rejects with an error response.\n   */\n  refreshToken(refreshToken) {\n    var performRefreshRequestWithPrefix = prefix => this.http.authedRequest(Method.Post, \"/refresh\", undefined, {\n      refresh_token: refreshToken\n    }, {\n      prefix,\n      inhibitLogoutEmit: true // we don't want to cause logout loops\n    });\n\n    // First try with the (specced) /v3/ prefix.\n    // However, before Synapse 1.72.0, Synapse incorrectly required a /v1/ prefix, so we fall\n    // back to that if the request fails, for backwards compatibility.\n    return performRefreshRequestWithPrefix(ClientPrefix.V3).catch(e => {\n      if (e.errcode === \"M_UNRECOGNIZED\") {\n        return performRefreshRequestWithPrefix(ClientPrefix.V1);\n      }\n      throw e;\n    });\n  }\n\n  /**\n   * @returns Promise which resolves to the available login flows\n   * @returns Rejects: with an error response.\n   */\n  loginFlows() {\n    return this.http.request(Method.Get, \"/login\");\n  }\n\n  /**\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   *\n   * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n   *    returned credentials. Instead, call {@link loginRequest} and create a new `MatrixClient` instance using the\n   *    results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n   */\n  login(loginType, data) {\n    return this.loginRequest(_objectSpread(_objectSpread({}, data), {}, {\n      type: loginType\n    })).then(response => {\n      if (response.access_token && response.user_id) {\n        this.http.opts.accessToken = response.access_token;\n        this.credentials = {\n          userId: response.user_id\n        };\n      }\n      return response;\n    });\n  }\n\n  /**\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   *\n   * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n   *   returned credentials. Instead, call {@link loginRequest} with `data.type: \"m.login.password\"`, and create a new\n   *   `MatrixClient` instance using the results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n   */\n  loginWithPassword(user, password) {\n    return this.login(\"m.login.password\", {\n      user: user,\n      password: password\n    });\n  }\n\n  /**\n   * @param redirectUrl - The URL to redirect to after the HS\n   * authenticates with CAS.\n   * @returns The HS URL to hit to begin the CAS login process.\n   */\n  getCasLoginUrl(redirectUrl) {\n    return this.getSsoLoginUrl(redirectUrl, \"cas\");\n  }\n\n  /**\n   * @param redirectUrl - The URL to redirect to after the HS\n   *     authenticates with the SSO.\n   * @param loginType - The type of SSO login we are doing (sso or cas).\n   *     Defaults to 'sso'.\n   * @param idpId - The ID of the Identity Provider being targeted, optional.\n   * @param action - the SSO flow to indicate to the IdP, optional.\n   * @returns The HS URL to hit to begin the SSO login process.\n   */\n  getSsoLoginUrl(redirectUrl) {\n    var loginType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"sso\";\n    var idpId = arguments.length > 2 ? arguments[2] : undefined;\n    var action = arguments.length > 3 ? arguments[3] : undefined;\n    var url = \"/login/\" + loginType + \"/redirect\";\n    if (idpId) {\n      url += \"/\" + idpId;\n    }\n    var params = {\n      redirectUrl,\n      [SSO_ACTION_PARAM.unstable]: action\n    };\n    return this.http.getUrl(url, params).href;\n  }\n\n  /**\n   * @param token - Login token previously received from homeserver\n   * @returns Promise which resolves to a LoginResponse object\n   * @returns Rejects: with an error response.\n   *\n   * @deprecated This method has unintuitive behaviour: it updates the `MatrixClient` instance with *some* of the\n   *   returned credentials. Instead, call {@link loginRequest} with `data.type: \"m.login.token\"`, and create a new\n   *   `MatrixClient` instance using the results. See https://github.com/matrix-org/matrix-js-sdk/issues/4502.\n   */\n  loginWithToken(token) {\n    return this.login(\"m.login.token\", {\n      token: token\n    });\n  }\n\n  /**\n   * Sends a `POST /login` request to the server.\n   *\n   * If successful, this will create a new device and access token for the user.\n   *\n   * @see {@link MatrixClient.loginFlows} which makes a `GET /login` request.\n   * @see https://spec.matrix.org/v1.13/client-server-api/#post_matrixclientv3login\n   *\n   * @param data - Credentials and other details for the login request.\n   */\n  loginRequest(data) {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      return yield _this46.http.authedRequest(Method.Post, \"/login\", undefined, data);\n    })();\n  }\n\n  /**\n   * Logs out the current session.\n   * Obviously, further calls that require authorisation should fail after this\n   * method is called. The state of the MatrixClient object is not affected:\n   * it is up to the caller to either reset or destroy the MatrixClient after\n   * this method succeeds.\n   * @param stopClient - whether to stop the client before calling /logout to prevent invalid token errors.\n   * @returns Promise which resolves: On success, the empty object `{}`\n   */\n  logout() {\n    var _arguments9 = arguments,\n      _this47 = this;\n    return _asyncToGenerator(function* () {\n      var stopClient = _arguments9.length > 0 && _arguments9[0] !== undefined ? _arguments9[0] : false;\n      if (stopClient) {\n        _this47.stopClient();\n        _this47.http.abort();\n      }\n      return _this47.http.authedRequest(Method.Post, \"/logout\");\n    })();\n  }\n\n  /**\n   * Deactivates the logged-in account.\n   * Obviously, further calls that require authorisation should fail after this\n   * method is called. The state of the MatrixClient object is not affected:\n   * it is up to the caller to either reset or destroy the MatrixClient after\n   * this method succeeds.\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @param erase - Optional. If set, send as `erase` attribute in the\n   * JSON request body, indicating whether the account should be erased. Defaults\n   * to false.\n   * @returns Promise which resolves: On success, the empty object\n   */\n  deactivateAccount(auth, erase) {\n    var body = {};\n    if (auth) {\n      body.auth = auth;\n    }\n    if (erase !== undefined) {\n      body.erase = erase;\n    }\n    return this.http.authedRequest(Method.Post, \"/account/deactivate\", undefined, body);\n  }\n\n  /**\n   * Make a request for an `m.login.token` to be issued as per\n   * https://spec.matrix.org/v1.7/client-server-api/#post_matrixclientv1loginget_token\n   *\n   * The server may require User-Interactive auth.\n   *\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: On success, the token response\n   * or UIA auth data.\n   */\n  requestLoginToken(auth) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      var body = {\n        auth\n      };\n      return _this48.http.authedRequest(Method.Post, \"/login/get_token\", undefined,\n      // no query params\n      body, {\n        prefix: ClientPrefix.V1\n      });\n    })();\n  }\n\n  /**\n   * Get the fallback URL to use for unknown interactive-auth stages.\n   *\n   * @param loginType -     the type of stage being attempted\n   * @param authSessionId - the auth session ID provided by the homeserver\n   *\n   * @returns HS URL to hit to for the fallback interface\n   */\n  getFallbackAuthUrl(loginType, authSessionId) {\n    var path = utils.encodeUri(\"/auth/$loginType/fallback/web\", {\n      $loginType: loginType\n    });\n    return this.http.getUrl(path, {\n      session: authSessionId\n    }).href;\n  }\n\n  /**\n   * Create a new room.\n   * @param options - a list of options to pass to the /createRoom API.\n   * @returns Promise which resolves: `{room_id: {string}}`\n   * @returns Rejects: with an error response.\n   */\n  createRoom(options) {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      var _this49$identityServe;\n      // eslint-disable-line camelcase\n      // some valid options include: room_alias_name, visibility, invite\n\n      // inject the id_access_token if inviting 3rd party addresses\n      var invitesNeedingToken = (options.invite_3pid || []).filter(i => !i.id_access_token);\n      if (invitesNeedingToken.length > 0 && (_this49$identityServe = _this49.identityServer) !== null && _this49$identityServe !== void 0 && _this49$identityServe.getAccessToken) {\n        var identityAccessToken = yield _this49.identityServer.getAccessToken();\n        if (identityAccessToken) {\n          for (var invite of invitesNeedingToken) {\n            invite.id_access_token = identityAccessToken;\n          }\n        }\n      }\n      return _this49.http.authedRequest(Method.Post, \"/createRoom\", undefined, options);\n    })();\n  }\n\n  /**\n   * Fetches relations for a given event\n   * @param roomId - the room of the event\n   * @param eventId - the id of the event\n   * @param relationType - the rel_type of the relations requested\n   * @param eventType - the event type of the relations requested\n   * @param opts - options with optional values for the request.\n   * @returns the response, with chunk, prev_batch and, next_batch.\n   */\n  fetchRelations(roomId, eventId, relationType, eventType) {\n    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {\n      dir: Direction.Backward\n    };\n    var params = opts;\n    if (Thread.hasServerSideFwdPaginationSupport === FeatureSupport.Experimental) {\n      params = replaceParam(\"dir\", \"org.matrix.msc3715.dir\", params);\n    }\n    if (this.canSupport.get(Feature.RelationsRecursion) === ServerSupport.Unstable) {\n      params = replaceParam(\"recurse\", \"org.matrix.msc3981.recurse\", params);\n    }\n    var queryString = utils.encodeParams(params);\n    var templatedUrl = \"/rooms/$roomId/relations/$eventId\";\n    if (relationType !== null) {\n      templatedUrl += \"/$relationType\";\n      if (eventType !== null) {\n        templatedUrl += \"/$eventType\";\n      }\n    } else if (eventType !== null) {\n      this.logger.warn(\"eventType: \".concat(eventType, \" ignored when fetching\\n            relations as relationType is null\"));\n      eventType = null;\n    }\n    var path = utils.encodeUri(templatedUrl + \"?\" + queryString, {\n      $roomId: roomId,\n      $eventId: eventId,\n      $relationType: relationType,\n      $eventType: eventType\n    });\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix: ClientPrefix.V1\n    });\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  roomState(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/state\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Get an event in a room by its event id.\n   *\n   * @returns Promise which resolves to an object containing the event.\n   * @returns Rejects: with an error response.\n   */\n  fetchRoomEvent(roomId, eventId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/event/$eventId\", {\n      $roomId: roomId,\n      $eventId: eventId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param includeMembership - the membership type to include in the response\n   * @param excludeMembership - the membership type to exclude from the response\n   * @param atEventId - the id of the event for which moment in the timeline the members should be returned for\n   * @returns Promise which resolves: dictionary of userid to profile information\n   * @returns Rejects: with an error response.\n   */\n  members(roomId, includeMembership, excludeMembership, atEventId) {\n    var queryParams = {};\n    if (includeMembership) {\n      queryParams.membership = includeMembership;\n    }\n    if (excludeMembership) {\n      queryParams.not_membership = excludeMembership;\n    }\n    if (atEventId) {\n      queryParams.at = atEventId;\n    }\n    var queryString = utils.encodeParams(queryParams);\n    var path = utils.encodeUri(\"/rooms/$roomId/members?\" + queryString, {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Upgrades a room to a new protocol version\n   * @param newVersion - The target version to upgrade to\n   * @returns Promise which resolves: Object with key 'replacement_room'\n   * @returns Rejects: with an error response.\n   */\n  upgradeRoom(roomId, newVersion) {\n    // eslint-disable-line camelcase\n    var path = utils.encodeUri(\"/rooms/$roomId/upgrade\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      new_version: newVersion\n    });\n  }\n\n  /**\n   * Retrieve a state event.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getStateEvent(roomId, eventType, stateKey) {\n    var pathParams = {\n      $roomId: roomId,\n      $eventType: eventType,\n      $stateKey: stateKey\n    };\n    var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n    if (stateKey !== undefined) {\n      path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n    }\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Send a state event into a room\n   * @param roomId - ID of the room to send the event into\n   * @param eventType - type of the state event to send\n   * @param content - content of the event to send\n   * @param stateKey - the stateKey to send into the room\n   * @param opts - Options for the request function.\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  sendStateEvent(roomId, eventType, content) {\n    var stateKey = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \"\";\n    var opts = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n    var pathParams = {\n      $roomId: roomId,\n      $eventType: eventType,\n      $stateKey: stateKey\n    };\n    var path = utils.encodeUri(\"/rooms/$roomId/state/$eventType\", pathParams);\n    if (stateKey !== undefined) {\n      path = utils.encodeUri(path + \"/$stateKey\", pathParams);\n    }\n    return this.http.authedRequest(Method.Put, path, undefined, content, opts);\n  }\n\n  /**\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  roomInitialSync(roomId, limit) {\n    var _limit$toString;\n    var path = utils.encodeUri(\"/rooms/$roomId/initialSync\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path, {\n      limit: (_limit$toString = limit === null || limit === void 0 ? void 0 : limit.toString()) !== null && _limit$toString !== void 0 ? _limit$toString : \"30\"\n    });\n  }\n\n  /**\n   * Set a marker to indicate the point in a room before which the user has read every\n   * event. This can be retrieved from room account data (the event type is `m.fully_read`)\n   * and displayed as a horizontal line in the timeline that is visually distinct to the\n   * position of the user's own read receipt.\n   * @param roomId - ID of the room that has been read\n   * @param rmEventId - ID of the event that has been read\n   * @param rrEventId - ID of the event tracked by the read receipt. This is here\n   * for convenience because the RR and the RM are commonly updated at the same time as\n   * each other. Optional.\n   * @param rpEventId - rpEvent the m.read.private read receipt event for when we\n   * don't want other users to see the read receipts. This is experimental. Optional.\n   * @returns Promise which resolves: the empty object, `{}`.\n   */\n  setRoomReadMarkersHttpRequest(roomId, rmEventId, rrEventId, rpEventId) {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/rooms/$roomId/read_markers\", {\n        $roomId: roomId\n      });\n      var content = {\n        [ReceiptType.FullyRead]: rmEventId,\n        [ReceiptType.Read]: rrEventId\n      };\n      if ((yield _this50.doesServerSupportUnstableFeature(\"org.matrix.msc2285.stable\")) || (yield _this50.isVersionSupported(\"v1.4\"))) {\n        content[ReceiptType.ReadPrivate] = rpEventId;\n      }\n      return _this50.http.authedRequest(Method.Post, path, undefined, content);\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves: A list of the user's current rooms\n   * @returns Rejects: with an error response.\n   */\n  getJoinedRooms() {\n    var path = utils.encodeUri(\"/joined_rooms\", {});\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Retrieve membership info. for a room.\n   * @param roomId - ID of the room to get membership for\n   * @returns Promise which resolves: A list of currently joined users\n   *                                 and their profile data.\n   * @returns Rejects: with an error response.\n   */\n  getJoinedRoomMembers(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/joined_members\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * @param params - Options for this request\n   * @returns Promise which resolves: IPublicRoomsResponse\n   * @returns Rejects: with an error response.\n   */\n  publicRooms() {\n    var _ref8 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var {\n        server,\n        limit,\n        since\n      } = _ref8,\n      options = _objectWithoutProperties(_ref8, _excluded);\n    if (Object.keys(options).length === 0) {\n      var queryParams = {\n        server,\n        limit,\n        since\n      };\n      return this.http.authedRequest(Method.Get, \"/publicRooms\", queryParams);\n    } else {\n      var _queryParams = {\n        server\n      };\n      var _body = _objectSpread({\n        limit,\n        since\n      }, options);\n      return this.http.authedRequest(Method.Post, \"/publicRooms\", _queryParams, _body);\n    }\n  }\n\n  /**\n   * Create an alias to room ID mapping.\n   * @param alias - The room alias to create.\n   * @param roomId - The room ID to link the alias to.\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  createAlias(alias, roomId) {\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    var data = {\n      room_id: roomId\n    };\n    return this.http.authedRequest(Method.Put, path, undefined, data);\n  }\n\n  /**\n   * Delete an alias to room ID mapping. This alias must be on your local server,\n   * and you must have sufficient access to do this operation.\n   * @param alias - The room alias to delete.\n   * @returns Promise which resolves: an empty object `{}`.\n   * @returns Rejects: with an error response.\n   */\n  deleteAlias(alias) {\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * Gets the local aliases for the room. Note: this includes all local aliases, unlike the\n   * curated list from the m.room.canonical_alias state event.\n   * @param roomId - The room ID to get local aliases for.\n   * @returns Promise which resolves: an object with an `aliases` property, containing an array of local aliases\n   * @returns Rejects: with an error response.\n   */\n  getLocalAliases(roomId) {\n    var path = utils.encodeUri(\"/rooms/$roomId/aliases\", {\n      $roomId: roomId\n    });\n    var prefix = ClientPrefix.V3;\n    return this.http.authedRequest(Method.Get, path, undefined, undefined, {\n      prefix\n    });\n  }\n\n  /**\n   * Get room info for the given alias.\n   * @param alias - The room alias to resolve.\n   * @returns Promise which resolves: Object with room_id and servers.\n   * @returns Rejects: with an error response.\n   */\n  getRoomIdForAlias(alias) {\n    // eslint-disable-line camelcase\n    var path = utils.encodeUri(\"/directory/room/$alias\", {\n      $alias: alias\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Get the visibility of a room in the current HS's room directory\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getRoomDirectoryVisibility(roomId) {\n    var path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Set the visibility of a room in the current HS's room directory\n   * @param visibility - \"public\" to make the room visible\n   *                 in the public directory, or \"private\" to make\n   *                 it invisible.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setRoomDirectoryVisibility(roomId, visibility) {\n    var path = utils.encodeUri(\"/directory/list/room/$roomId\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      visibility\n    });\n  }\n\n  /**\n   * Query the user directory with a term matching user IDs, display names and domains.\n   * @param options\n   * @param options.term - the term with which to search.\n   * @param options.limit - the maximum number of results to return. The server will apply a limit if unspecified.\n   * @returns Promise which resolves: an array of results.\n   */\n  searchUserDirectory(_ref9) {\n    var {\n      term,\n      limit\n    } = _ref9;\n    var body = {\n      search_term: term\n    };\n    if (limit !== undefined) {\n      body.limit = limit;\n    }\n    return this.http.authedRequest(Method.Post, \"/user_directory/search\", undefined, body);\n  }\n\n  /**\n   * Upload a file to the media repository on the homeserver.\n   *\n   * @param file - The object to upload. On a browser, something that\n   *   can be sent to XMLHttpRequest.send (typically a File).  Under node.js,\n   *   a a Buffer, String or ReadStream.\n   *\n   * @param opts -  options object\n   *\n   * @returns Promise which resolves to response object, as\n   *    determined by this.opts.onlyData, opts.rawResponse, and\n   *    opts.onlyContentUri.  Rejects with an error (usually a MatrixError).\n   */\n  uploadContent(file, opts) {\n    return this.http.uploadContent(file, opts);\n  }\n\n  /**\n   * Cancel a file upload in progress\n   * @param upload - The object returned from uploadContent\n   * @returns true if canceled, otherwise false\n   */\n  cancelUpload(upload) {\n    return this.http.cancelUpload(upload);\n  }\n\n  /**\n   * Get a list of all file uploads in progress\n   * @returns Array of objects representing current uploads.\n   * Currently in progress is element 0. Keys:\n   *  - promise: The promise associated with the upload\n   *  - loaded: Number of bytes uploaded\n   *  - total: Total number of bytes to upload\n   */\n  getCurrentUploads() {\n    return this.http.getCurrentUploads();\n  }\n\n  /**\n   * @param info - The kind of info to retrieve (e.g. 'displayname',\n   * 'avatar_url').\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   */\n  getProfileInfo(userId, info\n  // eslint-disable-next-line camelcase\n  ) {\n    var path = info ? utils.encodeUri(\"/profile/$userId/$info\", {\n      $userId: userId,\n      $info: info\n    }) : utils.encodeUri(\"/profile/$userId\", {\n      $userId: userId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Determine if the server supports extended profiles, as described by MSC4133.\n   *\n   * @returns `true` if supported, otherwise `false`\n   */\n  doesServerSupportExtendedProfiles() {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      return _this51.doesServerSupportUnstableFeature(UNSTABLE_MSC4133_EXTENDED_PROFILES);\n    })();\n  }\n\n  /**\n   * Get the prefix used for extended profile requests.\n   *\n   * @returns The prefix for use with `authedRequest`\n   */\n  getExtendedProfileRequestPrefix() {\n    var _this52 = this;\n    return _asyncToGenerator(function* () {\n      if (yield _this52.doesServerSupportUnstableFeature(\"uk.tcpip.msc4133.stable\")) {\n        return ClientPrefix.V3;\n      }\n      return \"/_matrix/client/unstable/uk.tcpip.msc4133\";\n    })();\n  }\n\n  /**\n   * Fetch a user's *extended* profile, which may include additional keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param userId The user ID to fetch the profile of.\n   * @returns A set of keys to property values.\n   *\n   * @throws An error if the server does not support MSC4133.\n   * @throws A M_NOT_FOUND error if the profile could not be found.\n   */\n  getExtendedProfile(userId) {\n    var _this53 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this53.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      return _this53.http.authedRequest(Method.Get, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), undefined, undefined, {\n        prefix: yield _this53.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Fetch a specific key from the user's *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param userId The user ID to fetch the profile of.\n   * @param key The key of the property to fetch.\n   * @returns The property value.\n   *\n   * @throws An error if the server does not support MSC4133.\n   * @throws A M_NOT_FOUND error if the key was not set OR the profile could not be found.\n   */\n  getExtendedProfileProperty(userId, key) {\n    var _this54 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this54.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var profile = yield _this54.http.authedRequest(Method.Get, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, undefined, {\n        prefix: yield _this54.getExtendedProfileRequestPrefix()\n      });\n      return profile[key];\n    })();\n  }\n\n  /**\n   * Set a property on your *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param key The key of the property to set.\n   * @param value The value to set on the property.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  setExtendedProfileProperty(key, value) {\n    var _this55 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this55.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this55.getUserId();\n      yield _this55.http.authedRequest(Method.Put, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, {\n        [key]: value\n      }, {\n        prefix: yield _this55.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Delete a property on your *extended* profile.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param key The key of the property to delete.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  deleteExtendedProfileProperty(key) {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this56.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this56.getUserId();\n      yield _this56.http.authedRequest(Method.Delete, utils.encodeUri(\"/profile/$userId/$key\", {\n        $userId: userId,\n        $key: key\n      }), undefined, undefined, {\n        prefix: yield _this56.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Update multiple properties on your *extended* profile. This will\n   * merge with any existing keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param profile The profile object to merge with the existing profile.\n   * @returns The newly merged profile.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  patchExtendedProfile(profile) {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this57.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this57.getUserId();\n      return _this57.http.authedRequest(Method.Patch, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), {}, profile, {\n        prefix: yield _this57.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * Set multiple properties on your *extended* profile. This will completely\n   * replace the existing profile, removing any unspecified keys.\n   *\n   * @see https://github.com/tcpipuk/matrix-spec-proposals/blob/main/proposals/4133-extended-profiles.md\n   * @param profile The profile object to set.\n   *\n   * @throws An error if the server does not support MSC4133 OR the server disallows editing the user profile.\n   */\n  setExtendedProfile(profile) {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      if (!(yield _this58.doesServerSupportExtendedProfiles())) {\n        throw new Error(\"Server does not support extended profiles\");\n      }\n      var userId = _this58.getUserId();\n      yield _this58.http.authedRequest(Method.Put, utils.encodeUri(\"/profile/$userId\", {\n        $userId: userId\n      }), {}, profile, {\n        prefix: yield _this58.getExtendedProfileRequestPrefix()\n      });\n    })();\n  }\n\n  /**\n   * @returns Promise which resolves to a list of the user's threepids.\n   * @returns Rejects: with an error response.\n   */\n  getThreePids() {\n    return this.http.authedRequest(Method.Get, \"/account/3pid\");\n  }\n\n  /**\n   * Add a 3PID to your homeserver account. This API does not use an identity\n   * server, as the homeserver is expected to handle 3PID ownership validation.\n   *\n   * @param data - A object with 3PID validation data from having called\n   * `account/3pid/<medium>/requestToken` on the homeserver.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  addThreePidOnly(data) {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/add\";\n      return _this59.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * Bind a 3PID for discovery onto an identity server via the homeserver. The\n   * identity server handles 3PID ownership validation and the homeserver records\n   * the new binding to track where all 3PIDs for the account are bound.\n   *\n   * @param data - A object with 3PID validation data from having called\n   * `validate/<medium>/requestToken` on the identity server. It should also\n   * contain `id_server` and `id_access_token` fields as well.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  bindThreePid(data) {\n    var _this60 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/bind\";\n      return _this60.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * Unbind a 3PID for discovery on an identity server via the homeserver. The\n   * homeserver removes its record of the binding to keep an updated record of\n   * where all 3PIDs for the account are bound.\n   *\n   * @param medium - The threepid medium (eg. 'email')\n   * @param address - The threepid address (eg. 'bob\\@example.com')\n   *        this must be as returned by getThreePids.\n   * @returns Promise which resolves: on success\n   * @returns Rejects: with an error response.\n   */\n  unbindThreePid(medium, address\n  // eslint-disable-next-line camelcase\n  ) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      var path = \"/account/3pid/unbind\";\n      var data = {\n        medium,\n        address,\n        id_server: _this61.getIdentityServerUrl(true)\n      };\n      return _this61.http.authedRequest(Method.Post, path, undefined, data);\n    })();\n  }\n\n  /**\n   * @param medium - The threepid medium (eg. 'email')\n   * @param address - The threepid address (eg. 'bob\\@example.com')\n   *        this must be as returned by getThreePids.\n   * @returns Promise which resolves: The server response on success\n   *     (generally the empty JSON object)\n   * @returns Rejects: with an error response.\n   */\n  deleteThreePid(medium, address\n  // eslint-disable-next-line camelcase\n  ) {\n    var path = \"/account/3pid/delete\";\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      medium,\n      address\n    });\n  }\n\n  /**\n   * Make a request to change your password.\n   * @param newPassword - The new desired password.\n   * @param logoutDevices - Should all sessions be logged out after the password change. Defaults to true.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPassword(authDict, newPassword, logoutDevices) {\n    var path = \"/account/password\";\n    var data = {\n      auth: authDict,\n      new_password: newPassword,\n      logout_devices: logoutDevices\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, data);\n  }\n\n  /**\n   * Gets all devices recorded for the logged-in user\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  getDevices() {\n    return this.http.authedRequest(Method.Get, \"/devices\");\n  }\n\n  /**\n   * Gets specific device details for the logged-in user\n   * @param deviceId -  device to query\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  getDevice(deviceId) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    return this.http.authedRequest(Method.Get, path);\n  }\n\n  /**\n   * Update the given device\n   *\n   * @param deviceId -  device to update\n   * @param body -       body of request\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  // eslint-disable-next-line camelcase\n  setDeviceDetails(deviceId, body) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * Delete the given device\n   *\n   * @param deviceId -  device to delete\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  deleteDevice(deviceId, auth) {\n    var path = utils.encodeUri(\"/devices/$device_id\", {\n      $device_id: deviceId\n    });\n    var body = {};\n    if (auth) {\n      body.auth = auth;\n    }\n    return this.http.authedRequest(Method.Delete, path, undefined, body);\n  }\n\n  /**\n   * Delete multiple device\n   *\n   * @param devices - IDs of the devices to delete\n   * @param auth - Optional. Auth data to supply for User-Interactive auth.\n   * @returns Promise which resolves: result object\n   * @returns Rejects: with an error response.\n   */\n  deleteMultipleDevices(devices, auth) {\n    var body = {\n      devices\n    };\n    if (auth) {\n      body.auth = auth;\n    }\n    var path = \"/delete_devices\";\n    return this.http.authedRequest(Method.Post, path, undefined, body);\n  }\n\n  /**\n   * Gets all pushers registered for the logged-in user\n   *\n   * @returns Promise which resolves: Array of objects representing pushers\n   * @returns Rejects: with an error response.\n   */\n  getPushers() {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      var response = yield _this62.http.authedRequest(Method.Get, \"/pushers\");\n\n      // Migration path for clients that connect to a homeserver that does not support\n      // MSC3881 yet, see https://github.com/matrix-org/matrix-spec-proposals/blob/kerry/remote-push-toggle/proposals/3881-remote-push-notification-toggling.md#migration\n      if (!(yield _this62.doesServerSupportUnstableFeature(\"org.matrix.msc3881\"))) {\n        response.pushers = response.pushers.map(pusher => {\n          if (!pusher.hasOwnProperty(PUSHER_ENABLED.name)) {\n            pusher[PUSHER_ENABLED.name] = true;\n          }\n          return pusher;\n        });\n      }\n      return response;\n    })();\n  }\n\n  /**\n   * Adds a new pusher or updates an existing pusher\n   *\n   * @param pusher - Object representing a pusher\n   * @returns Promise which resolves: Empty json object on success\n   * @returns Rejects: with an error response.\n   */\n  setPusher(pusher) {\n    var path = \"/pushers/set\";\n    return this.http.authedRequest(Method.Post, path, undefined, pusher);\n  }\n\n  /**\n   * Removes an existing pusher\n   * @param pushKey - pushkey of pusher to remove\n   * @param appId - app_id of pusher to remove\n   * @returns Promise which resolves: Empty json object on success\n   * @returns Rejects: with an error response.\n   */\n  removePusher(pushKey, appId) {\n    var path = \"/pushers/set\";\n    var body = {\n      pushkey: pushKey,\n      app_id: appId,\n      kind: null // marks pusher for removal\n    };\n    return this.http.authedRequest(Method.Post, path, undefined, body);\n  }\n\n  /**\n   * Persists local notification settings\n   * @returns Promise which resolves: an empty object\n   * @returns Rejects: with an error response.\n   */\n  setLocalNotificationSettings(deviceId, notificationSettings) {\n    var key = \"\".concat(LOCAL_NOTIFICATION_SETTINGS_PREFIX.name, \".\").concat(deviceId);\n    return this.setAccountData(key, notificationSettings);\n  }\n\n  /**\n   * Get the push rules for the account from the server.\n   * @returns Promise which resolves to the push rules.\n   * @returns Rejects: with an error response.\n   */\n  getPushRules() {\n    return this.http.authedRequest(Method.Get, \"/pushrules/\").then(rules => {\n      this.setPushRules(rules);\n      return this.pushRules;\n    });\n  }\n\n  /**\n   * Update the push rules for the account. This should be called whenever\n   * updated push rules are available.\n   */\n  setPushRules(rules) {\n    // Fix-up defaults, if applicable.\n    this.pushRules = PushProcessor.rewriteDefaultRules(rules, this.getUserId());\n    // Pre-calculate any necessary caches.\n    this.pushProcessor.updateCachedPushRuleKeys(this.pushRules);\n  }\n\n  /**\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  addPushRule(scope, kind, ruleId, body) {\n    // NB. Scope not uri encoded because devices need the '/'\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * @returns Promise which resolves: an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  deletePushRule(scope, kind, ruleId) {\n    // NB. Scope not uri encoded because devices need the '/'\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Delete, path);\n  }\n\n  /**\n   * Enable or disable a push notification rule.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPushRuleEnabled(scope, kind, ruleId, enabled) {\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/enabled\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      enabled: enabled\n    });\n  }\n\n  /**\n   * Set the actions for a push notification rule.\n   * @returns Promise which resolves: to an empty object `{}`\n   * @returns Rejects: with an error response.\n   */\n  setPushRuleActions(scope, kind, ruleId, actions) {\n    var path = utils.encodeUri(\"/pushrules/\" + scope + \"/$kind/$ruleId/actions\", {\n      $kind: kind,\n      $ruleId: ruleId\n    });\n    return this.http.authedRequest(Method.Put, path, undefined, {\n      actions: actions\n    });\n  }\n\n  /**\n   * Perform a server-side search.\n   * @param params\n   * @param params.next_batch - the batch token to pass in the query string\n   * @param params.body - the JSON object to pass to the request body.\n   * @param abortSignal - optional signal used to cancel the http request.\n   * @returns Promise which resolves to the search response object.\n   * @returns Rejects: with an error response.\n   */\n  search(_ref10, abortSignal) {\n    var {\n      body,\n      next_batch: nextBatch\n    } = _ref10;\n    var queryParams = {};\n    if (nextBatch) {\n      queryParams.next_batch = nextBatch;\n    }\n    return this.http.authedRequest(Method.Post, \"/search\", queryParams, body, {\n      abortSignal\n    });\n  }\n\n  /**\n   * Upload keys\n   *\n   * @param content -  body of upload request\n   *\n   * @param opts - this method no longer takes any opts,\n   *  used to take opts.device_id but this was not removed from the spec as a redundant parameter\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  uploadKeysRequest(content, opts) {\n    return this.http.authedRequest(Method.Post, \"/keys/upload\", undefined, content);\n  }\n  uploadKeySignatures(content) {\n    return this.http.authedRequest(Method.Post, \"/keys/signatures/upload\", undefined, content);\n  }\n\n  /**\n   * Download device keys\n   *\n   * @param userIds -  list of users to get keys for\n   *\n   * @param token - sync token to pass in the query request, to help\n   *   the HS give the most recent results\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  downloadKeysForUsers(userIds) {\n    var {\n      token\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var content = {\n      device_keys: {}\n    };\n    if (token !== undefined) {\n      content.token = token;\n    }\n    userIds.forEach(u => {\n      content.device_keys[u] = [];\n    });\n    return this.http.authedRequest(Method.Post, \"/keys/query\", undefined, content);\n  }\n\n  /**\n   * Claim one-time keys\n   *\n   * @param devices -  a list of [userId, deviceId] pairs\n   *\n   * @param keyAlgorithm -  desired key type\n   *\n   * @param timeout - the time (in milliseconds) to wait for keys from remote\n   *     servers\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  claimOneTimeKeys(devices) {\n    var keyAlgorithm = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"signed_curve25519\";\n    var timeout = arguments.length > 2 ? arguments[2] : undefined;\n    var queries = {};\n    if (keyAlgorithm === undefined) {\n      keyAlgorithm = \"signed_curve25519\";\n    }\n    for (var [userId, _deviceId] of devices) {\n      var query = queries[userId] || {};\n      safeSet(queries, userId, query);\n      safeSet(query, _deviceId, keyAlgorithm);\n    }\n    var content = {\n      one_time_keys: queries\n    };\n    if (timeout) {\n      content.timeout = timeout;\n    }\n    var path = \"/keys/claim\";\n    return this.http.authedRequest(Method.Post, path, undefined, content);\n  }\n\n  /**\n   * Ask the server for a list of users who have changed their device lists\n   * between a pair of sync tokens\n   *\n   *\n   * @returns Promise which resolves: result object. Rejects: with\n   *     an error response ({@link MatrixError}).\n   */\n  getKeyChanges(oldToken, newToken) {\n    var qps = {\n      from: oldToken,\n      to: newToken\n    };\n    return this.http.authedRequest(Method.Get, \"/keys/changes\", qps);\n  }\n  uploadDeviceSigningKeys(auth, keys) {\n    // API returns empty object\n    var data = Object.assign({}, keys);\n    if (auth) Object.assign(data, {\n      auth\n    });\n    return this.http.authedRequest(Method.Post, \"/keys/device_signing/upload\", undefined, data, {\n      prefix: ClientPrefix.Unstable\n    });\n  }\n\n  /**\n   * Register with an identity server using the OpenID token from the user's\n   * Homeserver, which can be retrieved via\n   * {@link MatrixClient#getOpenIdToken}.\n   *\n   * Note that the `/account/register` endpoint (as well as IS authentication in\n   * general) was added as part of the v2 API version.\n   *\n   * @returns Promise which resolves: with object containing an Identity\n   * Server access token.\n   * @returns Rejects: with an error response.\n   */\n  registerWithIdentityServer(hsOpenIdToken) {\n    if (!this.idBaseUrl) {\n      throw new Error(\"No identity server base URL set\");\n    }\n    var uri = this.http.getUrl(\"/account/register\", undefined, IdentityPrefix.V2, this.idBaseUrl);\n    return this.http.requestOtherUrl(Method.Post, uri, hsOpenIdToken);\n  }\n\n  /**\n   * Requests an email verification token directly from an identity server.\n   *\n   * This API is used as part of binding an email for discovery on an identity\n   * server. The validation data that results should be passed to the\n   * `bindThreePid` method to complete the binding process.\n   *\n   * @param email - The email address to request a token for\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 It is recommended this be around 16 ASCII characters.\n   * @param sendAttempt - If an identity server sees a duplicate request\n   *                 with the same sendAttempt, it will not send another email.\n   *                 To request another email to be sent, use a larger value for\n   *                 the sendAttempt param as was used in the previous request.\n   * @param nextLink - Optional If specified, the client will be redirected\n   *                 to this link after validation.\n   * @param identityAccessToken - The `access_token` field of the identity\n   * server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: TODO\n   * @returns Rejects: with an error response.\n   * @throws Error if no identity server is set\n   */\n  requestEmailToken(email, clientSecret, sendAttempt, nextLink, identityAccessToken) {\n    var params = {\n      client_secret: clientSecret,\n      email: email,\n      send_attempt: sendAttempt === null || sendAttempt === void 0 ? void 0 : sendAttempt.toString()\n    };\n    if (nextLink) {\n      params.next_link = nextLink;\n    }\n    return this.http.idServerRequest(Method.Post, \"/validate/email/requestToken\", params, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Requests a MSISDN verification token directly from an identity server.\n   *\n   * This API is used as part of binding a MSISDN for discovery on an identity\n   * server. The validation data that results should be passed to the\n   * `bindThreePid` method to complete the binding process.\n   *\n   * @param phoneCountry - The ISO 3166-1 alpha-2 code for the country in\n   *                 which phoneNumber should be parsed relative to.\n   * @param phoneNumber - The phone number, in national or international\n   *                 format\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 It is recommended this be around 16 ASCII characters.\n   * @param sendAttempt - If an identity server sees a duplicate request\n   *                 with the same sendAttempt, it will not send another SMS.\n   *                 To request another SMS to be sent, use a larger value for\n   *                 the sendAttempt param as was used in the previous request.\n   * @param nextLink - Optional If specified, the client will be redirected\n   *                 to this link after validation.\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves to an object with a sid string\n   * @returns Rejects: with an error response.\n   * @throws Error if no identity server is set\n   */\n  requestMsisdnToken(phoneCountry, phoneNumber, clientSecret, sendAttempt, nextLink, identityAccessToken) {\n    var params = {\n      client_secret: clientSecret,\n      country: phoneCountry,\n      phone_number: phoneNumber,\n      send_attempt: sendAttempt === null || sendAttempt === void 0 ? void 0 : sendAttempt.toString()\n    };\n    if (nextLink) {\n      params.next_link = nextLink;\n    }\n    return this.http.idServerRequest(Method.Post, \"/validate/msisdn/requestToken\", params, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Submits a MSISDN token to the identity server\n   *\n   * This is used when submitting the code sent by SMS to a phone number.\n   * The identity server has an equivalent API for email but the js-sdk does\n   * not expose this, since email is normally validated by the user clicking\n   * a link rather than entering a code.\n   *\n   * @param sid - The sid given in the response to requestToken\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 This must be the same value submitted in the requestToken call.\n   * @param msisdnToken - The MSISDN token, as entered by the user.\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   * Some legacy identity servers had no authentication here.\n   *\n   * @returns Promise which resolves: Object, containing success boolean.\n   * @returns Rejects: with an error response.\n   * @throws Error if No identity server is set\n   */\n  submitMsisdnToken(sid, clientSecret, msisdnToken, identityAccessToken) {\n    var params = {\n      sid: sid,\n      client_secret: clientSecret,\n      token: msisdnToken\n    };\n    return this.http.idServerRequest(Method.Post, \"/validate/msisdn/submitToken\", params, IdentityPrefix.V2, identityAccessToken !== null && identityAccessToken !== void 0 ? identityAccessToken : undefined);\n  }\n\n  /**\n   * Submits a MSISDN token to an arbitrary URL.\n   *\n   * This is used when submitting the code sent by SMS to a phone number in the\n   * newer 3PID flow where the homeserver validates 3PID ownership (as part of\n   * `requestAdd3pidMsisdnToken`). The homeserver response may include a\n   * `submit_url` to specify where the token should be sent, and this helper can\n   * be used to pass the token to this URL.\n   *\n   * @param url - The URL to submit the token to\n   * @param sid - The sid given in the response to requestToken\n   * @param clientSecret - A secret binary string generated by the client.\n   *                 This must be the same value submitted in the requestToken call.\n   * @param msisdnToken - The MSISDN token, as entered by the user.\n   *\n   * @returns Promise which resolves: Object, containing success boolean.\n   * @returns Rejects: with an error response.\n   */\n  submitMsisdnTokenOtherUrl(url, sid, clientSecret, msisdnToken) {\n    var params = {\n      sid: sid,\n      client_secret: clientSecret,\n      token: msisdnToken\n    };\n    return this.http.requestOtherUrl(Method.Post, url, params);\n  }\n\n  /**\n   * Gets the V2 hashing information from the identity server. Primarily useful for\n   * lookups.\n   * @param identityAccessToken - The access token for the identity server.\n   * @returns The hashing information for the identity server.\n   */\n  getIdentityHashDetails(identityAccessToken) {\n    return this.http.idServerRequest(Method.Get, \"/hash_details\", undefined, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Performs a hashed lookup of addresses against the identity server. This is\n   * only supported on identity servers which have at least the version 2 API.\n   * @param addressPairs - An array of 2 element arrays.\n   * The first element of each pair is the address, the second is the 3PID medium.\n   * Eg: `[\"email@example.org\", \"email\"]`\n   * @param identityAccessToken - The access token for the identity server.\n   * @returns A collection of address mappings to\n   * found MXIDs. Results where no user could be found will not be listed.\n   */\n  identityHashedLookup(addressPairs, identityAccessToken) {\n    var _this63 = this;\n    return _asyncToGenerator(function* () {\n      var params = {\n        // addresses: [\"email@example.org\", \"10005550000\"],\n        // algorithm: \"sha256\",\n        // pepper: \"abc123\"\n      };\n\n      // Get hash information first before trying to do a lookup\n      var hashes = yield _this63.getIdentityHashDetails(identityAccessToken);\n      if (!hashes || !hashes[\"lookup_pepper\"] || !hashes[\"algorithms\"]) {\n        throw new Error(\"Unsupported identity server: bad response\");\n      }\n      params[\"pepper\"] = hashes[\"lookup_pepper\"];\n      var localMapping = {\n        // hashed identifier => plain text address\n        // For use in this function's return format\n      };\n\n      // When picking an algorithm, we pick the hashed over no hashes\n      if (hashes[\"algorithms\"].includes(\"sha256\")) {\n        params[\"addresses\"] = yield Promise.all(addressPairs.map(/*#__PURE__*/function () {\n          var _ref11 = _asyncToGenerator(function* (p) {\n            var addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n            var med = p[1].toLowerCase();\n            var hashBuffer = yield sha256(\"\".concat(addr, \" \").concat(med, \" \").concat(params[\"pepper\"]));\n            var hashed = encodeUnpaddedBase64Url(hashBuffer);\n\n            // Map the hash to a known (case-sensitive) address. We use the case\n            // sensitive version because the caller might be expecting that.\n            localMapping[hashed] = p[0];\n            return hashed;\n          });\n          return function (_x4) {\n            return _ref11.apply(this, arguments);\n          };\n        }()));\n        params[\"algorithm\"] = \"sha256\";\n      } else if (hashes[\"algorithms\"].includes(\"none\")) {\n        params[\"addresses\"] = addressPairs.map(p => {\n          var addr = p[0].toLowerCase(); // lowercase to get consistent hashes\n          var med = p[1].toLowerCase();\n          var unhashed = \"\".concat(addr, \" \").concat(med);\n          // Map the unhashed values to a known (case-sensitive) address. We use\n          // the case-sensitive version because the caller might be expecting that.\n          localMapping[unhashed] = p[0];\n          return unhashed;\n        });\n        params[\"algorithm\"] = \"none\";\n      } else {\n        throw new Error(\"Unsupported identity server: unknown hash algorithm\");\n      }\n      var response = yield _this63.http.idServerRequest(Method.Post, \"/lookup\", params, IdentityPrefix.V2, identityAccessToken);\n      if (!(response !== null && response !== void 0 && response[\"mappings\"])) return []; // no results\n\n      var foundAddresses = [];\n      for (var hashed of Object.keys(response[\"mappings\"])) {\n        var mxid = response[\"mappings\"][hashed];\n        var plainAddress = localMapping[hashed];\n        if (!plainAddress) {\n          throw new Error(\"Identity server returned more results than expected\");\n        }\n        foundAddresses.push({\n          address: plainAddress,\n          mxid\n        });\n      }\n      return foundAddresses;\n    })();\n  }\n\n  /**\n   * Looks up the public Matrix ID mapping for a given 3rd party\n   * identifier from the identity server\n   *\n   * @param medium - The medium of the threepid, eg. 'email'\n   * @param address - The textual address of the threepid\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: A threepid mapping\n   *                                 object or the empty object if no mapping\n   *                                 exists\n   * @returns Rejects: with an error response.\n   */\n  lookupThreePid(medium, address, identityAccessToken) {\n    var _this64 = this;\n    return _asyncToGenerator(function* () {\n      // Note: we're using the V2 API by calling this function, but our\n      // function contract requires a V1 response. We therefore have to\n      // convert it manually.\n      var response = yield _this64.identityHashedLookup([[address, medium]], identityAccessToken);\n      var result = response.find(p => p.address === address);\n      if (!result) {\n        return {};\n      }\n      var mapping = {\n        address,\n        medium,\n        mxid: result.mxid\n\n        // We can't reasonably fill these parameters:\n        // not_before\n        // not_after\n        // ts\n        // signatures\n      };\n      return mapping;\n    })();\n  }\n\n  /**\n   * Looks up the public Matrix ID mappings for multiple 3PIDs.\n   *\n   * @param query - Array of arrays containing\n   * [medium, address]\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: Lookup results from IS.\n   * @returns Rejects: with an error response.\n   */\n  bulkLookupThreePids(query, identityAccessToken) {\n    var _this65 = this;\n    return _asyncToGenerator(function* () {\n      // Note: we're using the V2 API by calling this function, but our\n      // function contract requires a V1 response. We therefore have to\n      // convert it manually.\n      var response = yield _this65.identityHashedLookup(\n      // We have to reverse the query order to get [address, medium] pairs\n      query.map(p => [p[1], p[0]]), identityAccessToken);\n      var v1results = [];\n      var _loop2 = function* _loop2(mapping) {\n        var originalQuery = query.find(p => p[1] === mapping.address);\n        if (!originalQuery) {\n          throw new Error(\"Identity sever returned unexpected results\");\n        }\n        v1results.push([originalQuery[0],\n        // medium\n        mapping.address, mapping.mxid]);\n      };\n      for (var mapping of response) {\n        yield* _loop2(mapping);\n      }\n      return {\n        threepids: v1results\n      };\n    })();\n  }\n\n  /**\n   * Get account info from the identity server. This is useful as a neutral check\n   * to verify that other APIs are likely to approve access by testing that the\n   * token is valid, terms have been agreed, etc.\n   *\n   * @param identityAccessToken - The `access_token` field of the Identity\n   * Server `/account/register` response (see {@link registerWithIdentityServer}).\n   *\n   * @returns Promise which resolves: an object with account info.\n   * @returns Rejects: with an error response.\n   */\n  getIdentityAccount(identityAccessToken) {\n    return this.http.idServerRequest(Method.Get, \"/account\", undefined, IdentityPrefix.V2, identityAccessToken);\n  }\n\n  /**\n   * Send an event to a specific list of devices.\n   * This is a low-level API that simply wraps the HTTP API\n   * call to send to-device messages. We recommend using\n   * queueToDevice() which is a higher level API.\n   *\n   * @param eventType -  type of event to send\n   *    content to send. Map from user_id to device_id to content object.\n   * @param txnId -     transaction id. One will be made up if not\n   *    supplied.\n   * @returns Promise which resolves: to an empty object `{}`\n   */\n  sendToDevice(eventType, contentMap, txnId) {\n    var path = utils.encodeUri(\"/sendToDevice/$eventType/$txnId\", {\n      $eventType: eventType,\n      $txnId: txnId ? txnId : this.makeTxnId()\n    });\n    var body = {\n      messages: utils.recursiveMapToObject(contentMap)\n    };\n    var targets = new Map();\n    for (var [userId, deviceMessages] of contentMap) {\n      targets.set(userId, Array.from(deviceMessages.keys()));\n    }\n    this.logger.debug(\"PUT \".concat(path), targets);\n    return this.http.authedRequest(Method.Put, path, undefined, body);\n  }\n\n  /**\n   * This will encrypt the payload for all devices in the list and will queue it.\n   * The type of the sent to-device message will be `m.room.encrypted`.\n   * @param eventType - The type of event to send\n   * @param devices - The list of devices to send the event to.\n   * @param payload - The payload to send. This will be encrypted.\n   * @returns Promise which resolves once queued there is no error feedback when sending fails.\n   */\n  encryptAndSendToDevice(eventType, devices, payload) {\n    var _this66 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this66.cryptoBackend) {\n        throw new Error(\"Cannot encrypt to device event, your client does not support encryption.\");\n      }\n      var batch = yield _this66.cryptoBackend.encryptToDeviceMessages(eventType, devices, payload);\n\n      // TODO The batch mechanism removes all possibility to get error feedbacks..\n      // We might want instead to do the API call directly and pass the errors back.\n      yield _this66.queueToDevice(batch);\n    })();\n  }\n\n  /**\n   * Sends events directly to specific devices using Matrix's to-device\n   * messaging system. The batch will be split up into appropriately sized\n   * batches for sending and stored in the store so they can be retried\n   * later if they fail to send. Retries will happen automatically.\n   * @param batch - The to-device messages to send\n   */\n  queueToDevice(batch) {\n    return this.toDeviceMessageQueue.queueBatch(batch);\n  }\n\n  /**\n   * Get the third party protocols that can be reached using\n   * this HS\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyProtocols() {\n    return this.http.authedRequest(Method.Get, \"/thirdparty/protocols\").then(response => {\n      // sanity check\n      if (!response || typeof response !== \"object\") {\n        throw new Error(\"/thirdparty/protocols did not return an object: \".concat(response));\n      }\n      return response;\n    });\n  }\n\n  /**\n   * Get information on how a specific place on a third party protocol\n   * may be reached.\n   * @param protocol - The protocol given in getThirdpartyProtocols()\n   * @param params - Protocol-specific parameters, as given in the\n   *                        response to getThirdpartyProtocols()\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyLocation(protocol, params) {\n    var path = utils.encodeUri(\"/thirdparty/location/$protocol\", {\n      $protocol: protocol\n    });\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n\n  /**\n   * Get information on how a specific user on a third party protocol\n   * may be reached.\n   * @param protocol - The protocol given in getThirdpartyProtocols()\n   * @param params - Protocol-specific parameters, as given in the\n   *                        response to getThirdpartyProtocols()\n   * @returns Promise which resolves to the result object\n   */\n  getThirdpartyUser(protocol, params) {\n    var path = utils.encodeUri(\"/thirdparty/user/$protocol\", {\n      $protocol: protocol\n    });\n    return this.http.authedRequest(Method.Get, path, params);\n  }\n  getTerms(serviceType, baseUrl) {\n    var url = this.termsUrlForService(serviceType, baseUrl);\n    return this.http.requestOtherUrl(Method.Get, url);\n  }\n  agreeToTerms(serviceType, baseUrl, accessToken, termsUrls) {\n    var url = this.termsUrlForService(serviceType, baseUrl);\n    var headers = {\n      Authorization: \"Bearer \" + accessToken\n    };\n    return this.http.requestOtherUrl(Method.Post, url, {\n      user_accepts: termsUrls\n    }, {\n      headers\n    });\n  }\n\n  /**\n   * Reports an event as inappropriate to the server, which may then notify the appropriate people.\n   * @param roomId - The room in which the event being reported is located.\n   * @param eventId - The event to report.\n   * @param score - The score to rate this content as where -100 is most offensive and 0 is inoffensive.\n   * @param reason - The reason the content is being reported. May be blank.\n   * @returns Promise which resolves to an empty object if successful\n   */\n  reportEvent(roomId, eventId, score, reason) {\n    var path = utils.encodeUri(\"/rooms/$roomId/report/$eventId\", {\n      $roomId: roomId,\n      $eventId: eventId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      score,\n      reason\n    });\n  }\n\n  /**\n   * Reports a room as inappropriate to the server, which may then notify the appropriate people.\n   *\n   * This API was introduced in Matrix v1.13.\n   *\n   * @param roomId - The room being reported.\n   * @param reason - The reason the room is being reported. May be blank.\n   * @returns Promise which resolves to an empty object if successful\n   */\n  reportRoom(roomId, reason) {\n    var path = utils.encodeUri(\"/rooms/$roomId/report\", {\n      $roomId: roomId\n    });\n    return this.http.authedRequest(Method.Post, path, undefined, {\n      reason\n    });\n  }\n\n  /**\n   * Fetches or paginates a room hierarchy asmatrix-js-sdk/spec/unit/matrix-client.spec.ts defined by MSC2946.\n   * Falls back gracefully to sourcing its data from `getSpaceSummary` if this API is not yet supported by the server.\n   * @param roomId - The ID of the space-room to use as the root of the summary.\n   * @param limit - The maximum number of rooms to return per page.\n   * @param maxDepth - The maximum depth in the tree from the root room to return.\n   * @param suggestedOnly - Whether to only return rooms with suggested=true.\n   * @param fromToken - The opaque token to paginate a previous request.\n   * @returns the response, with next_batch & rooms fields.\n   */\n  getRoomHierarchy(roomId, limit, maxDepth) {\n    var suggestedOnly = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    var fromToken = arguments.length > 4 ? arguments[4] : undefined;\n    var path = utils.encodeUri(\"/rooms/$roomId/hierarchy\", {\n      $roomId: roomId\n    });\n    var queryParams = {\n      suggested_only: String(suggestedOnly),\n      max_depth: maxDepth === null || maxDepth === void 0 ? void 0 : maxDepth.toString(),\n      from: fromToken,\n      limit: limit === null || limit === void 0 ? void 0 : limit.toString()\n    };\n    return this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n      prefix: ClientPrefix.V1\n    }).catch(e => {\n      if (e.errcode === \"M_UNRECOGNIZED\") {\n        // fall back to the prefixed hierarchy API.\n        return this.http.authedRequest(Method.Get, path, queryParams, undefined, {\n          prefix: \"/_matrix/client/unstable/org.matrix.msc2946\"\n        });\n      }\n      throw e;\n    });\n  }\n\n  /**\n   * Creates a new file tree space with the given name. The client will pick\n   * defaults for how it expects to be able to support the remaining API offered\n   * by the returned class.\n   *\n   * Note that this is UNSTABLE and may have breaking changes without notice.\n   * @param name - The name of the tree space.\n   * @returns Promise which resolves to the created space.\n   */\n  unstableCreateFileTree(name) {\n    var _this67 = this;\n    return _asyncToGenerator(function* () {\n      var {\n        room_id: roomId\n      } = yield _this67.createRoom({\n        name: name,\n        preset: Preset.PrivateChat,\n        power_level_content_override: _objectSpread(_objectSpread({}, DEFAULT_TREE_POWER_LEVELS_TEMPLATE), {}, {\n          users: {\n            [_this67.getUserId()]: 100\n          }\n        }),\n        creation_content: {\n          [RoomCreateTypeField]: RoomType.Space\n        },\n        initial_state: [{\n          type: UNSTABLE_MSC3088_PURPOSE.name,\n          state_key: UNSTABLE_MSC3089_TREE_SUBTYPE.name,\n          content: {\n            [UNSTABLE_MSC3088_ENABLED.name]: true\n          }\n        }, {\n          type: EventType.RoomEncryption,\n          state_key: \"\",\n          content: {\n            algorithm: \"m.megolm.v1.aes-sha2\"\n          }\n        }]\n      });\n      return new MSC3089TreeSpace(_this67, roomId);\n    })();\n  }\n\n  /**\n   * Gets a reference to a tree space, if the room ID given is a tree space. If the room\n   * does not appear to be a tree space then null is returned.\n   *\n   * Note that this is UNSTABLE and may have breaking changes without notice.\n   * @param roomId - The room ID to get a tree space reference for.\n   * @returns The tree space, or null if not a tree space.\n   */\n  unstableGetFileTreeSpace(roomId) {\n    var _purposeEvent$getCont, _createEvent$getConte;\n    var room = this.getRoom(roomId);\n    if ((room === null || room === void 0 ? void 0 : room.getMyMembership()) !== KnownMembership.Join) return null;\n    var createEvent = room.currentState.getStateEvents(EventType.RoomCreate, \"\");\n    var purposeEvent = room.currentState.getStateEvents(UNSTABLE_MSC3088_PURPOSE.name, UNSTABLE_MSC3089_TREE_SUBTYPE.name);\n    if (!createEvent) throw new Error(\"Expected single room create event\");\n    if (!(purposeEvent !== null && purposeEvent !== void 0 && (_purposeEvent$getCont = purposeEvent.getContent()) !== null && _purposeEvent$getCont !== void 0 && _purposeEvent$getCont[UNSTABLE_MSC3088_ENABLED.name])) return null;\n    if (((_createEvent$getConte = createEvent.getContent()) === null || _createEvent$getConte === void 0 ? void 0 : _createEvent$getConte[RoomCreateTypeField]) !== RoomType.Space) return null;\n    return new MSC3089TreeSpace(this, roomId);\n  }\n\n  /**\n   * Perform a single MSC3575 sliding sync request.\n   * @param req - The request to make.\n   * @param proxyBaseUrl - The base URL for the sliding sync proxy.\n   * @param abortSignal - Optional signal to abort request mid-flight.\n   * @returns The sliding sync response, or a standard error.\n   * @throws on non 2xx status codes with an object with a field \"httpStatus\":number.\n   */\n  slidingSync(req, proxyBaseUrl, abortSignal) {\n    var qps = {};\n    if (req.pos) {\n      qps.pos = req.pos;\n      delete req.pos;\n    }\n    if (req.timeout) {\n      qps.timeout = req.timeout;\n      delete req.timeout;\n    }\n    var clientTimeout = req.clientTimeout;\n    delete req.clientTimeout;\n    return this.http.authedRequest(Method.Post, \"/sync\", qps, req, {\n      prefix: \"/_matrix/client/unstable/org.matrix.simplified_msc3575\",\n      baseUrl: proxyBaseUrl,\n      localTimeoutMs: clientTimeout,\n      abortSignal\n    });\n  }\n\n  /**\n   * A helper to determine thread support\n   * @returns a boolean to determine if threads are enabled\n   */\n  supportsThreads() {\n    var _this$clientOpts4;\n    return ((_this$clientOpts4 = this.clientOpts) === null || _this$clientOpts4 === void 0 ? void 0 : _this$clientOpts4.threadSupport) || false;\n  }\n\n  /**\n   * A helper to determine intentional mentions support\n   * @returns a boolean to determine if intentional mentions are enabled on the server\n   * @experimental\n   */\n  supportsIntentionalMentions() {\n    return this.canSupport.get(Feature.IntentionalMentions) !== ServerSupport.Unsupported;\n  }\n\n  /**\n   * Fetches the summary of a room as defined by an initial version of MSC3266 and implemented in Synapse\n   * Proposed at https://github.com/matrix-org/matrix-doc/pull/3266\n   * @param roomIdOrAlias - The ID or alias of the room to get the summary of.\n   * @param via - The list of servers which know about the room if only an ID was provided.\n   */\n  getRoomSummary(roomIdOrAlias, via) {\n    var _this68 = this;\n    return _asyncToGenerator(function* () {\n      var paramOpts = {\n        prefix: \"/_matrix/client/unstable/im.nheko.summary\"\n      };\n      try {\n        var path = utils.encodeUri(\"/summary/$roomid\", {\n          $roomid: roomIdOrAlias\n        });\n        return yield _this68.http.authedRequest(Method.Get, path, {\n          via\n        }, undefined, paramOpts);\n      } catch (e) {\n        if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n          var _path = utils.encodeUri(\"/rooms/$roomid/summary\", {\n            $roomid: roomIdOrAlias\n          });\n          return yield _this68.http.authedRequest(Method.Get, _path, {\n            via\n          }, undefined, paramOpts);\n        } else {\n          throw e;\n        }\n      }\n    })();\n  }\n\n  /**\n   * Processes a list of threaded events and adds them to their respective timelines\n   * @param room - the room the adds the threaded events\n   * @param threadedEvents - an array of the threaded events\n   * @param toStartOfTimeline - the direction in which we want to add the events\n   */\n  processThreadEvents(room, threadedEvents, toStartOfTimeline) {\n    room.processThreadedEvents(threadedEvents, toStartOfTimeline);\n  }\n\n  /**\n   * Processes a list of thread roots and creates a thread model\n   * @param room - the room to create the threads in\n   * @param threadedEvents - an array of thread roots\n   * @param toStartOfTimeline - the direction\n   */\n  processThreadRoots(room, threadedEvents, toStartOfTimeline) {\n    if (!this.supportsThreads()) return;\n    room.processThreadRoots(threadedEvents, toStartOfTimeline);\n  }\n  processBeaconEvents(room, events) {\n    this.processAggregatedTimelineEvents(room, events);\n  }\n\n  /**\n   * Calls aggregation functions for event types that are aggregated\n   * Polls and location beacons\n   * @param room - room the events belong to\n   * @param events - timeline events to be processed\n   * @returns\n   */\n  processAggregatedTimelineEvents(room, events) {\n    if (!(events !== null && events !== void 0 && events.length)) return;\n    if (!room) return;\n    room.currentState.processBeaconEvents(events, this);\n    room.processPollEvents(events);\n  }\n\n  /**\n   * Fetches information about the user for the configured access token.\n   */\n  whoami() {\n    var _this69 = this;\n    return _asyncToGenerator(function* () {\n      return _this69.http.authedRequest(Method.Get, \"/account/whoami\");\n    })();\n  }\n\n  /**\n   * Find the event_id closest to the given timestamp in the given direction.\n   * @returns Resolves: A promise of an object containing the event_id and\n   *    origin_server_ts of the closest event to the timestamp in the given direction\n   * @returns Rejects: when the request fails (module:http-api.MatrixError)\n   */\n  timestampToEvent(roomId, timestamp, dir) {\n    var _this70 = this;\n    return _asyncToGenerator(function* () {\n      var path = utils.encodeUri(\"/rooms/$roomId/timestamp_to_event\", {\n        $roomId: roomId\n      });\n      var queryParams = {\n        ts: timestamp.toString(),\n        dir: dir\n      };\n      try {\n        return yield _this70.http.authedRequest(Method.Get, path, queryParams, undefined, {\n          prefix: ClientPrefix.V1\n        });\n      } catch (err) {\n        // Fallback to the prefixed unstable endpoint. Since the stable endpoint is\n        // new, we should also try the unstable endpoint before giving up. We can\n        // remove this fallback request in a year (remove after 2023-11-28).\n        if (err.errcode === \"M_UNRECOGNIZED\" && (\n        // XXX: The 400 status code check should be removed in the future\n        // when Synapse is compliant with MSC3743.\n        err.httpStatus === 400 ||\n        // This the correct standard status code for an unsupported\n        // endpoint according to MSC3743. Not Found and Method Not Allowed\n        // both indicate that this endpoint+verb combination is\n        // not supported.\n        err.httpStatus === 404 || err.httpStatus === 405)) {\n          return yield _this70.http.authedRequest(Method.Get, path, queryParams, undefined, {\n            prefix: \"/_matrix/client/unstable/org.matrix.msc3030\"\n          });\n        }\n        throw err;\n      }\n    })();\n  }\n\n  /**\n   * Get the OIDC issuer responsible for authentication on this server, if any\n   * @returns Resolves: A promise of an object containing the OIDC issuer if configured\n   * @returns Rejects: when the request fails (module:http-api.MatrixError)\n   * @experimental - part of MSC2965\n   * @deprecated in favour of getAuthMetadata\n   */\n  getAuthIssuer() {\n    var _this71 = this;\n    return _asyncToGenerator(function* () {\n      return _this71.http.request(Method.Get, \"/auth_issuer\", undefined, undefined, {\n        prefix: ClientPrefix.Unstable + \"/org.matrix.msc2965\"\n      });\n    })();\n  }\n\n  /**\n   * Discover and validate delegated auth configuration\n   * - delegated auth issuer openid-configuration is reachable\n   * - delegated auth issuer openid-configuration is configured correctly for us\n   * Fetches /auth_metadata falling back to legacy implementation using /auth_issuer followed by\n   * https://oidc-issuer.example.com/.well-known/openid-configuration and other files linked therein.\n   * When successful, validated metadata is returned\n   * @returns validated authentication metadata and optionally signing keys\n   * @throws when delegated auth config is invalid or unreachable\n   * @experimental - part of MSC2965\n   */\n  getAuthMetadata() {\n    var _this72 = this;\n    return _asyncToGenerator(function* () {\n      var authMetadata;\n      try {\n        authMetadata = yield _this72.http.request(Method.Get, \"/auth_metadata\", undefined, undefined, {\n          prefix: ClientPrefix.Unstable + \"/org.matrix.msc2965\"\n        });\n      } catch (e) {\n        if (e instanceof MatrixError && e.errcode === \"M_UNRECOGNIZED\") {\n          var {\n            issuer\n          } = yield _this72.getAuthIssuer();\n          return discoverAndValidateOIDCIssuerWellKnown(issuer);\n        }\n        throw e;\n      }\n      return validateAuthMetadataAndKeys(authMetadata);\n    })();\n  }\n}\n_defineProperty(MatrixClient, \"RESTORE_BACKUP_ERROR_BAD_KEY\", \"RESTORE_BACKUP_ERROR_BAD_KEY\");\nfunction getUnstableDelayQueryOpts(delayOpts) {\n  return Object.fromEntries(Object.entries(delayOpts).map(_ref12 => {\n    var [k, v] = _ref12;\n    return [\"\".concat(UNSTABLE_MSC4140_DELAYED_EVENTS, \".\").concat(k), v];\n  }));\n}\n\n/**\n * recalculates an accurate notifications count on event decryption.\n * Servers do not have enough knowledge about encrypted events to calculate an\n * accurate notification_count\n */\nexport function fixNotificationCountOnDecryption(cli, event) {\n  var _actions$tweaks;\n  var ourUserId = cli.getUserId();\n  var eventId = event.getId();\n  var room = cli.getRoom(event.getRoomId());\n  if (!room || !ourUserId || !eventId) return;\n\n  // Due to threads, we can get relation events (eg. edits & reactions) that never get\n  // added to a timeline and so cannot be found in their own room (their edit / reaction\n  // still applies to the event it needs to, so it doesn't matter too much). However, if\n  // we try to process notification about this event, we'll get very confused because we\n  // won't be able to find the event in the room, so will assume it must be unread, even\n  // if it's actually read. We therefore skip anything that isn't in the room. This isn't\n  // *great*, so if we can fix the homeless events (eg. with MSC4023) then we should probably\n  // remove this workaround.\n  if (!room.findEventById(eventId)) {\n    logger.info(\"Decrypted event \".concat(event.getId(), \" is not in room \").concat(room.roomId, \": ignoring\"));\n    return;\n  }\n  var isThreadEvent = !!event.threadRootId && !event.isThreadRoot;\n  var hasReadEvent;\n  if (isThreadEvent) {\n    var thread = room.getThread(event.threadRootId);\n    hasReadEvent = thread ? thread.hasUserReadEvent(ourUserId, eventId) :\n    // If the thread object does not exist in the room yet, we don't\n    // want to calculate notification for this event yet. We have not\n    // restored the read receipts yet and can't accurately calculate\n    // notifications at this stage.\n    //\n    // This issue can likely go away when MSC3874 is implemented\n    true;\n  } else {\n    hasReadEvent = room.hasUserReadEvent(ourUserId, eventId);\n  }\n  if (hasReadEvent) {\n    // If the event has been read, ignore it.\n    return;\n  }\n  var actions = cli.getPushActionsForEvent(event, true);\n\n  // Ensure the unread counts are kept up to date if the event is encrypted\n  // We also want to make sure that the notification count goes up if we already\n  // have encrypted events to avoid other code from resetting 'highlight' to zero.\n  var newHighlight = !!(actions !== null && actions !== void 0 && (_actions$tweaks = actions.tweaks) !== null && _actions$tweaks !== void 0 && _actions$tweaks.highlight);\n  if (newHighlight) {\n    // TODO: Handle mentions received while the client is offline\n    // See also https://github.com/vector-im/element-web/issues/9069\n    var newCount = room.getUnreadCountForEventContext(NotificationCountType.Highlight, event) + 1;\n    if (isThreadEvent) {\n      room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Highlight, newCount);\n    } else {\n      room.setUnreadNotificationCount(NotificationCountType.Highlight, newCount);\n    }\n  }\n\n  // `notify` is used in practice for incrementing the total count\n  var newNotify = !!(actions !== null && actions !== void 0 && actions.notify);\n\n  // The room total count is NEVER incremented by the server for encrypted rooms. We basically ignore\n  // the server here as it's always going to tell us to increment for encrypted events.\n  if (newNotify) {\n    // Total count is used to typically increment a room notification counter, but not loudly highlight it.\n    var _newCount = room.getUnreadCountForEventContext(NotificationCountType.Total, event) + 1;\n    if (isThreadEvent) {\n      room.setThreadUnreadNotificationCount(event.threadRootId, NotificationCountType.Total, _newCount);\n    } else {\n      room.setUnreadNotificationCount(NotificationCountType.Total, _newCount);\n    }\n  }\n}\n\n/**\n * Given an event, figure out the thread ID we should use for it in a receipt.\n *\n * This will either be \"main\", or event.threadRootId. For the thread root, or\n * e.g. reactions to the thread root, this will be main. For events inside the\n * thread, or e.g. reactions to them, this will be event.threadRootId.\n *\n * (Exported for test.)\n */\nexport function threadIdForReceipt(event) {\n  return inMainTimelineForReceipt(event) ? MAIN_ROOM_TIMELINE : event.threadRootId;\n}\n\n/**\n * a) True for non-threaded messages, thread roots and non-thread relations to thread roots.\n * b) False for messages with thread relations to the thread root.\n * c) False for messages with any kind of relation to a message from case b.\n *\n * Note: true for redactions of messages that are in threads. Redacted messages\n * are not really in threads (because their relations are gone), so if they look\n * like they are in threads, that is a sign of a bug elsewhere. (At time of\n * writing, this bug definitely exists - messages are not moved to another\n * thread when they are redacted.)\n *\n * @returns true if this event is considered to be in the main timeline as far\n *               as receipts are concerned.\n */\nexport function inMainTimelineForReceipt(event) {\n  if (!event.threadRootId) {\n    // Not in a thread: then it is in the main timeline\n    return true;\n  }\n  if (event.isThreadRoot) {\n    // Thread roots are in the main timeline. Note: the spec is ambiguous (or\n    // wrong) on this - see\n    // https://github.com/matrix-org/matrix-spec-proposals/pull/4037\n    return true;\n  }\n  if (!event.isRelation()) {\n    // If it's not related to anything, it can't be related via a chain of\n    // relations to a thread root.\n    //\n    // Note: this is a bug, because how does it have a threadRootId if it is\n    // neither a thread root, nor related to one?\n    logger.warn(\"Event is not a relation or a thread root, but still has a threadRootId! id=\".concat(event.getId()));\n    return true;\n  }\n  if (event.isRelation(THREAD_RELATION_TYPE.name)) {\n    // It's a message in a thread - definitely not in the main timeline.\n    return false;\n  }\n  var isRelatedToRoot = event.relationEventId === event.threadRootId;\n\n  // If it's related to the thread root (and we already know it's not a thread\n  // relation) then it's in the main timeline. If it's related to something\n  // else, then it's in the thread (because it has a thread ID).\n  return isRelatedToRoot;\n}\n//# sourceMappingURL=client.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetEventCapability = exports.EventKind = exports.EventDirection = void 0;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar EventKind = /*#__PURE__*/function (EventKind) {\n  EventKind[\"Event\"] = \"event\";\n  EventKind[\"State\"] = \"state_event\";\n  EventKind[\"ToDevice\"] = \"to_device\";\n  EventKind[\"RoomAccount\"] = \"room_account\";\n  return EventKind;\n}({});\nexports.EventKind = EventKind;\nvar EventDirection = /*#__PURE__*/function (EventDirection) {\n  EventDirection[\"Send\"] = \"send\";\n  EventDirection[\"Receive\"] = \"receive\";\n  return EventDirection;\n}({});\nexports.EventDirection = EventDirection;\nvar WidgetEventCapability = /*#__PURE__*/function () {\n  function WidgetEventCapability(direction, eventType, kind, keyStr, raw) {\n    _classCallCheck(this, WidgetEventCapability);\n    this.direction = direction;\n    this.eventType = eventType;\n    this.kind = kind;\n    this.keyStr = keyStr;\n    this.raw = raw;\n  }\n  _createClass(WidgetEventCapability, [{\n    key: \"matchesAsStateEvent\",\n    value: function matchesAsStateEvent(direction, eventType, stateKey) {\n      if (this.kind !== EventKind.State) return false; // not a state event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n      if (this.keyStr === null) return true; // all state keys are allowed\n      if (this.keyStr === stateKey) return true; // this state key is allowed\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsToDeviceEvent\",\n    value: function matchesAsToDeviceEvent(direction, eventType) {\n      if (this.kind !== EventKind.ToDevice) return false; // not a to-device event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }, {\n    key: \"matchesAsRoomEvent\",\n    value: function matchesAsRoomEvent(direction, eventType) {\n      var msgtype = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n      if (this.kind !== EventKind.Event) return false; // not a room event\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      if (this.eventType === \"m.room.message\") {\n        if (this.keyStr === null) return true; // all message types are allowed\n        if (this.keyStr === msgtype) return true; // this message type is allowed\n      } else {\n        return true; // already passed the check for if the event is allowed\n      }\n\n      // Default not allowed\n      return false;\n    }\n  }, {\n    key: \"matchesAsRoomAccountData\",\n    value: function matchesAsRoomAccountData(direction, eventType) {\n      if (this.kind !== EventKind.RoomAccount) return false; // not room account data\n      if (this.direction !== direction) return false; // direction mismatch\n      if (this.eventType !== eventType) return false; // event type mismatch\n\n      // Checks passed, the event is allowed\n      return true;\n    }\n  }], [{\n    key: \"forStateEvent\",\n    value: function forStateEvent(direction, eventType, stateKey) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      eventType = eventType.replace(/#/g, \"\\\\#\");\n      stateKey = stateKey !== null && stateKey !== undefined ? \"#\".concat(stateKey) : \"\";\n      var str = \"org.matrix.msc2762.\".concat(direction, \".state_event:\").concat(eventType).concat(stateKey);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forToDeviceEvent\",\n    value: function forToDeviceEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/56\n      var str = \"org.matrix.msc3819.\".concat(direction, \".to_device:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomEvent\",\n    value: function forRoomEvent(direction, eventType) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:\").concat(eventType);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomMessageEvent\",\n    value: function forRoomMessageEvent(direction, msgtype) {\n      // TODO: Enable support for m.* namespace once the MSC lands.\n      // https://github.com/matrix-org/matrix-widget-api/issues/22\n      msgtype = msgtype === null || msgtype === undefined ? \"\" : msgtype;\n      var str = \"org.matrix.msc2762.\".concat(direction, \".event:m.room.message#\").concat(msgtype);\n\n      // cheat by sending it through the processor\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n  }, {\n    key: \"forRoomAccountData\",\n    value: function forRoomAccountData(direction, eventType) {\n      var str = \"com.beeper.capabilities.\".concat(direction, \".room_account_data:\").concat(eventType);\n      return WidgetEventCapability.findEventCapabilities([str])[0];\n    }\n\n    /**\n     * Parses a capabilities request to find all the event capability requests.\n     * @param {Iterable<Capability>} capabilities The capabilities requested/to parse.\n     * @returns {WidgetEventCapability[]} An array of event capability requests. May be empty, but never null.\n     */\n  }, {\n    key: \"findEventCapabilities\",\n    value: function findEventCapabilities(capabilities) {\n      var parsed = [];\n      var _iterator = _createForOfIteratorHelper(capabilities),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var cap = _step.value;\n          var _direction = null;\n          var eventSegment = void 0;\n          var _kind = null;\n\n          // TODO: Enable support for m.* namespace once the MSCs land.\n          // https://github.com/matrix-org/matrix-widget-api/issues/22\n          // https://github.com/matrix-org/matrix-widget-api/issues/56\n\n          if (cap.startsWith(\"org.matrix.msc2762.send.event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.send.state_event:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.send.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.send.to_device:\")) {\n            _direction = EventDirection.Send;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.send.to_device:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.Event;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc2762.receive.state_event:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.State;\n            eventSegment = cap.substring(\"org.matrix.msc2762.receive.state_event:\".length);\n          } else if (cap.startsWith(\"org.matrix.msc3819.receive.to_device:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.ToDevice;\n            eventSegment = cap.substring(\"org.matrix.msc3819.receive.to_device:\".length);\n          } else if (cap.startsWith(\"com.beeper.capabilities.receive.room_account_data:\")) {\n            _direction = EventDirection.Receive;\n            _kind = EventKind.RoomAccount;\n            eventSegment = cap.substring(\"com.beeper.capabilities.receive.room_account_data:\".length);\n          }\n          if (_direction === null || _kind === null || eventSegment === undefined) continue;\n\n          // The capability uses `#` as a separator between event type and state key/msgtype,\n          // so we split on that. However, a # is also valid in either one of those so we\n          // join accordingly.\n          // Eg: `m.room.message##m.text` is \"m.room.message\" event with msgtype \"#m.text\".\n          var expectingKeyStr = eventSegment.startsWith(\"m.room.message#\") || _kind === EventKind.State;\n          var _keyStr = null;\n          if (eventSegment.includes(\"#\") && expectingKeyStr) {\n            // Dev note: regex is difficult to write, so instead the rules are manually written\n            // out. This is probably just as understandable as a boring regex though, so win-win?\n\n            // Test cases:\n            // str                      eventSegment        keyStr\n            // -------------------------------------------------------------\n            // m.room.message#          m.room.message      <empty string>\n            // m.room.message#test      m.room.message      test\n            // m.room.message\\#         m.room.message#     test\n            // m.room.message##test     m.room.message      #test\n            // m.room.message\\##test    m.room.message#     test\n            // m.room.message\\\\##test   m.room.message\\#    test\n            // m.room.message\\\\###test  m.room.message\\#    #test\n\n            // First step: explode the string\n            var parts = eventSegment.split(\"#\");\n\n            // To form the eventSegment, we'll keep finding parts of the exploded string until\n            // there's one that doesn't end with the escape character (\\). We'll then join those\n            // segments together with the exploding character. We have to remember to consume the\n            // escape character as well.\n            var idx = parts.findIndex(function (p) {\n              return !p.endsWith(\"\\\\\");\n            });\n            eventSegment = parts.slice(0, idx + 1).map(function (p) {\n              return p.endsWith(\"\\\\\") ? p.substring(0, p.length - 1) : p;\n            }).join(\"#\");\n\n            // The keyStr is whatever is left over.\n            _keyStr = parts.slice(idx + 1).join(\"#\");\n          }\n          parsed.push(new WidgetEventCapability(_direction, eventSegment, _kind, _keyStr, cap));\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return parsed;\n    }\n  }]);\n  return WidgetEventCapability;\n}();\nexports.WidgetEventCapability = WidgetEventCapability;\n//# sourceMappingURL=WidgetEventCapability.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SimpleObservable = void 0;\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n/*\n * Copyright 2020 The Matrix.org Foundation C.I.C.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nvar SimpleObservable = /*#__PURE__*/function () {\n  function SimpleObservable(initialFn) {\n    _classCallCheck(this, SimpleObservable);\n    _defineProperty(this, \"listeners\", []);\n    if (initialFn) this.listeners.push(initialFn);\n  }\n  _createClass(SimpleObservable, [{\n    key: \"onUpdate\",\n    value: function onUpdate(fn) {\n      this.listeners.push(fn);\n    }\n  }, {\n    key: \"update\",\n    value: function update(val) {\n      var _iterator = _createForOfIteratorHelper(this.listeners),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var listener = _step.value;\n          listener(val);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.listeners = []; // reset\n    }\n  }]);\n  return SimpleObservable;\n}();\nexports.SimpleObservable = SimpleObservable;\n//# sourceMappingURL=SimpleObservable.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ClientWidgetApi = void 0;\nvar _events = require(\"events\");\nvar _PostmessageTransport = require(\"./transport/PostmessageTransport\");\nvar _WidgetApiDirection = require(\"./interfaces/WidgetApiDirection\");\nvar _WidgetApiAction = require(\"./interfaces/WidgetApiAction\");\nvar _Capabilities = require(\"./interfaces/Capabilities\");\nvar _ApiVersion = require(\"./interfaces/ApiVersion\");\nvar _WidgetEventCapability = require(\"./models/WidgetEventCapability\");\nvar _GetOpenIDAction = require(\"./interfaces/GetOpenIDAction\");\nvar _SimpleObservable = require(\"./util/SimpleObservable\");\nvar _Symbols = require(\"./Symbols\");\nvar _UpdateDelayedEventAction = require(\"./interfaces/UpdateDelayedEventAction\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _regeneratorRuntime() { \"use strict\"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return exports; }; var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function (obj, key, desc) { obj[key] = desc.value; }, $Symbol = \"function\" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || \"@@iterator\", asyncIteratorSymbol = $Symbol.asyncIterator || \"@@asyncIterator\", toStringTagSymbol = $Symbol.toStringTag || \"@@toStringTag\"; function define(obj, key, value) { return Object.defineProperty(obj, key, { value: value, enumerable: !0, configurable: !0, writable: !0 }), obj[key]; } try { define({}, \"\"); } catch (err) { define = function define(obj, key, value) { return obj[key] = value; }; } function wrap(innerFn, outerFn, self, tryLocsList) { var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []); return defineProperty(generator, \"_invoke\", { value: makeInvokeMethod(innerFn, self, context) }), generator; } function tryCatch(fn, obj, arg) { try { return { type: \"normal\", arg: fn.call(obj, arg) }; } catch (err) { return { type: \"throw\", arg: err }; } } exports.wrap = wrap; var ContinueSentinel = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var IteratorPrototype = {}; define(IteratorPrototype, iteratorSymbol, function () { return this; }); var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([]))); NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype); var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype); function defineIteratorMethods(prototype) { [\"next\", \"throw\", \"return\"].forEach(function (method) { define(prototype, method, function (arg) { return this._invoke(method, arg); }); }); } function AsyncIterator(generator, PromiseImpl) { function invoke(method, arg, resolve, reject) { var record = tryCatch(generator[method], generator, arg); if (\"throw\" !== record.type) { var result = record.arg, value = result.value; return value && \"object\" == _typeof(value) && hasOwn.call(value, \"__await\") ? PromiseImpl.resolve(value.__await).then(function (value) { invoke(\"next\", value, resolve, reject); }, function (err) { invoke(\"throw\", err, resolve, reject); }) : PromiseImpl.resolve(value).then(function (unwrapped) { result.value = unwrapped, resolve(result); }, function (error) { return invoke(\"throw\", error, resolve, reject); }); } reject(record.arg); } var previousPromise; defineProperty(this, \"_invoke\", { value: function value(method, arg) { function callInvokeWithMethodAndArg() { return new PromiseImpl(function (resolve, reject) { invoke(method, arg, resolve, reject); }); } return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(innerFn, self, context) { var state = \"suspendedStart\"; return function (method, arg) { if (\"executing\" === state) throw new Error(\"Generator is already running\"); if (\"completed\" === state) { if (\"throw\" === method) throw arg; return doneResult(); } for (context.method = method, context.arg = arg;;) { var delegate = context.delegate; if (delegate) { var delegateResult = maybeInvokeDelegate(delegate, context); if (delegateResult) { if (delegateResult === ContinueSentinel) continue; return delegateResult; } } if (\"next\" === context.method) context.sent = context._sent = context.arg;else if (\"throw\" === context.method) { if (\"suspendedStart\" === state) throw state = \"completed\", context.arg; context.dispatchException(context.arg); } else \"return\" === context.method && context.abrupt(\"return\", context.arg); state = \"executing\"; var record = tryCatch(innerFn, self, context); if (\"normal\" === record.type) { if (state = context.done ? \"completed\" : \"suspendedYield\", record.arg === ContinueSentinel) continue; return { value: record.arg, done: context.done }; } \"throw\" === record.type && (state = \"completed\", context.method = \"throw\", context.arg = record.arg); } }; } function maybeInvokeDelegate(delegate, context) { var methodName = context.method, method = delegate.iterator[methodName]; if (undefined === method) return context.delegate = null, \"throw\" === methodName && delegate.iterator[\"return\"] && (context.method = \"return\", context.arg = undefined, maybeInvokeDelegate(delegate, context), \"throw\" === context.method) || \"return\" !== methodName && (context.method = \"throw\", context.arg = new TypeError(\"The iterator does not provide a '\" + methodName + \"' method\")), ContinueSentinel; var record = tryCatch(method, delegate.iterator, context.arg); if (\"throw\" === record.type) return context.method = \"throw\", context.arg = record.arg, context.delegate = null, ContinueSentinel; var info = record.arg; return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, \"return\" !== context.method && (context.method = \"next\", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = \"throw\", context.arg = new TypeError(\"iterator result is not an object\"), context.delegate = null, ContinueSentinel); } function pushTryEntry(locs) { var entry = { tryLoc: locs[0] }; 1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry); } function resetTryEntry(entry) { var record = entry.completion || {}; record.type = \"normal\", delete record.arg, entry.completion = record; } function Context(tryLocsList) { this.tryEntries = [{ tryLoc: \"root\" }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0); } function values(iterable) { if (iterable) { var iteratorMethod = iterable[iteratorSymbol]; if (iteratorMethod) return iteratorMethod.call(iterable); if (\"function\" == typeof iterable.next) return iterable; if (!isNaN(iterable.length)) { var i = -1, next = function next() { for (; ++i < iterable.length;) if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next; return next.value = undefined, next.done = !0, next; }; return next.next = next; } } return { next: doneResult }; } function doneResult() { return { value: undefined, done: !0 }; } return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, \"constructor\", { value: GeneratorFunctionPrototype, configurable: !0 }), defineProperty(GeneratorFunctionPrototype, \"constructor\", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, \"GeneratorFunction\"), exports.isGeneratorFunction = function (genFun) { var ctor = \"function\" == typeof genFun && genFun.constructor; return !!ctor && (ctor === GeneratorFunction || \"GeneratorFunction\" === (ctor.displayName || ctor.name)); }, exports.mark = function (genFun) { return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, \"GeneratorFunction\")), genFun.prototype = Object.create(Gp), genFun; }, exports.awrap = function (arg) { return { __await: arg }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () { return this; }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) { void 0 === PromiseImpl && (PromiseImpl = Promise); var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl); return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) { return result.done ? result.value : iter.next(); }); }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, \"Generator\"), define(Gp, iteratorSymbol, function () { return this; }), define(Gp, \"toString\", function () { return \"[object Generator]\"; }), exports.keys = function (val) { var object = Object(val), keys = []; for (var key in object) keys.push(key); return keys.reverse(), function next() { for (; keys.length;) { var key = keys.pop(); if (key in object) return next.value = key, next.done = !1, next; } return next.done = !0, next; }; }, exports.values = values, Context.prototype = { constructor: Context, reset: function reset(skipTempReset) { if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = \"next\", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) \"t\" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined); }, stop: function stop() { this.done = !0; var rootRecord = this.tryEntries[0].completion; if (\"throw\" === rootRecord.type) throw rootRecord.arg; return this.rval; }, dispatchException: function dispatchException(exception) { if (this.done) throw exception; var context = this; function handle(loc, caught) { return record.type = \"throw\", record.arg = exception, context.next = loc, caught && (context.method = \"next\", context.arg = undefined), !!caught; } for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i], record = entry.completion; if (\"root\" === entry.tryLoc) return handle(\"end\"); if (entry.tryLoc <= this.prev) { var hasCatch = hasOwn.call(entry, \"catchLoc\"), hasFinally = hasOwn.call(entry, \"finallyLoc\"); if (hasCatch && hasFinally) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } else if (hasCatch) { if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0); } else { if (!hasFinally) throw new Error(\"try statement without catch or finally\"); if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc); } } } }, abrupt: function abrupt(type, arg) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc <= this.prev && hasOwn.call(entry, \"finallyLoc\") && this.prev < entry.finallyLoc) { var finallyEntry = entry; break; } } finallyEntry && (\"break\" === type || \"continue\" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null); var record = finallyEntry ? finallyEntry.completion : {}; return record.type = type, record.arg = arg, finallyEntry ? (this.method = \"next\", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record); }, complete: function complete(record, afterLoc) { if (\"throw\" === record.type) throw record.arg; return \"break\" === record.type || \"continue\" === record.type ? this.next = record.arg : \"return\" === record.type ? (this.rval = this.arg = record.arg, this.method = \"return\", this.next = \"end\") : \"normal\" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel; }, finish: function finish(finallyLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel; } }, \"catch\": function _catch(tryLoc) { for (var i = this.tryEntries.length - 1; i >= 0; --i) { var entry = this.tryEntries[i]; if (entry.tryLoc === tryLoc) { var record = entry.completion; if (\"throw\" === record.type) { var thrown = record.arg; resetTryEntry(entry); } return thrown; } } throw new Error(\"illegal catch attempt\"); }, delegateYield: function delegateYield(iterable, resultName, nextLoc) { return this.delegate = { iterator: values(iterable), resultName: resultName, nextLoc: nextLoc }, \"next\" === this.method && (this.arg = undefined), ContinueSentinel; } }, exports; }\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _asyncIterator(iterable) { var method, async, sync, retry = 2; for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) { if (async && null != (method = iterable[async])) return method.call(iterable); if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable)); async = \"@@asyncIterator\", sync = \"@@iterator\"; } throw new TypeError(\"Object is not async iterable\"); }\nfunction AsyncFromSyncIterator(s) { function AsyncFromSyncIteratorContinuation(r) { if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\")); var done = r.done; return Promise.resolve(r.value).then(function (value) { return { value: value, done: done }; }); } return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) { this.s = s, this.n = s.next; }, AsyncFromSyncIterator.prototype = { s: null, n: null, next: function next() { return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments)); }, \"return\": function _return(value) { var ret = this.s[\"return\"]; return void 0 === ret ? Promise.resolve({ value: value, done: !0 }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments)); }, \"throw\": function _throw(value) { var thr = this.s[\"return\"]; return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments)); } }, new AsyncFromSyncIterator(s); } /*\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Copyright 2020 - 2024 The Matrix.org Foundation C.I.C.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *         http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             *\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             */\n/**\n * API handler for the client side of widgets. This raises events\n * for each action received as `action:${action}` (eg: \"action:screenshot\").\n * Default handling can be prevented by using preventDefault() on the\n * raised event. The default handling varies for each action: ones\n * which the SDK can handle safely are acknowledged appropriately and\n * ones which are unhandled (custom or require the client to do something)\n * are rejected with an error.\n *\n * Events which are preventDefault()ed must reply using the transport.\n * The events raised will have a default of an IWidgetApiRequest\n * interface.\n *\n * When the ClientWidgetApi is ready to start sending requests, it will\n * raise a \"ready\" CustomEvent. After the ready event fires, actions can\n * be sent and the transport will be ready.\n *\n * When the widget has indicated it has loaded, this class raises a\n * \"preparing\" CustomEvent. The preparing event does not indicate that\n * the widget is ready to receive communications - that is signified by\n * the ready event exclusively.\n *\n * This class only handles one widget at a time.\n */\nvar ClientWidgetApi = /*#__PURE__*/function (_EventEmitter) {\n  _inherits(ClientWidgetApi, _EventEmitter);\n  var _super = _createSuper(ClientWidgetApi);\n  /**\n   * Creates a new client widget API. This will instantiate the transport\n   * and start everything. When the iframe is loaded under the widget's\n   * conditions, a \"ready\" event will be raised.\n   * @param {Widget} widget The widget to communicate with.\n   * @param {HTMLIFrameElement} iframe The iframe the widget is in.\n   * @param {WidgetDriver} driver The driver for this widget/client.\n   */\n  function ClientWidgetApi(widget, iframe, driver) {\n    var _this;\n    _classCallCheck(this, ClientWidgetApi);\n    _this = _super.call(this);\n    _this.widget = widget;\n    _this.iframe = iframe;\n    _this.driver = driver;\n    _defineProperty(_assertThisInitialized(_this), \"transport\", void 0);\n    _defineProperty(_assertThisInitialized(_this), \"cachedWidgetVersions\", null);\n    // contentLoadedActionSent is used to check that only one ContentLoaded request is send.\n    _defineProperty(_assertThisInitialized(_this), \"contentLoadedActionSent\", false);\n    _defineProperty(_assertThisInitialized(_this), \"allowedCapabilities\", new Set());\n    _defineProperty(_assertThisInitialized(_this), \"allowedEvents\", []);\n    _defineProperty(_assertThisInitialized(_this), \"isStopped\", false);\n    _defineProperty(_assertThisInitialized(_this), \"turnServers\", null);\n    _defineProperty(_assertThisInitialized(_this), \"contentLoadedWaitTimer\", void 0);\n    // Stores pending requests to push a room's state to the widget\n    _defineProperty(_assertThisInitialized(_this), \"pushRoomStateTasks\", new Set());\n    // Room ID  event type  state key  events to be pushed\n    _defineProperty(_assertThisInitialized(_this), \"pushRoomStateResult\", new Map());\n    _defineProperty(_assertThisInitialized(_this), \"flushRoomStateTask\", null);\n    _defineProperty(_assertThisInitialized(_this), \"viewedRoomId\", null);\n    if (!(iframe !== null && iframe !== void 0 && iframe.contentWindow)) {\n      throw new Error(\"No iframe supplied\");\n    }\n    if (!widget) {\n      throw new Error(\"Invalid widget\");\n    }\n    if (!driver) {\n      throw new Error(\"Invalid driver\");\n    }\n    _this.transport = new _PostmessageTransport.PostmessageTransport(_WidgetApiDirection.WidgetApiDirection.ToWidget, widget.id, iframe.contentWindow, window);\n    _this.transport.targetOrigin = widget.origin;\n    _this.transport.on(\"message\", _this.handleMessage.bind(_assertThisInitialized(_this)));\n    iframe.addEventListener(\"load\", _this.onIframeLoad.bind(_assertThisInitialized(_this)));\n    _this.transport.start();\n    return _this;\n  }\n  _createClass(ClientWidgetApi, [{\n    key: \"hasCapability\",\n    value: function hasCapability(capability) {\n      return this.allowedCapabilities.has(capability);\n    }\n  }, {\n    key: \"canUseRoomTimeline\",\n    value: function canUseRoomTimeline(roomId) {\n      return this.hasCapability(\"org.matrix.msc2762.timeline:\".concat(_Symbols.Symbols.AnyRoom)) || this.hasCapability(\"org.matrix.msc2762.timeline:\".concat(roomId));\n    }\n  }, {\n    key: \"canSendRoomEvent\",\n    value: function canSendRoomEvent(eventType) {\n      var msgtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomEvent(_WidgetEventCapability.EventDirection.Send, eventType, msgtype);\n      });\n    }\n  }, {\n    key: \"canSendStateEvent\",\n    value: function canSendStateEvent(eventType, stateKey) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsStateEvent(_WidgetEventCapability.EventDirection.Send, eventType, stateKey);\n      });\n    }\n  }, {\n    key: \"canSendToDeviceEvent\",\n    value: function canSendToDeviceEvent(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsToDeviceEvent(_WidgetEventCapability.EventDirection.Send, eventType);\n      });\n    }\n  }, {\n    key: \"canReceiveRoomEvent\",\n    value: function canReceiveRoomEvent(eventType) {\n      var msgtype = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomEvent(_WidgetEventCapability.EventDirection.Receive, eventType, msgtype);\n      });\n    }\n  }, {\n    key: \"canReceiveStateEvent\",\n    value: function canReceiveStateEvent(eventType, stateKey) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsStateEvent(_WidgetEventCapability.EventDirection.Receive, eventType, stateKey);\n      });\n    }\n  }, {\n    key: \"canReceiveToDeviceEvent\",\n    value: function canReceiveToDeviceEvent(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsToDeviceEvent(_WidgetEventCapability.EventDirection.Receive, eventType);\n      });\n    }\n  }, {\n    key: \"canReceiveRoomAccountData\",\n    value: function canReceiveRoomAccountData(eventType) {\n      return this.allowedEvents.some(function (e) {\n        return e.matchesAsRoomAccountData(_WidgetEventCapability.EventDirection.Receive, eventType);\n      });\n    }\n  }, {\n    key: \"stop\",\n    value: function stop() {\n      this.isStopped = true;\n      this.transport.stop();\n    }\n  }, {\n    key: \"getWidgetVersions\",\n    value: function () {\n      var _getWidgetVersions = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var r;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              if (!Array.isArray(this.cachedWidgetVersions)) {\n                _context.next = 2;\n                break;\n              }\n              return _context.abrupt(\"return\", Promise.resolve(this.cachedWidgetVersions));\n            case 2:\n              _context.prev = 2;\n              _context.next = 5;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.SupportedApiVersions, {});\n            case 5:\n              r = _context.sent;\n              this.cachedWidgetVersions = r.supported_versions;\n              return _context.abrupt(\"return\", r.supported_versions);\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](2);\n              console.warn(\"non-fatal error getting supported widget versions: \", _context.t0);\n              return _context.abrupt(\"return\", []);\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2, 10]]);\n      }));\n      function getWidgetVersions() {\n        return _getWidgetVersions.apply(this, arguments);\n      }\n      return getWidgetVersions;\n    }()\n  }, {\n    key: \"beginCapabilities\",\n    value: function beginCapabilities() {\n      var _this2 = this;\n      // widget has loaded - tell all the listeners that\n      this.emit(\"preparing\");\n      var requestedCaps;\n      this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.Capabilities, {}).then(function (caps) {\n        requestedCaps = caps.capabilities;\n        return _this2.driver.validateCapabilities(new Set(caps.capabilities));\n      }).then(function (allowedCaps) {\n        _this2.allowCapabilities(_toConsumableArray(allowedCaps), requestedCaps);\n        _this2.emit(\"ready\");\n      })[\"catch\"](function (e) {\n        _this2.emit(\"error:preparing\", e);\n      });\n    }\n  }, {\n    key: \"allowCapabilities\",\n    value: function allowCapabilities(allowed, requested) {\n      var _this$allowedEvents,\n        _this3 = this;\n      console.log(\"Widget \".concat(this.widget.id, \" is allowed capabilities:\"), allowed);\n      var _iterator2 = _createForOfIteratorHelper(allowed),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var c = _step2.value;\n          this.allowedCapabilities.add(c);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      var allowedEvents = _WidgetEventCapability.WidgetEventCapability.findEventCapabilities(allowed);\n      (_this$allowedEvents = this.allowedEvents).push.apply(_this$allowedEvents, _toConsumableArray(allowedEvents));\n      this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.NotifyCapabilities, {\n        requested: requested,\n        approved: Array.from(this.allowedCapabilities)\n      })[\"catch\"](function (e) {\n        console.warn(\"non-fatal error notifying widget of approved capabilities:\", e);\n      }).then(function () {\n        _this3.emit(\"capabilitiesNotified\");\n      });\n\n      // Push the initial room state for all rooms with a timeline capability\n      var _iterator3 = _createForOfIteratorHelper(allowed),\n        _step3;\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var _c = _step3.value;\n          if ((0, _Capabilities.isTimelineCapability)(_c)) {\n            var roomId = (0, _Capabilities.getTimelineRoomIDFromCapability)(_c);\n            if (roomId === _Symbols.Symbols.AnyRoom) {\n              var _iterator4 = _createForOfIteratorHelper(this.driver.getKnownRooms()),\n                _step4;\n              try {\n                for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n                  var _roomId = _step4.value;\n                  this.pushRoomState(_roomId);\n                }\n              } catch (err) {\n                _iterator4.e(err);\n              } finally {\n                _iterator4.f();\n              }\n            } else {\n              this.pushRoomState(roomId);\n            }\n          }\n        }\n        // If new events are allowed and the currently viewed room isn't covered\n        // by a timeline capability, then we know that there could be some state\n        // in the viewed room that the widget hasn't learned about yet- push it.\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n      if (allowedEvents.length > 0 && this.viewedRoomId !== null && !this.canUseRoomTimeline(this.viewedRoomId)) {\n        this.pushRoomState(this.viewedRoomId);\n      }\n    }\n  }, {\n    key: \"onIframeLoad\",\n    value: function onIframeLoad(ev) {\n      if (this.widget.waitForIframeLoad) {\n        // If the widget is set to waitForIframeLoad the capabilities immediately get setup after load.\n        // The client does not wait for the ContentLoaded action.\n        this.beginCapabilities();\n      } else {\n        // Reaching this means, that the Iframe got reloaded/loaded and\n        // the clientApi is awaiting the FIRST ContentLoaded action.\n        console.log(\"waitForIframeLoad is false: waiting for widget to send contentLoaded\");\n        this.contentLoadedWaitTimer = setTimeout(function () {\n          console.error(\"Widget specified waitForIframeLoad=false but timed out waiting for contentLoaded event!\");\n        }, 10000);\n        this.contentLoadedActionSent = false;\n      }\n    }\n  }, {\n    key: \"handleContentLoadedAction\",\n    value: function handleContentLoadedAction(action) {\n      if (this.contentLoadedWaitTimer !== undefined) {\n        clearTimeout(this.contentLoadedWaitTimer);\n        this.contentLoadedWaitTimer = undefined;\n      }\n      if (this.contentLoadedActionSent) {\n        throw new Error(\"Improper sequence: ContentLoaded Action can only be sent once after the widget loaded \" + \"and should only be used if waitForIframeLoad is false (default=true)\");\n      }\n      if (this.widget.waitForIframeLoad) {\n        this.transport.reply(action, {\n          error: {\n            message: \"Improper sequence: not expecting ContentLoaded event if \" + \"waitForIframeLoad is true (default=true)\"\n          }\n        });\n      } else {\n        this.transport.reply(action, {});\n        this.beginCapabilities();\n      }\n      this.contentLoadedActionSent = true;\n    }\n  }, {\n    key: \"replyVersions\",\n    value: function replyVersions(request) {\n      this.transport.reply(request, {\n        supported_versions: _ApiVersion.CurrentApiVersions\n      });\n    }\n  }, {\n    key: \"supportsUpdateState\",\n    value: function () {\n      var _supportsUpdateState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.getWidgetVersions();\n            case 2:\n              return _context2.abrupt(\"return\", _context2.sent.includes(_ApiVersion.UnstableApiVersion.MSC2762_UPDATE_STATE));\n            case 3:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function supportsUpdateState() {\n        return _supportsUpdateState.apply(this, arguments);\n      }\n      return supportsUpdateState;\n    }()\n  }, {\n    key: \"handleCapabilitiesRenegotiate\",\n    value: function handleCapabilitiesRenegotiate(request) {\n      var _request$data,\n        _this4 = this;\n      // acknowledge first\n      this.transport.reply(request, {});\n      var requested = ((_request$data = request.data) === null || _request$data === void 0 ? void 0 : _request$data.capabilities) || [];\n      var newlyRequested = new Set(requested.filter(function (r) {\n        return !_this4.hasCapability(r);\n      }));\n      if (newlyRequested.size === 0) {\n        // Nothing to do - skip validation\n        this.allowCapabilities([], []);\n      }\n      this.driver.validateCapabilities(newlyRequested).then(function (allowed) {\n        return _this4.allowCapabilities(_toConsumableArray(allowed), _toConsumableArray(newlyRequested));\n      });\n    }\n  }, {\n    key: \"handleNavigate\",\n    value: function handleNavigate(request) {\n      var _request$data2,\n        _request$data3,\n        _this5 = this;\n      if (!this.hasCapability(_Capabilities.MatrixCapabilities.MSC2931Navigate)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      if (!((_request$data2 = request.data) !== null && _request$data2 !== void 0 && _request$data2.uri) || !((_request$data3 = request.data) !== null && _request$data3 !== void 0 && _request$data3.uri.toString().startsWith(\"https://matrix.to/#\"))) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid matrix.to URI\"\n          }\n        });\n      }\n      var onErr = function onErr(e) {\n        console.error(\"[ClientWidgetApi] Failed to handle navigation: \", e);\n        _this5.handleDriverError(e, request, \"Error handling navigation\");\n      };\n      try {\n        this.driver.navigate(request.data.uri.toString())[\"catch\"](function (e) {\n          return onErr(e);\n        }).then(function () {\n          return _this5.transport.reply(request, {});\n        });\n      } catch (e) {\n        return onErr(e);\n      }\n    }\n  }, {\n    key: \"handleOIDC\",\n    value: function handleOIDC(request) {\n      var _this6 = this;\n      var phase = 1; // 1 = initial request, 2 = after user manual confirmation\n\n      var replyState = function replyState(state, credential) {\n        credential = credential || {};\n        if (phase > 1) {\n          return _this6.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.OpenIDCredentials, _objectSpread({\n            state: state,\n            original_request_id: request.requestId\n          }, credential));\n        } else {\n          return _this6.transport.reply(request, _objectSpread({\n            state: state\n          }, credential));\n        }\n      };\n      var replyError = function replyError(msg) {\n        console.error(\"[ClientWidgetApi] Failed to handle OIDC: \", msg);\n        if (phase > 1) {\n          // We don't have a way to indicate that a random error happened in this flow, so\n          // just block the attempt.\n          return replyState(_GetOpenIDAction.OpenIDRequestState.Blocked);\n        } else {\n          return _this6.transport.reply(request, {\n            error: {\n              message: msg\n            }\n          });\n        }\n      };\n      var observer = new _SimpleObservable.SimpleObservable(function (update) {\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.PendingUserConfirmation && phase > 1) {\n          observer.close();\n          return replyError(\"client provided out-of-phase response to OIDC flow\");\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.PendingUserConfirmation) {\n          replyState(update.state);\n          phase++;\n          return;\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.Allowed && !update.token) {\n          return replyError(\"client provided invalid OIDC token for an allowed request\");\n        }\n        if (update.state === _GetOpenIDAction.OpenIDRequestState.Blocked) {\n          update.token = undefined; // just in case the client did something weird\n        }\n\n        observer.close();\n        return replyState(update.state, update.token);\n      });\n      this.driver.askOpenID(observer);\n    }\n  }, {\n    key: \"handleReadRoomAccountData\",\n    value: function handleReadRoomAccountData(request) {\n      var _this7 = this;\n      var events = Promise.resolve([]);\n      events = this.driver.readRoomAccountData(request.data.type);\n      if (!this.canReceiveRoomAccountData(request.data.type)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Cannot read room account data of this type\"\n          }\n        });\n      }\n      return events.then(function (evs) {\n        _this7.transport.reply(request, {\n          events: evs\n        });\n      });\n    }\n  }, {\n    key: \"handleReadEvents\",\n    value: function () {\n      var _handleReadEvents = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(request) {\n        var _this8 = this;\n        var askRoomIds, _iterator5, _step5, roomId, limit, since, stateKey, msgtype, _stateKey, events;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (request.data.type) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event type\"\n                }\n              }));\n            case 2:\n              if (!(request.data.limit !== undefined && (!request.data.limit || request.data.limit < 0))) {\n                _context3.next = 4;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - limit out of range\"\n                }\n              }));\n            case 4:\n              if (!(request.data.room_ids === undefined)) {\n                _context3.next = 8;\n                break;\n              }\n              askRoomIds = this.viewedRoomId === null ? [] : [this.viewedRoomId];\n              _context3.next = 30;\n              break;\n            case 8:\n              if (!(request.data.room_ids === _Symbols.Symbols.AnyRoom)) {\n                _context3.next = 12;\n                break;\n              }\n              askRoomIds = this.driver.getKnownRooms().filter(function (roomId) {\n                return _this8.canUseRoomTimeline(roomId);\n              });\n              _context3.next = 30;\n              break;\n            case 12:\n              askRoomIds = request.data.room_ids;\n              _iterator5 = _createForOfIteratorHelper(askRoomIds);\n              _context3.prev = 14;\n              _iterator5.s();\n            case 16:\n              if ((_step5 = _iterator5.n()).done) {\n                _context3.next = 22;\n                break;\n              }\n              roomId = _step5.value;\n              if (this.canUseRoomTimeline(roomId)) {\n                _context3.next = 20;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Unable to access room timeline: \".concat(roomId)\n                }\n              }));\n            case 20:\n              _context3.next = 16;\n              break;\n            case 22:\n              _context3.next = 27;\n              break;\n            case 24:\n              _context3.prev = 24;\n              _context3.t0 = _context3[\"catch\"](14);\n              _iterator5.e(_context3.t0);\n            case 27:\n              _context3.prev = 27;\n              _iterator5.f();\n              return _context3.finish(27);\n            case 30:\n              limit = request.data.limit || 0;\n              since = request.data.since;\n              stateKey = undefined;\n              msgtype = undefined;\n              if (!(request.data.state_key !== undefined)) {\n                _context3.next = 40;\n                break;\n              }\n              stateKey = request.data.state_key === true ? undefined : request.data.state_key.toString();\n              if (this.canReceiveStateEvent(request.data.type, (_stateKey = stateKey) !== null && _stateKey !== void 0 ? _stateKey : null)) {\n                _context3.next = 38;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Cannot read state events of this type\"\n                }\n              }));\n            case 38:\n              _context3.next = 43;\n              break;\n            case 40:\n              msgtype = request.data.msgtype;\n              if (this.canReceiveRoomEvent(request.data.type, msgtype)) {\n                _context3.next = 43;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Cannot read room events of this type\"\n                }\n              }));\n            case 43:\n              if (!(request.data.room_ids === undefined && askRoomIds.length === 0)) {\n                _context3.next = 50;\n                break;\n              }\n              // For backwards compatibility we still call the deprecated\n              // readRoomEvents and readStateEvents methods in case the client isn't\n              // letting us know the currently viewed room via setViewedRoomId\n              //\n              // This can be considered as a deprecated implementation.\n              // A driver should call `setViewedRoomId` on the widget messaging and implement the new readRoomState and readRoomTimeline\n              // Methods.\n              // This block makes sure that it is also possible to not use setViewedRoomId.\n              // readRoomTimeline and readRoomState are required however! Otherwise widget requests that include\n              // `room_ids` will fail.\n              console.warn(\"The widgetDriver uses deprecated behaviour:\\n It does not set the viewedRoomId using `setViewedRoomId`\");\n              _context3.next = 47;\n              return (\n                // This returns [] with the current driver of Element Web.\n                // Add default implementations of the `readRoomEvents` and `readStateEvents`\n                // methods to use `readRoomTimeline` and `readRoomState` if they are not overwritten.\n                request.data.state_key === undefined ? this.driver.readRoomEvents(request.data.type, msgtype, limit, null, since) : this.driver.readStateEvents(request.data.type, stateKey, limit, null)\n              );\n            case 47:\n              events = _context3.sent;\n              _context3.next = 68;\n              break;\n            case 50:\n              _context3.next = 52;\n              return this.supportsUpdateState();\n            case 52:\n              if (!_context3.sent) {\n                _context3.next = 58;\n                break;\n              }\n              _context3.next = 55;\n              return Promise.all(askRoomIds.map(function (roomId) {\n                return _this8.driver.readRoomTimeline(roomId, request.data.type, msgtype, stateKey, limit, since);\n              }));\n            case 55:\n              events = _context3.sent.flat(1);\n              _context3.next = 68;\n              break;\n            case 58:\n              if (!(request.data.state_key === undefined)) {\n                _context3.next = 64;\n                break;\n              }\n              _context3.next = 61;\n              return Promise.all(askRoomIds.map(function (roomId) {\n                return _this8.driver.readRoomTimeline(roomId, request.data.type, msgtype, stateKey, limit, since);\n              }));\n            case 61:\n              _context3.t1 = _context3.sent;\n              _context3.next = 67;\n              break;\n            case 64:\n              _context3.next = 66;\n              return Promise.all(askRoomIds.map(function (roomId) {\n                return _this8.driver.readRoomState(roomId, request.data.type, stateKey);\n              }));\n            case 66:\n              _context3.t1 = _context3.sent;\n            case 67:\n              events = _context3.t1.flat(1);\n            case 68:\n              this.transport.reply(request, {\n                events: events\n              });\n            case 69:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[14, 24, 27, 30]]);\n      }));\n      function handleReadEvents(_x) {\n        return _handleReadEvents.apply(this, arguments);\n      }\n      return handleReadEvents;\n    }()\n  }, {\n    key: \"handleSendEvent\",\n    value: function handleSendEvent(request) {\n      var _this9 = this;\n      if (!request.data.type) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - missing event type\"\n          }\n        });\n      }\n      if (!!request.data.room_id && !this.canUseRoomTimeline(request.data.room_id)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Unable to access room timeline: \".concat(request.data.room_id)\n          }\n        });\n      }\n      var isDelayedEvent = request.data.delay !== undefined || request.data.parent_delay_id !== undefined;\n      if (isDelayedEvent && !this.hasCapability(_Capabilities.MatrixCapabilities.MSC4157SendDelayedEvent)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      var sendEventPromise;\n      if (request.data.state_key !== undefined) {\n        if (!this.canSendStateEvent(request.data.type, request.data.state_key)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot send state events of this type\"\n            }\n          });\n        }\n        if (!isDelayedEvent) {\n          sendEventPromise = this.driver.sendEvent(request.data.type, request.data.content || {}, request.data.state_key, request.data.room_id);\n        } else {\n          var _request$data$delay, _request$data$parent_;\n          sendEventPromise = this.driver.sendDelayedEvent((_request$data$delay = request.data.delay) !== null && _request$data$delay !== void 0 ? _request$data$delay : null, (_request$data$parent_ = request.data.parent_delay_id) !== null && _request$data$parent_ !== void 0 ? _request$data$parent_ : null, request.data.type, request.data.content || {}, request.data.state_key, request.data.room_id);\n        }\n      } else {\n        var content = request.data.content || {};\n        var msgtype = content[\"msgtype\"];\n        if (!this.canSendRoomEvent(request.data.type, msgtype)) {\n          return this.transport.reply(request, {\n            error: {\n              message: \"Cannot send room events of this type\"\n            }\n          });\n        }\n        if (!isDelayedEvent) {\n          sendEventPromise = this.driver.sendEvent(request.data.type, content, null,\n          // not sending a state event\n          request.data.room_id);\n        } else {\n          var _request$data$delay2, _request$data$parent_2;\n          sendEventPromise = this.driver.sendDelayedEvent((_request$data$delay2 = request.data.delay) !== null && _request$data$delay2 !== void 0 ? _request$data$delay2 : null, (_request$data$parent_2 = request.data.parent_delay_id) !== null && _request$data$parent_2 !== void 0 ? _request$data$parent_2 : null, request.data.type, content, null,\n          // not sending a state event\n          request.data.room_id);\n        }\n      }\n      sendEventPromise.then(function (sentEvent) {\n        return _this9.transport.reply(request, _objectSpread({\n          room_id: sentEvent.roomId\n        }, \"eventId\" in sentEvent ? {\n          event_id: sentEvent.eventId\n        } : {\n          delay_id: sentEvent.delayId\n        }));\n      })[\"catch\"](function (e) {\n        console.error(\"error sending event: \", e);\n        _this9.handleDriverError(e, request, \"Error sending event\");\n      });\n    }\n  }, {\n    key: \"handleUpdateDelayedEvent\",\n    value: function handleUpdateDelayedEvent(request) {\n      var _this10 = this;\n      if (!request.data.delay_id) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Invalid request - missing delay_id\"\n          }\n        });\n      }\n      if (!this.hasCapability(_Capabilities.MatrixCapabilities.MSC4157UpdateDelayedEvent)) {\n        return this.transport.reply(request, {\n          error: {\n            message: \"Missing capability\"\n          }\n        });\n      }\n      switch (request.data.action) {\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Cancel:\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Restart:\n        case _UpdateDelayedEventAction.UpdateDelayedEventAction.Send:\n          this.driver.updateDelayedEvent(request.data.delay_id, request.data.action).then(function () {\n            return _this10.transport.reply(request, {});\n          })[\"catch\"](function (e) {\n            console.error(\"error updating delayed event: \", e);\n            _this10.handleDriverError(e, request, \"Error updating delayed event\");\n          });\n          break;\n        default:\n          return this.transport.reply(request, {\n            error: {\n              message: \"Invalid request - unsupported action\"\n            }\n          });\n      }\n    }\n  }, {\n    key: \"handleSendToDevice\",\n    value: function () {\n      var _handleSendToDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(request) {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              if (request.data.type) {\n                _context4.next = 5;\n                break;\n              }\n              _context4.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event type\"\n                }\n              });\n            case 3:\n              _context4.next = 31;\n              break;\n            case 5:\n              if (request.data.messages) {\n                _context4.next = 10;\n                break;\n              }\n              _context4.next = 8;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event contents\"\n                }\n              });\n            case 8:\n              _context4.next = 31;\n              break;\n            case 10:\n              if (!(typeof request.data.encrypted !== \"boolean\")) {\n                _context4.next = 15;\n                break;\n              }\n              _context4.next = 13;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing encryption flag\"\n                }\n              });\n            case 13:\n              _context4.next = 31;\n              break;\n            case 15:\n              if (this.canSendToDeviceEvent(request.data.type)) {\n                _context4.next = 20;\n                break;\n              }\n              _context4.next = 18;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Cannot send to-device events of this type\"\n                }\n              });\n            case 18:\n              _context4.next = 31;\n              break;\n            case 20:\n              _context4.prev = 20;\n              _context4.next = 23;\n              return this.driver.sendToDevice(request.data.type, request.data.encrypted, request.data.messages);\n            case 23:\n              _context4.next = 25;\n              return this.transport.reply(request, {});\n            case 25:\n              _context4.next = 31;\n              break;\n            case 27:\n              _context4.prev = 27;\n              _context4.t0 = _context4[\"catch\"](20);\n              console.error(\"error sending to-device event\", _context4.t0);\n              this.handleDriverError(_context4.t0, request, \"Error sending event\");\n            case 31:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[20, 27]]);\n      }));\n      function handleSendToDevice(_x2) {\n        return _handleSendToDevice.apply(this, arguments);\n      }\n      return handleSendToDevice;\n    }()\n  }, {\n    key: \"pollTurnServers\",\n    value: function () {\n      var _pollTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee5(turnServers, initialServer) {\n        var _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, server;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n              _context5.next = 3;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateTurnServers, initialServer // it's compatible, but missing the index signature\n              );\n            case 3:\n              // Pick the generator up where we left off\n              _iteratorAbruptCompletion = false;\n              _didIteratorError = false;\n              _context5.prev = 5;\n              _iterator = _asyncIterator(turnServers);\n            case 7:\n              _context5.next = 9;\n              return _iterator.next();\n            case 9:\n              if (!(_iteratorAbruptCompletion = !(_step = _context5.sent).done)) {\n                _context5.next = 16;\n                break;\n              }\n              server = _step.value;\n              _context5.next = 13;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateTurnServers, server // it's compatible, but missing the index signature\n              );\n            case 13:\n              _iteratorAbruptCompletion = false;\n              _context5.next = 7;\n              break;\n            case 16:\n              _context5.next = 22;\n              break;\n            case 18:\n              _context5.prev = 18;\n              _context5.t0 = _context5[\"catch\"](5);\n              _didIteratorError = true;\n              _iteratorError = _context5.t0;\n            case 22:\n              _context5.prev = 22;\n              _context5.prev = 23;\n              if (!(_iteratorAbruptCompletion && _iterator[\"return\"] != null)) {\n                _context5.next = 27;\n                break;\n              }\n              _context5.next = 27;\n              return _iterator[\"return\"]();\n            case 27:\n              _context5.prev = 27;\n              if (!_didIteratorError) {\n                _context5.next = 30;\n                break;\n              }\n              throw _iteratorError;\n            case 30:\n              return _context5.finish(27);\n            case 31:\n              return _context5.finish(22);\n            case 32:\n              _context5.next = 37;\n              break;\n            case 34:\n              _context5.prev = 34;\n              _context5.t1 = _context5[\"catch\"](0);\n              console.error(\"error polling for TURN servers\", _context5.t1);\n            case 37:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[0, 34], [5, 18, 22, 32], [23,, 27, 31]]);\n      }));\n      function pollTurnServers(_x3, _x4) {\n        return _pollTurnServers.apply(this, arguments);\n      }\n      return pollTurnServers;\n    }()\n  }, {\n    key: \"handleWatchTurnServers\",\n    value: function () {\n      var _handleWatchTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee6(request) {\n        var turnServers, _yield$turnServers$ne, done, value;\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3846TurnServers)) {\n                _context6.next = 5;\n                break;\n              }\n              _context6.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              });\n            case 3:\n              _context6.next = 30;\n              break;\n            case 5:\n              if (!this.turnServers) {\n                _context6.next = 10;\n                break;\n              }\n              _context6.next = 8;\n              return this.transport.reply(request, {});\n            case 8:\n              _context6.next = 30;\n              break;\n            case 10:\n              _context6.prev = 10;\n              turnServers = this.driver.getTurnServers(); // Peek at the first result, so we can at least verify that the\n              // client isn't banned from getting TURN servers entirely\n              _context6.next = 14;\n              return turnServers.next();\n            case 14:\n              _yield$turnServers$ne = _context6.sent;\n              done = _yield$turnServers$ne.done;\n              value = _yield$turnServers$ne.value;\n              if (!done) {\n                _context6.next = 19;\n                break;\n              }\n              throw new Error(\"Client refuses to provide any TURN servers\");\n            case 19:\n              _context6.next = 21;\n              return this.transport.reply(request, {});\n            case 21:\n              // Start the poll loop, sending the widget the initial result\n              this.pollTurnServers(turnServers, value);\n              this.turnServers = turnServers;\n              _context6.next = 30;\n              break;\n            case 25:\n              _context6.prev = 25;\n              _context6.t0 = _context6[\"catch\"](10);\n              console.error(\"error getting first TURN server results\", _context6.t0);\n              _context6.next = 30;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"TURN servers not available\"\n                }\n              });\n            case 30:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this, [[10, 25]]);\n      }));\n      function handleWatchTurnServers(_x5) {\n        return _handleWatchTurnServers.apply(this, arguments);\n      }\n      return handleWatchTurnServers;\n    }()\n  }, {\n    key: \"handleUnwatchTurnServers\",\n    value: function () {\n      var _handleUnwatchTurnServers = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee7(request) {\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3846TurnServers)) {\n                _context7.next = 5;\n                break;\n              }\n              _context7.next = 3;\n              return this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              });\n            case 3:\n              _context7.next = 15;\n              break;\n            case 5:\n              if (this.turnServers) {\n                _context7.next = 10;\n                break;\n              }\n              _context7.next = 8;\n              return this.transport.reply(request, {});\n            case 8:\n              _context7.next = 15;\n              break;\n            case 10:\n              _context7.next = 12;\n              return this.turnServers[\"return\"](undefined);\n            case 12:\n              this.turnServers = null;\n              _context7.next = 15;\n              return this.transport.reply(request, {});\n            case 15:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n      function handleUnwatchTurnServers(_x6) {\n        return _handleUnwatchTurnServers.apply(this, arguments);\n      }\n      return handleUnwatchTurnServers;\n    }()\n  }, {\n    key: \"handleReadRelations\",\n    value: function () {\n      var _handleReadRelations = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee8(request) {\n        var _this11 = this;\n        var result, chunk;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              if (request.data.event_id) {\n                _context8.next = 2;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing event ID\"\n                }\n              }));\n            case 2:\n              if (!(request.data.limit !== undefined && request.data.limit < 0)) {\n                _context8.next = 4;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - limit out of range\"\n                }\n              }));\n            case 4:\n              if (!(request.data.room_id !== undefined && !this.canUseRoomTimeline(request.data.room_id))) {\n                _context8.next = 6;\n                break;\n              }\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Unable to access room timeline: \".concat(request.data.room_id)\n                }\n              }));\n            case 6:\n              _context8.prev = 6;\n              _context8.next = 9;\n              return this.driver.readEventRelations(request.data.event_id, request.data.room_id, request.data.rel_type, request.data.event_type, request.data.from, request.data.to, request.data.limit, request.data.direction);\n            case 9:\n              result = _context8.sent;\n              // only return events that the user has the permission to receive\n              chunk = result.chunk.filter(function (e) {\n                if (e.state_key !== undefined) {\n                  return _this11.canReceiveStateEvent(e.type, e.state_key);\n                } else {\n                  return _this11.canReceiveRoomEvent(e.type, e.content[\"msgtype\"]);\n                }\n              });\n              return _context8.abrupt(\"return\", this.transport.reply(request, {\n                chunk: chunk,\n                prev_batch: result.prevBatch,\n                next_batch: result.nextBatch\n              }));\n            case 14:\n              _context8.prev = 14;\n              _context8.t0 = _context8[\"catch\"](6);\n              console.error(\"error getting the relations\", _context8.t0);\n              this.handleDriverError(_context8.t0, request, \"Unexpected error while reading relations\");\n            case 18:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[6, 14]]);\n      }));\n      function handleReadRelations(_x7) {\n        return _handleReadRelations.apply(this, arguments);\n      }\n      return handleReadRelations;\n    }()\n  }, {\n    key: \"handleUserDirectorySearch\",\n    value: function () {\n      var _handleUserDirectorySearch = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee9(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC3973UserDirectorySearch)) {\n                _context9.next = 2;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              if (!(typeof request.data.search_term !== \"string\")) {\n                _context9.next = 4;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - missing search term\"\n                }\n              }));\n            case 4:\n              if (!(request.data.limit !== undefined && request.data.limit < 0)) {\n                _context9.next = 6;\n                break;\n              }\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Invalid request - limit out of range\"\n                }\n              }));\n            case 6:\n              _context9.prev = 6;\n              _context9.next = 9;\n              return this.driver.searchUserDirectory(request.data.search_term, request.data.limit);\n            case 9:\n              result = _context9.sent;\n              return _context9.abrupt(\"return\", this.transport.reply(request, {\n                limited: result.limited,\n                results: result.results.map(function (r) {\n                  return {\n                    user_id: r.userId,\n                    display_name: r.displayName,\n                    avatar_url: r.avatarUrl\n                  };\n                })\n              }));\n            case 13:\n              _context9.prev = 13;\n              _context9.t0 = _context9[\"catch\"](6);\n              console.error(\"error searching in the user directory\", _context9.t0);\n              this.handleDriverError(_context9.t0, request, \"Unexpected error while searching in the user directory\");\n            case 17:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[6, 13]]);\n      }));\n      function handleUserDirectorySearch(_x8) {\n        return _handleUserDirectorySearch.apply(this, arguments);\n      }\n      return handleUserDirectorySearch;\n    }()\n  }, {\n    key: \"handleGetMediaConfig\",\n    value: function () {\n      var _handleGetMediaConfig = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee10(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039UploadFile)) {\n                _context10.next = 2;\n                break;\n              }\n              return _context10.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context10.prev = 2;\n              _context10.next = 5;\n              return this.driver.getMediaConfig();\n            case 5:\n              result = _context10.sent;\n              return _context10.abrupt(\"return\", this.transport.reply(request, result));\n            case 9:\n              _context10.prev = 9;\n              _context10.t0 = _context10[\"catch\"](2);\n              console.error(\"error while getting the media configuration\", _context10.t0);\n              this.handleDriverError(_context10.t0, request, \"Unexpected error while getting the media configuration\");\n            case 13:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[2, 9]]);\n      }));\n      function handleGetMediaConfig(_x9) {\n        return _handleGetMediaConfig.apply(this, arguments);\n      }\n      return handleGetMediaConfig;\n    }()\n  }, {\n    key: \"handleUploadFile\",\n    value: function () {\n      var _handleUploadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee11(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039UploadFile)) {\n                _context11.next = 2;\n                break;\n              }\n              return _context11.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context11.prev = 2;\n              _context11.next = 5;\n              return this.driver.uploadFile(request.data.file);\n            case 5:\n              result = _context11.sent;\n              return _context11.abrupt(\"return\", this.transport.reply(request, {\n                content_uri: result.contentUri\n              }));\n            case 9:\n              _context11.prev = 9;\n              _context11.t0 = _context11[\"catch\"](2);\n              console.error(\"error while uploading a file\", _context11.t0);\n              this.handleDriverError(_context11.t0, request, \"Unexpected error while uploading a file\");\n            case 13:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[2, 9]]);\n      }));\n      function handleUploadFile(_x10) {\n        return _handleUploadFile.apply(this, arguments);\n      }\n      return handleUploadFile;\n    }()\n  }, {\n    key: \"handleDownloadFile\",\n    value: function () {\n      var _handleDownloadFile = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee12(request) {\n        var result;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              if (this.hasCapability(_Capabilities.MatrixCapabilities.MSC4039DownloadFile)) {\n                _context12.next = 2;\n                break;\n              }\n              return _context12.abrupt(\"return\", this.transport.reply(request, {\n                error: {\n                  message: \"Missing capability\"\n                }\n              }));\n            case 2:\n              _context12.prev = 2;\n              _context12.next = 5;\n              return this.driver.downloadFile(request.data.content_uri);\n            case 5:\n              result = _context12.sent;\n              return _context12.abrupt(\"return\", this.transport.reply(request, {\n                file: result.file\n              }));\n            case 9:\n              _context12.prev = 9;\n              _context12.t0 = _context12[\"catch\"](2);\n              console.error(\"error while downloading a file\", _context12.t0);\n              this.handleDriverError(_context12.t0, request, \"Unexpected error while downloading a file\");\n            case 13:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[2, 9]]);\n      }));\n      function handleDownloadFile(_x11) {\n        return _handleDownloadFile.apply(this, arguments);\n      }\n      return handleDownloadFile;\n    }()\n  }, {\n    key: \"handleDriverError\",\n    value: function handleDriverError(e, request, message) {\n      var data = this.driver.processError(e);\n      this.transport.reply(request, {\n        error: _objectSpread({\n          message: message\n        }, data)\n      });\n    }\n  }, {\n    key: \"handleMessage\",\n    value: function handleMessage(ev) {\n      if (this.isStopped) return;\n      var actionEv = new CustomEvent(\"action:\".concat(ev.detail.action), {\n        detail: ev.detail,\n        cancelable: true\n      });\n      this.emit(\"action:\".concat(ev.detail.action), actionEv);\n      if (!actionEv.defaultPrevented) {\n        switch (ev.detail.action) {\n          case _WidgetApiAction.WidgetApiFromWidgetAction.ContentLoaded:\n            return this.handleContentLoadedAction(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SupportedApiVersions:\n            return this.replyVersions(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SendEvent:\n            return this.handleSendEvent(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.SendToDevice:\n            return this.handleSendToDevice(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.GetOpenIDCredentials:\n            return this.handleOIDC(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2931Navigate:\n            return this.handleNavigate(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2974RenegotiateCapabilities:\n            return this.handleCapabilitiesRenegotiate(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC2876ReadEvents:\n            return this.handleReadEvents(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.WatchTurnServers:\n            return this.handleWatchTurnServers(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.UnwatchTurnServers:\n            return this.handleUnwatchTurnServers(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC3869ReadRelations:\n            return this.handleReadRelations(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC3973UserDirectorySearch:\n            return this.handleUserDirectorySearch(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.BeeperReadRoomAccountData:\n            return this.handleReadRoomAccountData(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039GetMediaConfigAction:\n            return this.handleGetMediaConfig(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039UploadFileAction:\n            return this.handleUploadFile(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4039DownloadFileAction:\n            return this.handleDownloadFile(ev.detail);\n          case _WidgetApiAction.WidgetApiFromWidgetAction.MSC4157UpdateDelayedEvent:\n            return this.handleUpdateDelayedEvent(ev.detail);\n          default:\n            return this.transport.reply(ev.detail, {\n              error: {\n                message: \"Unknown or unsupported action: \" + ev.detail.action\n              }\n            });\n        }\n      }\n    }\n\n    /**\n     * Informs the widget that the client's theme has changed.\n     * @param theme The theme data, as an object with arbitrary contents.\n     */\n  }, {\n    key: \"updateTheme\",\n    value: function updateTheme(theme) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.ThemeChange, theme);\n    }\n\n    /**\n     * Informs the widget that the client's language has changed.\n     * @param lang The BCP 47 identifier representing the client's current language.\n     */\n  }, {\n    key: \"updateLanguage\",\n    value: function updateLanguage(lang) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.LanguageChange, {\n        lang: lang\n      });\n    }\n\n    /**\n     * Takes a screenshot of the widget.\n     * @returns Resolves to the widget's screenshot.\n     * @throws Throws if there is a problem.\n     */\n  }, {\n    key: \"takeScreenshot\",\n    value: function takeScreenshot() {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.TakeScreenshot, {});\n    }\n\n    /**\n     * Alerts the widget to whether or not it is currently visible.\n     * @param {boolean} isVisible Whether the widget is visible or not.\n     * @returns {Promise<IWidgetApiResponseData>} Resolves when the widget acknowledges the update.\n     */\n  }, {\n    key: \"updateVisibility\",\n    value: function updateVisibility(isVisible) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateVisibility, {\n        visible: isVisible\n      });\n    }\n  }, {\n    key: \"sendWidgetConfig\",\n    value: function sendWidgetConfig(data) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.WidgetConfig, data).then();\n    }\n  }, {\n    key: \"notifyModalWidgetButtonClicked\",\n    value: function notifyModalWidgetButtonClicked(id) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.ButtonClicked, {\n        id: id\n      }).then();\n    }\n  }, {\n    key: \"notifyModalWidgetClose\",\n    value: function notifyModalWidgetClose(data) {\n      return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.CloseModalWidget, data).then();\n    }\n\n    /**\n     * Feeds an event to the widget. As a client you are expected to call this\n     * for every new event in every room to which you are joined or invited.\n     * @param {IRoomEvent} rawEvent The event to (try to) send to the widget.\n     * @param {string} currentViewedRoomId The room ID the user is currently\n     *   interacting with. Not the room ID of the event.\n     * @returns {Promise<void>} Resolves when delivered or if the widget is not\n     *   able to read the event due to permissions, rejects if the widget failed\n     *   to handle the event.\n     * @deprecated It is recommended to communicate the viewed room ID by calling\n     *   {@link ClientWidgetApi.setViewedRoomId} rather than passing it to this\n     *   method.\n     */\n  }, {\n    key: \"feedEvent\",\n    value: function () {\n      var _feedEvent = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee13(rawEvent, currentViewedRoomId) {\n        var _rawEvent$content;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              if (currentViewedRoomId !== undefined) this.setViewedRoomId(currentViewedRoomId);\n              if (!(rawEvent.room_id !== this.viewedRoomId && !this.canUseRoomTimeline(rawEvent.room_id))) {\n                _context13.next = 3;\n                break;\n              }\n              return _context13.abrupt(\"return\");\n            case 3:\n              if (!(rawEvent.state_key !== undefined && rawEvent.state_key !== null)) {\n                _context13.next = 8;\n                break;\n              }\n              if (this.canReceiveStateEvent(rawEvent.type, rawEvent.state_key)) {\n                _context13.next = 6;\n                break;\n              }\n              return _context13.abrupt(\"return\");\n            case 6:\n              _context13.next = 10;\n              break;\n            case 8:\n              if (this.canReceiveRoomEvent(rawEvent.type, (_rawEvent$content = rawEvent.content) === null || _rawEvent$content === void 0 ? void 0 : _rawEvent$content[\"msgtype\"])) {\n                _context13.next = 10;\n                break;\n              }\n              return _context13.abrupt(\"return\");\n            case 10:\n              _context13.next = 12;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.SendEvent,\n              // it's compatible, but missing the index signature\n              rawEvent);\n            case 12:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this);\n      }));\n      function feedEvent(_x12, _x13) {\n        return _feedEvent.apply(this, arguments);\n      }\n      return feedEvent;\n    }()\n    /**\n     * Feeds a to-device event to the widget. As a client you are expected to\n     * call this for every to-device event you receive.\n     * @param {IRoomEvent} rawEvent The event to (try to) send to the widget.\n     * @param {boolean} encrypted Whether the event contents were encrypted.\n     * @returns {Promise<void>} Resolves when delivered or if the widget is not\n     *   able to receive the event due to permissions, rejects if the widget\n     *   failed to handle the event.\n     */\n  }, {\n    key: \"feedToDevice\",\n    value: function () {\n      var _feedToDevice = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee14(rawEvent, encrypted) {\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              if (!this.canReceiveToDeviceEvent(rawEvent.type)) {\n                _context14.next = 3;\n                break;\n              }\n              _context14.next = 3;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.SendToDevice, // it's compatible, but missing the index signature\n              _objectSpread(_objectSpread({}, rawEvent), {}, {\n                encrypted: encrypted\n              }));\n            case 3:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n      function feedToDevice(_x14, _x15) {\n        return _feedToDevice.apply(this, arguments);\n      }\n      return feedToDevice;\n    }()\n  }, {\n    key: \"setViewedRoomId\",\n    value:\n    /**\n     * Indicate that a room is being viewed (making it possible for the widget\n     * to interact with it).\n     */\n    function setViewedRoomId(roomId) {\n      this.viewedRoomId = roomId;\n      // If the widget doesn't have timeline permissions for the room then\n      // this is its opportunity to learn the room state. We push the entire\n      // room state, which could be redundant if this room had been viewed\n      // once before, but it's easier than selectively pushing just the bits\n      // of state that changed while the room was in the background.\n      if (roomId !== null && !this.canUseRoomTimeline(roomId)) this.pushRoomState(roomId);\n    }\n  }, {\n    key: \"flushRoomState\",\n    value: function () {\n      var _flushRoomState = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var events, _iterator6, _step6, eventTypeMap, _iterator7, _step7, stateKeyMap;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.prev = 0;\n            case 1:\n              _context15.next = 3;\n              return Promise.all(_toConsumableArray(this.pushRoomStateTasks));\n            case 3:\n              if (this.pushRoomStateTasks.size > 0) {\n                _context15.next = 1;\n                break;\n              }\n            case 4:\n              events = [];\n              _iterator6 = _createForOfIteratorHelper(this.pushRoomStateResult.values());\n              try {\n                for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n                  eventTypeMap = _step6.value;\n                  _iterator7 = _createForOfIteratorHelper(eventTypeMap.values());\n                  try {\n                    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n                      stateKeyMap = _step7.value;\n                      events.push.apply(events, _toConsumableArray(stateKeyMap.values()));\n                    }\n                  } catch (err) {\n                    _iterator7.e(err);\n                  } finally {\n                    _iterator7.f();\n                  }\n                }\n              } catch (err) {\n                _iterator6.e(err);\n              } finally {\n                _iterator6.f();\n              }\n              _context15.next = 9;\n              return this.getWidgetVersions();\n            case 9:\n              if (!_context15.sent.includes(_ApiVersion.UnstableApiVersion.MSC2762_UPDATE_STATE)) {\n                _context15.next = 12;\n                break;\n              }\n              _context15.next = 12;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateState, {\n                state: events\n              });\n            case 12:\n              _context15.prev = 12;\n              this.flushRoomStateTask = null;\n              return _context15.finish(12);\n            case 15:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this, [[0,, 12, 15]]);\n      }));\n      function flushRoomState() {\n        return _flushRoomState.apply(this, arguments);\n      }\n      return flushRoomState;\n    }()\n    /**\n     * Read the room's state and push all entries that the widget is allowed to\n     * read through to the widget.\n     */\n  }, {\n    key: \"pushRoomState\",\n    value: function pushRoomState(roomId) {\n      var _this12 = this;\n      var _iterator8 = _createForOfIteratorHelper(this.allowedEvents),\n        _step8;\n      try {\n        var _loop = function _loop() {\n          var cap = _step8.value;\n          if (cap.kind === _WidgetEventCapability.EventKind.State && cap.direction === _WidgetEventCapability.EventDirection.Receive) {\n            var _cap$keyStr, _this12$flushRoomStat;\n            // Initiate the task\n            var events = _this12.driver.readRoomState(roomId, cap.eventType, (_cap$keyStr = cap.keyStr) !== null && _cap$keyStr !== void 0 ? _cap$keyStr : undefined);\n            var task = events.then(function (events) {\n              // When complete, queue the resulting events to be\n              // pushed to the widget\n              var _iterator9 = _createForOfIteratorHelper(events),\n                _step9;\n              try {\n                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {\n                  var event = _step9.value;\n                  var eventTypeMap = _this12.pushRoomStateResult.get(roomId);\n                  if (eventTypeMap === undefined) {\n                    eventTypeMap = new Map();\n                    _this12.pushRoomStateResult.set(roomId, eventTypeMap);\n                  }\n                  var stateKeyMap = eventTypeMap.get(cap.eventType);\n                  if (stateKeyMap === undefined) {\n                    stateKeyMap = new Map();\n                    eventTypeMap.set(cap.eventType, stateKeyMap);\n                  }\n                  if (!stateKeyMap.has(event.state_key)) stateKeyMap.set(event.state_key, event);\n                }\n              } catch (err) {\n                _iterator9.e(err);\n              } finally {\n                _iterator9.f();\n              }\n            }, function (e) {\n              return console.error(\"Failed to read room state for \".concat(roomId, \" (\").concat(cap.eventType, \", \").concat(cap.keyStr, \")\"), e);\n            }).then(function () {\n              // Mark request as no longer pending\n              _this12.pushRoomStateTasks[\"delete\"](task);\n            });\n\n            // Mark task as pending\n            _this12.pushRoomStateTasks.add(task);\n            // Assuming no other tasks are already happening concurrently,\n            // schedule the widget action that actually pushes the events\n            (_this12$flushRoomStat = _this12.flushRoomStateTask) !== null && _this12$flushRoomStat !== void 0 ? _this12$flushRoomStat : _this12.flushRoomStateTask = _this12.flushRoomState();\n            _this12.flushRoomStateTask[\"catch\"](function (e) {\n              return console.error(\"Failed to push room state\", e);\n            });\n          }\n        };\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          _loop();\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n    }\n\n    /**\n     * Feeds a room state update to the widget. As a client you are expected to\n     * call this for every state update in every room to which you are joined or\n     * invited.\n     * @param {IRoomEvent} rawEvent The state event corresponding to the updated\n     *   room state entry.\n     * @returns {Promise<void>} Resolves when delivered or if the widget is not\n     *   able to receive the room state due to permissions, rejects if the\n     *   widget failed to handle the update.\n     */\n  }, {\n    key: \"feedStateUpdate\",\n    value: function () {\n      var _feedStateUpdate = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee16(rawEvent) {\n        var eventTypeMap, stateKeyMap;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              if (!(rawEvent.state_key === undefined)) {\n                _context16.next = 2;\n                break;\n              }\n              throw new Error(\"Not a state event\");\n            case 2:\n              if (!((rawEvent.room_id === this.viewedRoomId || this.canUseRoomTimeline(rawEvent.room_id)) && this.canReceiveStateEvent(rawEvent.type, rawEvent.state_key))) {\n                _context16.next = 21;\n                break;\n              }\n              if (!(this.pushRoomStateTasks.size === 0)) {\n                _context16.next = 11;\n                break;\n              }\n              _context16.next = 6;\n              return this.getWidgetVersions();\n            case 6:\n              if (!_context16.sent.includes(_ApiVersion.UnstableApiVersion.MSC2762_UPDATE_STATE)) {\n                _context16.next = 9;\n                break;\n              }\n              _context16.next = 9;\n              return this.transport.send(_WidgetApiAction.WidgetApiToWidgetAction.UpdateState, {\n                state: [rawEvent]\n              });\n            case 9:\n              _context16.next = 21;\n              break;\n            case 11:\n              // Lump the update in with whatever data will be sent in the\n              // initial push later. Even if we set it to an \"outdated\" entry\n              // here, we can count on any newer entries being passed to this\n              // same method eventually; this won't cause stuck state.\n              eventTypeMap = this.pushRoomStateResult.get(rawEvent.room_id);\n              if (eventTypeMap === undefined) {\n                eventTypeMap = new Map();\n                this.pushRoomStateResult.set(rawEvent.room_id, eventTypeMap);\n              }\n              stateKeyMap = eventTypeMap.get(rawEvent.type);\n              if (stateKeyMap === undefined) {\n                stateKeyMap = new Map();\n                eventTypeMap.set(rawEvent.type, stateKeyMap);\n              }\n              if (!stateKeyMap.has(rawEvent.type)) stateKeyMap.set(rawEvent.state_key, rawEvent);\n            case 16:\n              _context16.next = 18;\n              return Promise.all(_toConsumableArray(this.pushRoomStateTasks));\n            case 18:\n              if (this.pushRoomStateTasks.size > 0) {\n                _context16.next = 16;\n                break;\n              }\n            case 19:\n              _context16.next = 21;\n              return this.flushRoomStateTask;\n            case 21:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this);\n      }));\n      function feedStateUpdate(_x16) {\n        return _feedStateUpdate.apply(this, arguments);\n      }\n      return feedStateUpdate;\n    }()\n  }]);\n  return ClientWidgetApi;\n}(_events.EventEmitter);\nexports.ClientWidgetApi = ClientWidgetApi;\n//# sourceMappingURL=ClientWidgetApi.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WidgetParser = void 0;\nvar _Widget = require(\"./Widget\");\nvar _url = require(\"./validation/url\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); } /*\n                                                                                                                                                                                                                                                                                                                                                                                               * Copyright 2020 The Matrix.org Foundation C.I.C.\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               * Licensed under the Apache License, Version 2.0 (the \"License\");\n                                                                                                                                                                                                                                                                                                                                                                                               * you may not use this file except in compliance with the License.\n                                                                                                                                                                                                                                                                                                                                                                                               * You may obtain a copy of the License at\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               *         http://www.apache.org/licenses/LICENSE-2.0\n                                                                                                                                                                                                                                                                                                                                                                                               *\n                                                                                                                                                                                                                                                                                                                                                                                               * Unless required by applicable law or agreed to in writing, software\n                                                                                                                                                                                                                                                                                                                                                                                               * distributed under the License is distributed on an \"AS IS\" BASIS,\n                                                                                                                                                                                                                                                                                                                                                                                               * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n                                                                                                                                                                                                                                                                                                                                                                                               * See the License for the specific language governing permissions and\n                                                                                                                                                                                                                                                                                                                                                                                               * limitations under the License.\n                                                                                                                                                                                                                                                                                                                                                                                               */\nvar WidgetParser = /*#__PURE__*/function () {\n  function WidgetParser() {\n    _classCallCheck(this, WidgetParser);\n  } // private constructor because this is a util class\n\n  /**\n   * Parses widgets from the \"m.widgets\" account data event. This will always\n   * return an array, though may be empty if no valid widgets were found.\n   * @param {IAccountDataWidgets} content The content of the \"m.widgets\" account data.\n   * @returns {Widget[]} The widgets in account data, or an empty array.\n   */\n  _createClass(WidgetParser, null, [{\n    key: \"parseAccountData\",\n    value: function parseAccountData(content) {\n      if (!content) return [];\n      var result = [];\n      for (var _i = 0, _Object$keys = Object.keys(content); _i < _Object$keys.length; _i++) {\n        var _widgetId = _Object$keys[_i];\n        var roughWidget = content[_widgetId];\n        if (!roughWidget) continue;\n        if (roughWidget.type !== \"m.widget\" && roughWidget.type !== \"im.vector.modular.widgets\") continue;\n        if (!roughWidget.sender) continue;\n        var probableWidgetId = roughWidget.state_key || roughWidget.id;\n        if (probableWidgetId !== _widgetId) continue;\n        var asStateEvent = {\n          content: roughWidget.content,\n          sender: roughWidget.sender,\n          type: \"m.widget\",\n          state_key: _widgetId,\n          event_id: \"$example\",\n          room_id: \"!example\",\n          origin_server_ts: 1\n        };\n        var widget = WidgetParser.parseRoomWidget(asStateEvent);\n        if (widget) result.push(widget);\n      }\n      return result;\n    }\n\n    /**\n     * Parses all the widgets possible in the given array. This will always return\n     * an array, though may be empty if no widgets could be parsed.\n     * @param {IStateEvent[]} currentState The room state to parse.\n     * @returns {Widget[]} The widgets in the state, or an empty array.\n     */\n  }, {\n    key: \"parseWidgetsFromRoomState\",\n    value: function parseWidgetsFromRoomState(currentState) {\n      if (!currentState) return [];\n      var result = [];\n      var _iterator = _createForOfIteratorHelper(currentState),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var state = _step.value;\n          var widget = WidgetParser.parseRoomWidget(state);\n          if (widget) result.push(widget);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return result;\n    }\n\n    /**\n     * Parses a state event into a widget. If the state event does not represent\n     * a widget (wrong event type, invalid widget, etc) then null is returned.\n     * @param {IStateEvent} stateEvent The state event.\n     * @returns {Widget|null} The widget, or null if invalid\n     */\n  }, {\n    key: \"parseRoomWidget\",\n    value: function parseRoomWidget(stateEvent) {\n      if (!stateEvent) return null;\n\n      // TODO: [Legacy] Remove legacy support\n      if (stateEvent.type !== \"m.widget\" && stateEvent.type !== \"im.vector.modular.widgets\") {\n        return null;\n      }\n\n      // Dev note: Throughout this function we have null safety to ensure that\n      // if the caller did not supply something useful that we don't error. This\n      // is done against the requirements of the interface because not everyone\n      // will have an interface to validate against.\n\n      var content = stateEvent.content || {};\n\n      // Form our best approximation of a widget with the information we have\n      var estimatedWidget = {\n        id: stateEvent.state_key,\n        creatorUserId: content[\"creatorUserId\"] || stateEvent.sender,\n        name: content[\"name\"],\n        type: content[\"type\"],\n        url: content[\"url\"],\n        waitForIframeLoad: content[\"waitForIframeLoad\"],\n        data: content[\"data\"]\n      };\n\n      // Finally, process that widget\n      return WidgetParser.processEstimatedWidget(estimatedWidget);\n    }\n  }, {\n    key: \"processEstimatedWidget\",\n    value: function processEstimatedWidget(widget) {\n      // Validate that the widget has the best chance of passing as a widget\n      if (!widget.id || !widget.creatorUserId || !widget.type) {\n        return null;\n      }\n      if (!(0, _url.isValidUrl)(widget.url)) {\n        return null;\n      }\n      // TODO: Validate data for known widget types\n      return new _Widget.Widget(widget);\n    }\n  }]);\n  return WidgetParser;\n}();\nexports.WidgetParser = WidgetParser;\n//# sourceMappingURL=WidgetParser.js.map","/** @license React v16.13.1\n * react-is.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';var b=\"function\"===typeof Symbol&&Symbol.for,c=b?Symbol.for(\"react.element\"):60103,d=b?Symbol.for(\"react.portal\"):60106,e=b?Symbol.for(\"react.fragment\"):60107,f=b?Symbol.for(\"react.strict_mode\"):60108,g=b?Symbol.for(\"react.profiler\"):60114,h=b?Symbol.for(\"react.provider\"):60109,k=b?Symbol.for(\"react.context\"):60110,l=b?Symbol.for(\"react.async_mode\"):60111,m=b?Symbol.for(\"react.concurrent_mode\"):60111,n=b?Symbol.for(\"react.forward_ref\"):60112,p=b?Symbol.for(\"react.suspense\"):60113,q=b?\nSymbol.for(\"react.suspense_list\"):60120,r=b?Symbol.for(\"react.memo\"):60115,t=b?Symbol.for(\"react.lazy\"):60116,v=b?Symbol.for(\"react.block\"):60121,w=b?Symbol.for(\"react.fundamental\"):60117,x=b?Symbol.for(\"react.responder\"):60118,y=b?Symbol.for(\"react.scope\"):60119;\nfunction z(a){if(\"object\"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}exports.AsyncMode=l;exports.ConcurrentMode=m;exports.ContextConsumer=k;exports.ContextProvider=h;exports.Element=c;exports.ForwardRef=n;exports.Fragment=e;exports.Lazy=t;exports.Memo=r;exports.Portal=d;\nexports.Profiler=g;exports.StrictMode=f;exports.Suspense=p;exports.isAsyncMode=function(a){return A(a)||z(a)===l};exports.isConcurrentMode=A;exports.isContextConsumer=function(a){return z(a)===k};exports.isContextProvider=function(a){return z(a)===h};exports.isElement=function(a){return\"object\"===typeof a&&null!==a&&a.$$typeof===c};exports.isForwardRef=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};exports.isLazy=function(a){return z(a)===t};\nexports.isMemo=function(a){return z(a)===r};exports.isPortal=function(a){return z(a)===d};exports.isProfiler=function(a){return z(a)===g};exports.isStrictMode=function(a){return z(a)===f};exports.isSuspense=function(a){return z(a)===p};\nexports.isValidElementType=function(a){return\"string\"===typeof a||\"function\"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||\"object\"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};exports.typeOf=z;\n","/*!\n\tautosize 4.0.4\n\tlicense: MIT\n\thttp://www.jacklmoore.com/autosize\n*/\n(function (global, factory) {\n\tif (typeof define === \"function\" && define.amd) {\n\t\tdefine(['module', 'exports'], factory);\n\t} else if (typeof exports !== \"undefined\") {\n\t\tfactory(module, exports);\n\t} else {\n\t\tvar mod = {\n\t\t\texports: {}\n\t\t};\n\t\tfactory(mod, mod.exports);\n\t\tglobal.autosize = mod.exports;\n\t}\n})(this, function (module, exports) {\n\t'use strict';\n\n\tvar map = typeof Map === \"function\" ? new Map() : function () {\n\t\tvar keys = [];\n\t\tvar values = [];\n\n\t\treturn {\n\t\t\thas: function has(key) {\n\t\t\t\treturn keys.indexOf(key) > -1;\n\t\t\t},\n\t\t\tget: function get(key) {\n\t\t\t\treturn values[keys.indexOf(key)];\n\t\t\t},\n\t\t\tset: function set(key, value) {\n\t\t\t\tif (keys.indexOf(key) === -1) {\n\t\t\t\t\tkeys.push(key);\n\t\t\t\t\tvalues.push(value);\n\t\t\t\t}\n\t\t\t},\n\t\t\tdelete: function _delete(key) {\n\t\t\t\tvar index = keys.indexOf(key);\n\t\t\t\tif (index > -1) {\n\t\t\t\t\tkeys.splice(index, 1);\n\t\t\t\t\tvalues.splice(index, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t}();\n\n\tvar createEvent = function createEvent(name) {\n\t\treturn new Event(name, { bubbles: true });\n\t};\n\ttry {\n\t\tnew Event('test');\n\t} catch (e) {\n\t\t// IE does not support `new Event()`\n\t\tcreateEvent = function createEvent(name) {\n\t\t\tvar evt = document.createEvent('Event');\n\t\t\tevt.initEvent(name, true, false);\n\t\t\treturn evt;\n\t\t};\n\t}\n\n\tfunction assign(ta) {\n\t\tif (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || map.has(ta)) return;\n\n\t\tvar heightOffset = null;\n\t\tvar clientWidth = null;\n\t\tvar cachedHeight = null;\n\n\t\tfunction init() {\n\t\t\tvar style = window.getComputedStyle(ta, null);\n\n\t\t\tif (style.resize === 'vertical') {\n\t\t\t\tta.style.resize = 'none';\n\t\t\t} else if (style.resize === 'both') {\n\t\t\t\tta.style.resize = 'horizontal';\n\t\t\t}\n\n\t\t\tif (style.boxSizing === 'content-box') {\n\t\t\t\theightOffset = -(parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));\n\t\t\t} else {\n\t\t\t\theightOffset = parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth);\n\t\t\t}\n\t\t\t// Fix when a textarea is not on document body and heightOffset is Not a Number\n\t\t\tif (isNaN(heightOffset)) {\n\t\t\t\theightOffset = 0;\n\t\t\t}\n\n\t\t\tupdate();\n\t\t}\n\n\t\tfunction changeOverflow(value) {\n\t\t\t{\n\t\t\t\t// Chrome/Safari-specific fix:\n\t\t\t\t// When the textarea y-overflow is hidden, Chrome/Safari do not reflow the text to account for the space\n\t\t\t\t// made available by removing the scrollbar. The following forces the necessary text reflow.\n\t\t\t\tvar width = ta.style.width;\n\t\t\t\tta.style.width = '0px';\n\t\t\t\t// Force reflow:\n\t\t\t\t/* jshint ignore:start */\n\t\t\t\tta.offsetWidth;\n\t\t\t\t/* jshint ignore:end */\n\t\t\t\tta.style.width = width;\n\t\t\t}\n\n\t\t\tta.style.overflowY = value;\n\t\t}\n\n\t\tfunction getParentOverflows(el) {\n\t\t\tvar arr = [];\n\n\t\t\twhile (el && el.parentNode && el.parentNode instanceof Element) {\n\t\t\t\tif (el.parentNode.scrollTop) {\n\t\t\t\t\tarr.push({\n\t\t\t\t\t\tnode: el.parentNode,\n\t\t\t\t\t\tscrollTop: el.parentNode.scrollTop\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\tel = el.parentNode;\n\t\t\t}\n\n\t\t\treturn arr;\n\t\t}\n\n\t\tfunction resize() {\n\t\t\tif (ta.scrollHeight === 0) {\n\t\t\t\t// If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar overflows = getParentOverflows(ta);\n\t\t\tvar docTop = document.documentElement && document.documentElement.scrollTop; // Needed for Mobile IE (ticket #240)\n\n\t\t\tta.style.height = '';\n\t\t\tta.style.height = ta.scrollHeight + heightOffset + 'px';\n\n\t\t\t// used to check if an update is actually necessary on window.resize\n\t\t\tclientWidth = ta.clientWidth;\n\n\t\t\t// prevents scroll-position jumping\n\t\t\toverflows.forEach(function (el) {\n\t\t\t\tel.node.scrollTop = el.scrollTop;\n\t\t\t});\n\n\t\t\tif (docTop) {\n\t\t\t\tdocument.documentElement.scrollTop = docTop;\n\t\t\t}\n\t\t}\n\n\t\tfunction update() {\n\t\t\tresize();\n\n\t\t\tvar styleHeight = Math.round(parseFloat(ta.style.height));\n\t\t\tvar computed = window.getComputedStyle(ta, null);\n\n\t\t\t// Using offsetHeight as a replacement for computed.height in IE, because IE does not account use of border-box\n\t\t\tvar actualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(computed.height)) : ta.offsetHeight;\n\n\t\t\t// The actual height not matching the style height (set via the resize method) indicates that \n\t\t\t// the max-height has been exceeded, in which case the overflow should be allowed.\n\t\t\tif (actualHeight < styleHeight) {\n\t\t\t\tif (computed.overflowY === 'hidden') {\n\t\t\t\t\tchangeOverflow('scroll');\n\t\t\t\t\tresize();\n\t\t\t\t\tactualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Normally keep overflow set to hidden, to avoid flash of scrollbar as the textarea expands.\n\t\t\t\tif (computed.overflowY !== 'hidden') {\n\t\t\t\t\tchangeOverflow('hidden');\n\t\t\t\t\tresize();\n\t\t\t\t\tactualHeight = computed.boxSizing === 'content-box' ? Math.round(parseFloat(window.getComputedStyle(ta, null).height)) : ta.offsetHeight;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cachedHeight !== actualHeight) {\n\t\t\t\tcachedHeight = actualHeight;\n\t\t\t\tvar evt = createEvent('autosize:resized');\n\t\t\t\ttry {\n\t\t\t\t\tta.dispatchEvent(evt);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// Firefox will throw an error on dispatchEvent for a detached element\n\t\t\t\t\t// https://bugzilla.mozilla.org/show_bug.cgi?id=889376\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar pageResize = function pageResize() {\n\t\t\tif (ta.clientWidth !== clientWidth) {\n\t\t\t\tupdate();\n\t\t\t}\n\t\t};\n\n\t\tvar destroy = function (style) {\n\t\t\twindow.removeEventListener('resize', pageResize, false);\n\t\t\tta.removeEventListener('input', update, false);\n\t\t\tta.removeEventListener('keyup', update, false);\n\t\t\tta.removeEventListener('autosize:destroy', destroy, false);\n\t\t\tta.removeEventListener('autosize:update', update, false);\n\n\t\t\tObject.keys(style).forEach(function (key) {\n\t\t\t\tta.style[key] = style[key];\n\t\t\t});\n\n\t\t\tmap.delete(ta);\n\t\t}.bind(ta, {\n\t\t\theight: ta.style.height,\n\t\t\tresize: ta.style.resize,\n\t\t\toverflowY: ta.style.overflowY,\n\t\t\toverflowX: ta.style.overflowX,\n\t\t\twordWrap: ta.style.wordWrap\n\t\t});\n\n\t\tta.addEventListener('autosize:destroy', destroy, false);\n\n\t\t// IE9 does not fire onpropertychange or oninput for deletions,\n\t\t// so binding to onkeyup to catch most of those events.\n\t\t// There is no way that I know of to detect something like 'cut' in IE9.\n\t\tif ('onpropertychange' in ta && 'oninput' in ta) {\n\t\t\tta.addEventListener('keyup', update, false);\n\t\t}\n\n\t\twindow.addEventListener('resize', pageResize, false);\n\t\tta.addEventListener('input', update, false);\n\t\tta.addEventListener('autosize:update', update, false);\n\t\tta.style.overflowX = 'hidden';\n\t\tta.style.wordWrap = 'break-word';\n\n\t\tmap.set(ta, {\n\t\t\tdestroy: destroy,\n\t\t\tupdate: update\n\t\t});\n\n\t\tinit();\n\t}\n\n\tfunction destroy(ta) {\n\t\tvar methods = map.get(ta);\n\t\tif (methods) {\n\t\t\tmethods.destroy();\n\t\t}\n\t}\n\n\tfunction update(ta) {\n\t\tvar methods = map.get(ta);\n\t\tif (methods) {\n\t\t\tmethods.update();\n\t\t}\n\t}\n\n\tvar autosize = null;\n\n\t// Do nothing in Node.js environment and IE8 (or lower)\n\tif (typeof window === 'undefined' || typeof window.getComputedStyle !== 'function') {\n\t\tautosize = function autosize(el) {\n\t\t\treturn el;\n\t\t};\n\t\tautosize.destroy = function (el) {\n\t\t\treturn el;\n\t\t};\n\t\tautosize.update = function (el) {\n\t\t\treturn el;\n\t\t};\n\t} else {\n\t\tautosize = function autosize(el, options) {\n\t\t\tif (el) {\n\t\t\t\tArray.prototype.forEach.call(el.length ? el : [el], function (x) {\n\t\t\t\t\treturn assign(x, options);\n\t\t\t\t});\n\t\t\t}\n\t\t\treturn el;\n\t\t};\n\t\tautosize.destroy = function (el) {\n\t\t\tif (el) {\n\t\t\t\tArray.prototype.forEach.call(el.length ? el : [el], destroy);\n\t\t\t}\n\t\t\treturn el;\n\t\t};\n\t\tautosize.update = function (el) {\n\t\t\tif (el) {\n\t\t\t\tArray.prototype.forEach.call(el.length ? el : [el], update);\n\t\t\t}\n\t\t\treturn el;\n\t\t};\n\t}\n\n\texports.default = autosize;\n\tmodule.exports = exports['default'];\n});","// This code has been refactored for 140 bytes\n// You can see the original here: https://github.com/twolfson/computedStyle/blob/04cd1da2e30fa45844f95f5cb1ac898e9b9ef050/lib/computedStyle.js\nvar computedStyle = function (el, prop, getComputedStyle) {\n  getComputedStyle = window.getComputedStyle;\n\n  // In one fell swoop\n  return (\n    // If we have getComputedStyle\n    getComputedStyle ?\n      // Query it\n      // TODO: From CSS-Query notes, we might need (node, null) for FF\n      getComputedStyle(el) :\n\n    // Otherwise, we are in IE and use currentStyle\n      el.currentStyle\n  )[\n    // Switch to camelCase for CSSOM\n    // DEV: Grabbed from jQuery\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/css.js#L191-L194\n    // https://github.com/jquery/jquery/blob/1.9-stable/src/core.js#L593-L597\n    prop.replace(/-(\\w)/gi, function (word, letter) {\n      return letter.toUpperCase();\n    })\n  ];\n};\n\nmodule.exports = computedStyle;\n","// Load in dependencies\nvar computedStyle = require('computed-style');\n\n/**\n * Calculate the `line-height` of a given node\n * @param {HTMLElement} node Element to calculate line height of. Must be in the DOM.\n * @returns {Number} `line-height` of the element in pixels\n */\nfunction lineHeight(node) {\n  // Grab the line-height via style\n  var lnHeightStr = computedStyle(node, 'line-height');\n  var lnHeight = parseFloat(lnHeightStr, 10);\n\n  // If the lineHeight did not contain a unit (i.e. it was numeric), convert it to ems (e.g. '2.3' === '2.3em')\n  if (lnHeightStr === lnHeight + '') {\n    // Save the old lineHeight style and update the em unit to the element\n    var _lnHeightStyle = node.style.lineHeight;\n    node.style.lineHeight = lnHeightStr + 'em';\n\n    // Calculate the em based height\n    lnHeightStr = computedStyle(node, 'line-height');\n    lnHeight = parseFloat(lnHeightStr, 10);\n\n    // Revert the lineHeight style\n    if (_lnHeightStyle) {\n      node.style.lineHeight = _lnHeightStyle;\n    } else {\n      delete node.style.lineHeight;\n    }\n  }\n\n  // If the lineHeight is in `pt`, convert it to pixels (4px for 3pt)\n  // DEV: `em` units are converted to `pt` in IE6\n  // Conversion ratio from https://developer.mozilla.org/en-US/docs/Web/CSS/length\n  if (lnHeightStr.indexOf('pt') !== -1) {\n    lnHeight *= 4;\n    lnHeight /= 3;\n  // Otherwise, if the lineHeight is in `mm`, convert it to pixels (96px for 25.4mm)\n  } else if (lnHeightStr.indexOf('mm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 25.4;\n  // Otherwise, if the lineHeight is in `cm`, convert it to pixels (96px for 2.54cm)\n  } else if (lnHeightStr.indexOf('cm') !== -1) {\n    lnHeight *= 96;\n    lnHeight /= 2.54;\n  // Otherwise, if the lineHeight is in `in`, convert it to pixels (96px for 1in)\n  } else if (lnHeightStr.indexOf('in') !== -1) {\n    lnHeight *= 96;\n  // Otherwise, if the lineHeight is in `pc`, convert it to pixels (12pt for 1pc)\n  } else if (lnHeightStr.indexOf('pc') !== -1) {\n    lnHeight *= 16;\n  }\n\n  // Continue our computation\n  lnHeight = Math.round(lnHeight);\n\n  // If the line-height is \"normal\", calculate by font-size\n  if (lnHeightStr === 'normal') {\n    // Create a temporary node\n    var nodeName = node.nodeName;\n    var _node = document.createElement(nodeName);\n    _node.innerHTML = '&nbsp;';\n\n    // If we have a text area, reset it to only 1 row\n    // https://github.com/twolfson/line-height/issues/4\n    if (nodeName.toUpperCase() === 'TEXTAREA') {\n      _node.setAttribute('rows', '1');\n    }\n\n    // Set the font-size of the element\n    var fontSizeStr = computedStyle(node, 'font-size');\n    _node.style.fontSize = fontSizeStr;\n\n    // Remove default padding/border which can affect offset height\n    // https://github.com/twolfson/line-height/issues/4\n    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/offsetHeight\n    _node.style.padding = '0px';\n    _node.style.border = '0px';\n\n    // Append it to the body\n    var body = document.body;\n    body.appendChild(_node);\n\n    // Assume the line height of the element is the height\n    var height = _node.offsetHeight;\n    lnHeight = height;\n\n    // Remove our child from the DOM\n    body.removeChild(_node);\n  }\n\n  // Return the calculated height\n  return lnHeight;\n}\n\n// Export lineHeight\nmodule.exports = lineHeight;\n","\"use strict\";\nvar __extends = (this && this.__extends) || (function () {\n    var extendStatics = Object.setPrototypeOf ||\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __assign = (this && this.__assign) || Object.assign || function(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n        s = arguments[i];\n        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n            t[p] = s[p];\n    }\n    return t;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)\n            t[p[i]] = s[p[i]];\n    return t;\n};\nexports.__esModule = true;\nvar React = require(\"react\");\nvar PropTypes = require(\"prop-types\");\nvar autosize = require(\"autosize\");\nvar _getLineHeight = require(\"line-height\");\nvar getLineHeight = _getLineHeight;\nvar RESIZED = \"autosize:resized\";\n/**\n * A light replacement for built-in textarea component\n * which automaticaly adjusts its height to match the content\n */\nvar TextareaAutosizeClass = /** @class */ (function (_super) {\n    __extends(TextareaAutosizeClass, _super);\n    function TextareaAutosizeClass() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.state = {\n            lineHeight: null\n        };\n        _this.textarea = null;\n        _this.onResize = function (e) {\n            if (_this.props.onResize) {\n                _this.props.onResize(e);\n            }\n        };\n        _this.updateLineHeight = function () {\n            if (_this.textarea) {\n                _this.setState({\n                    lineHeight: getLineHeight(_this.textarea)\n                });\n            }\n        };\n        _this.onChange = function (e) {\n            var onChange = _this.props.onChange;\n            _this.currentValue = e.currentTarget.value;\n            onChange && onChange(e);\n        };\n        return _this;\n    }\n    TextareaAutosizeClass.prototype.componentDidMount = function () {\n        var _this = this;\n        var _a = this.props, maxRows = _a.maxRows, async = _a.async;\n        if (typeof maxRows === \"number\") {\n            this.updateLineHeight();\n        }\n        if (typeof maxRows === \"number\" || async) {\n            /*\n              the defer is needed to:\n                - force \"autosize\" to activate the scrollbar when this.props.maxRows is passed\n                - support StyledComponents (see #71)\n            */\n            setTimeout(function () { return _this.textarea && autosize(_this.textarea); });\n        }\n        else {\n            this.textarea && autosize(this.textarea);\n        }\n        if (this.textarea) {\n            this.textarea.addEventListener(RESIZED, this.onResize);\n        }\n    };\n    TextareaAutosizeClass.prototype.componentWillUnmount = function () {\n        if (this.textarea) {\n            this.textarea.removeEventListener(RESIZED, this.onResize);\n            autosize.destroy(this.textarea);\n        }\n    };\n    TextareaAutosizeClass.prototype.render = function () {\n        var _this = this;\n        var _a = this, _b = _a.props, onResize = _b.onResize, maxRows = _b.maxRows, onChange = _b.onChange, style = _b.style, innerRef = _b.innerRef, children = _b.children, props = __rest(_b, [\"onResize\", \"maxRows\", \"onChange\", \"style\", \"innerRef\", \"children\"]), lineHeight = _a.state.lineHeight;\n        var maxHeight = maxRows && lineHeight ? lineHeight * maxRows : null;\n        return (React.createElement(\"textarea\", __assign({}, props, { onChange: this.onChange, style: maxHeight ? __assign({}, style, { maxHeight: maxHeight }) : style, ref: function (element) {\n                _this.textarea = element;\n                if (typeof _this.props.innerRef === 'function') {\n                    _this.props.innerRef(element);\n                }\n                else if (_this.props.innerRef) {\n                    _this.props.innerRef.current = element;\n                }\n            } }), children));\n    };\n    TextareaAutosizeClass.prototype.componentDidUpdate = function () {\n        this.textarea && autosize.update(this.textarea);\n    };\n    TextareaAutosizeClass.defaultProps = {\n        rows: 1,\n        async: false\n    };\n    TextareaAutosizeClass.propTypes = {\n        rows: PropTypes.number,\n        maxRows: PropTypes.number,\n        onResize: PropTypes.func,\n        innerRef: PropTypes.any,\n        async: PropTypes.bool\n    };\n    return TextareaAutosizeClass;\n}(React.Component));\nexports.TextareaAutosize = React.forwardRef(function (props, ref) {\n    return React.createElement(TextareaAutosizeClass, __assign({}, props, { innerRef: ref }));\n});\n","\"use strict\";\nexports.__esModule = true;\nvar TextareaAutosize_1 = require(\"./TextareaAutosize\");\nexports[\"default\"] = TextareaAutosize_1.TextareaAutosize;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Input.scss';\n\nimport TextareaAutosize from 'react-autosize-textarea';\n\nfunction Input({\n  id, label, name, value, placeholder,\n  required, type, onChange, forwardRef,\n  resizable, minHeight, onResize, state,\n  onKeyDown, disabled, autoFocus,\n}) {\n  return (\n    <div className=\"input-container\">\n      { label !== '' && <label className=\"input__label text-b2\" htmlFor={id}>{label}</label> }\n      { resizable\n        ? (\n          <TextareaAutosize\n            dir=\"auto\"\n            style={{ minHeight: `${minHeight}px` }}\n            name={name}\n            id={id}\n            className={`input input--resizable${state !== 'normal' ? ` input--${state}` : ''}`}\n            ref={forwardRef}\n            type={type}\n            placeholder={placeholder}\n            required={required}\n            defaultValue={value}\n            autoComplete=\"off\"\n            onChange={onChange}\n            onResize={onResize}\n            onKeyDown={onKeyDown}\n            disabled={disabled}\n            autoFocus={autoFocus}\n          />\n        ) : (\n          <input\n            dir=\"auto\"\n            ref={forwardRef}\n            id={id}\n            name={name}\n            className={`input ${state !== 'normal' ? ` input--${state}` : ''}`}\n            type={type}\n            placeholder={placeholder}\n            required={required}\n            defaultValue={value}\n            autoComplete=\"off\"\n            onChange={onChange}\n            onKeyDown={onKeyDown}\n            disabled={disabled}\n            // eslint-disable-next-line jsx-a11y/no-autofocus\n            autoFocus={autoFocus}\n          />\n        )}\n    </div>\n  );\n}\n\nInput.defaultProps = {\n  id: null,\n  name: '',\n  label: '',\n  value: '',\n  placeholder: '',\n  type: 'text',\n  required: false,\n  onChange: null,\n  forwardRef: null,\n  resizable: false,\n  minHeight: 46,\n  onResize: null,\n  state: 'normal',\n  onKeyDown: null,\n  disabled: false,\n  autoFocus: false,\n};\n\nInput.propTypes = {\n  id: PropTypes.string,\n  name: PropTypes.string,\n  label: PropTypes.string,\n  value: PropTypes.string,\n  placeholder: PropTypes.string,\n  required: PropTypes.bool,\n  type: PropTypes.string,\n  onChange: PropTypes.func,\n  forwardRef: PropTypes.shape({}),\n  resizable: PropTypes.bool,\n  minHeight: PropTypes.number,\n  onResize: PropTypes.func,\n  state: PropTypes.oneOf(['normal', 'success', 'error']),\n  onKeyDown: PropTypes.func,\n  disabled: PropTypes.bool,\n  autoFocus: PropTypes.bool,\n};\n\nexport default Input;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './ScrollView.scss';\n\nconst ScrollView = React.forwardRef(({\n  horizontal, vertical, autoHide, invisible, onScroll, children,\n}, ref) => {\n  let scrollbarClasses = '';\n  if (horizontal) scrollbarClasses += ' scrollbar__h';\n  if (vertical) scrollbarClasses += ' scrollbar__v';\n  if (autoHide) scrollbarClasses += ' scrollbar--auto-hide';\n  if (invisible) scrollbarClasses += ' scrollbar--invisible';\n  return (\n    <div onScroll={onScroll} ref={ref} className={`scrollbar${scrollbarClasses}`}>\n      {children}\n    </div>\n  );\n});\n\nScrollView.defaultProps = {\n  horizontal: false,\n  vertical: true,\n  autoHide: false,\n  invisible: false,\n  onScroll: null,\n};\n\nScrollView.propTypes = {\n  horizontal: PropTypes.bool,\n  vertical: PropTypes.bool,\n  autoHide: PropTypes.bool,\n  invisible: PropTypes.bool,\n  onScroll: PropTypes.func,\n  children: PropTypes.node.isRequired,\n};\n\nexport default ScrollView;\n","import React, { useState, useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport './ContextMenu.scss';\n\nimport Tippy from '@tippyjs/react';\nimport 'tippy.js/animations/scale-extreme.css';\n\nimport Text from '../text/Text';\nimport Button from '../button/Button';\nimport ScrollView from '../scroll/ScrollView';\n\nfunction ContextMenu({\n  content, placement, maxWidth, render, afterToggle,\n}) {\n  const [isVisible, setVisibility] = useState(false);\n  const showMenu = () => setVisibility(true);\n  const hideMenu = () => setVisibility(false);\n\n  useEffect(() => {\n    if (afterToggle !== null) afterToggle(isVisible);\n  }, [isVisible]);\n\n  return (\n    <Tippy\n      animation=\"scale-extreme\"\n      className=\"context-menu\"\n      visible={isVisible}\n      onClickOutside={hideMenu}\n      content={<ScrollView invisible>{typeof content === 'function' ? content(hideMenu) : content}</ScrollView>}\n      placement={placement}\n      interactive\n      arrow={false}\n      maxWidth={maxWidth}\n      duration={200}\n    >\n      {render(isVisible ? hideMenu : showMenu)}\n    </Tippy>\n  );\n}\n\nContextMenu.defaultProps = {\n  maxWidth: 'unset',\n  placement: 'right',\n  afterToggle: null,\n};\n\nContextMenu.propTypes = {\n  content: PropTypes.oneOfType([\n    PropTypes.node,\n    PropTypes.func,\n  ]).isRequired,\n  placement: PropTypes.oneOf(['top', 'right', 'bottom', 'left']),\n  maxWidth: PropTypes.oneOfType([\n    PropTypes.string,\n    PropTypes.number,\n  ]),\n  render: PropTypes.func.isRequired,\n  afterToggle: PropTypes.func,\n};\n\nfunction MenuHeader({ children }) {\n  return (\n    <div className=\"context-menu__header\">\n      <Text variant=\"b3\">{ children }</Text>\n    </div>\n  );\n}\n\nMenuHeader.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nfunction MenuItem({\n  variant, iconSrc, type,\n  onClick, children, disabled,\n}) {\n  return (\n    <div className=\"context-menu__item\">\n      <Button\n        variant={variant}\n        iconSrc={iconSrc}\n        type={type}\n        onClick={onClick}\n        disabled={disabled}\n      >\n        { children }\n      </Button>\n    </div>\n  );\n}\n\nMenuItem.defaultProps = {\n  variant: 'surface',\n  iconSrc: null,\n  type: 'button',\n  disabled: false,\n  onClick: null,\n};\n\nMenuItem.propTypes = {\n  variant: PropTypes.oneOf(['surface', 'positive', 'caution', 'danger']),\n  iconSrc: PropTypes.string,\n  type: PropTypes.oneOf(['button', 'submit']),\n  onClick: PropTypes.func,\n  children: PropTypes.node.isRequired,\n  disabled: PropTypes.bool,\n};\n\nfunction MenuBorder() {\n  return <div style={{ borderBottom: '1px solid var(--bg-surface-border)' }}> </div>;\n}\n\nexport {\n  ContextMenu as default, MenuHeader, MenuItem, MenuBorder,\n};\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport './Header.scss';\n\nfunction Header({ children }) {\n  return (\n    <div className=\"header\">\n      {children}\n    </div>\n  );\n}\n\nHeader.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nfunction TitleWrapper({ children }) {\n  return (\n    <div className=\"header__title-wrapper\">\n      {children}\n    </div>\n  );\n}\n\nTitleWrapper.propTypes = {\n  children: PropTypes.node.isRequired,\n};\n\nexport { Header as default, TitleWrapper };\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = findTabbableDescendants;\n/*!\n * Adapted from jQuery UI core\n *\n * http://jqueryui.com\n *\n * Copyright 2014 jQuery Foundation and other contributors\n * Released under the MIT license.\n * http://jquery.org/license\n *\n * http://api.jqueryui.com/category/ui-core/\n */\n\nvar DISPLAY_NONE = \"none\";\nvar DISPLAY_CONTENTS = \"contents\";\n\nvar tabbableNode = /input|select|textarea|button|object|iframe/;\n\nfunction isNotOverflowing(element, style) {\n  return style.getPropertyValue(\"overflow\") !== \"visible\" ||\n  // if 'overflow: visible' set, check if there is actually any overflow\n  element.scrollWidth <= 0 && element.scrollHeight <= 0;\n}\n\nfunction hidesContents(element) {\n  var zeroSize = element.offsetWidth <= 0 && element.offsetHeight <= 0;\n\n  // If the node is empty, this is good enough\n  if (zeroSize && !element.innerHTML) return true;\n\n  try {\n    // Otherwise we need to check some styles\n    var style = window.getComputedStyle(element);\n    var displayValue = style.getPropertyValue(\"display\");\n    return zeroSize ? displayValue !== DISPLAY_CONTENTS && isNotOverflowing(element, style) : displayValue === DISPLAY_NONE;\n  } catch (exception) {\n    // eslint-disable-next-line no-console\n    console.warn(\"Failed to inspect element style\");\n    return false;\n  }\n}\n\nfunction visible(element) {\n  var parentElement = element;\n  var rootNode = element.getRootNode && element.getRootNode();\n  while (parentElement) {\n    if (parentElement === document.body) break;\n\n    // if we are not hidden yet, skip to checking outside the Web Component\n    if (rootNode && parentElement === rootNode) parentElement = rootNode.host.parentNode;\n\n    if (hidesContents(parentElement)) return false;\n    parentElement = parentElement.parentNode;\n  }\n  return true;\n}\n\nfunction focusable(element, isTabIndexNotNaN) {\n  var nodeName = element.nodeName.toLowerCase();\n  var res = tabbableNode.test(nodeName) && !element.disabled || (nodeName === \"a\" ? element.href || isTabIndexNotNaN : isTabIndexNotNaN);\n  return res && visible(element);\n}\n\nfunction tabbable(element) {\n  var tabIndex = element.getAttribute(\"tabindex\");\n  if (tabIndex === null) tabIndex = undefined;\n  var isTabIndexNaN = isNaN(tabIndex);\n  return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);\n}\n\nfunction findTabbableDescendants(element) {\n  var descendants = [].slice.call(element.querySelectorAll(\"*\"), 0).reduce(function (finished, el) {\n    return finished.concat(!el.shadowRoot ? [el] : findTabbableDescendants(el.shadowRoot));\n  }, []);\n  return descendants.filter(tabbable);\n}\nmodule.exports = exports[\"default\"];"],"file":"assets/index-71ZZmCGz.js"}